"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tw-elements";
exports.ids = ["vendor-chunks/tw-elements"];
exports.modules = {

/***/ "(ssr)/./node_modules/tw-elements/js/tw-elements.es.min.js":
/*!***********************************************************!*\
  !*** ./node_modules/tw-elements/js/tw-elements.es.min.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ qs),\n/* harmony export */   Carousel: () => (/* binding */ Z),\n/* harmony export */   Collapse: () => (/* binding */ pe),\n/* harmony export */   Dropdown: () => (/* binding */ X),\n/* harmony export */   Input: () => (/* binding */ $),\n/* harmony export */   Modal: () => (/* binding */ ai),\n/* harmony export */   Offcanvas: () => (/* binding */ _e),\n/* harmony export */   Popover: () => (/* binding */ Nn),\n/* harmony export */   Ripple: () => (/* binding */ Hn),\n/* harmony export */   ScrollSpy: () => (/* binding */ In),\n/* harmony export */   Tab: () => (/* binding */ Rn),\n/* harmony export */   Tooltip: () => (/* binding */ Qt),\n/* harmony export */   initTWE: () => (/* binding */ lc)\n/* harmony export */ });\nvar Yn = Object.defineProperty;\r\nvar Kn = (i, t, e) => t in i ? Yn(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;\r\nvar Ne = (i, t, e) => (Kn(i, typeof t != \"symbol\" ? t + \"\" : t, e), e);\r\n/*!\r\n* TW Elements\r\n* Version: FREE 2.0.0\r\n* \r\n* Copyright: Material Design for Bootstrap\r\n* https://mdbootstrap.com/\r\n* \r\n* Read the license: https://tw-elements.com/license/\r\n*\r\n*\r\n* Documentation: https://tw-elements.com/\r\n*\r\n* Support: https://mdbootstrap.com/support/cat/twe\r\n*\r\n* Contact: tailwind@mdbootstrap.com\r\n* \r\n*/\r\nconst Se = (() => {\r\n  const i = {};\r\n  let t = 1;\r\n  return {\r\n    set(e, s, n) {\r\n      typeof e[s] > \"u\" && (e[s] = {\r\n        key: s,\r\n        id: t\r\n      }, t++), i[e[s].id] = n;\r\n    },\r\n    get(e, s) {\r\n      if (!e || typeof e[s] > \"u\")\r\n        return null;\r\n      const n = e[s];\r\n      return n.key === s ? i[n.id] : null;\r\n    },\r\n    delete(e, s) {\r\n      if (typeof e[s] > \"u\")\r\n        return;\r\n      const n = e[s];\r\n      n.key === s && (delete i[n.id], delete e[s]);\r\n    }\r\n  };\r\n})(), V = {\r\n  setData(i, t, e) {\r\n    Se.set(i, t, e);\r\n  },\r\n  getData(i, t) {\r\n    return Se.get(i, t);\r\n  },\r\n  removeData(i, t) {\r\n    Se.delete(i, t);\r\n  }\r\n}, zn = 1e6, qn = 1e3, Ze = \"transitionend\", Xn = (i) => i == null ? `${i}` : {}.toString.call(i).match(/\\s([a-z]+)/i)[1].toLowerCase(), Gn = (i) => {\r\n  do\r\n    i += Math.floor(Math.random() * zn);\r\n  while (document.getElementById(i));\r\n  return i;\r\n}, ks = (i) => {\r\n  let t = i.getAttribute(\"data-twe-target\");\r\n  if (!t || t === \"#\") {\r\n    let e = i.getAttribute(\"href\");\r\n    if (!e || !e.includes(\"#\") && !e.startsWith(\".\"))\r\n      return null;\r\n    e.includes(\"#\") && !e.startsWith(\"#\") && (e = `#${e.split(\"#\")[1]}`), t = e && e !== \"#\" ? e.trim() : null;\r\n  }\r\n  return t;\r\n}, ci = (i) => {\r\n  const t = ks(i);\r\n  return t && document.querySelector(t) ? t : null;\r\n}, nt = (i) => {\r\n  const t = ks(i);\r\n  return t ? document.querySelector(t) : null;\r\n}, Je = (i) => {\r\n  if (!i)\r\n    return 0;\r\n  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(i);\r\n  const s = Number.parseFloat(t), n = Number.parseFloat(e);\r\n  return !s && !n ? 0 : (t = t.split(\",\")[0], e = e.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * qn);\r\n}, Ps = (i) => {\r\n  i.dispatchEvent(new Event(Ze));\r\n}, St = (i) => !i || typeof i != \"object\" ? !1 : (typeof i.jquery < \"u\" && (i = i[0]), typeof i.nodeType < \"u\"), rt = (i) => St(i) ? i.jquery ? i[0] : i : typeof i == \"string\" && i.length > 0 ? document.querySelector(i) : null, R = (i, t, e) => {\r\n  Object.keys(e).forEach((s) => {\r\n    const n = e[s], r = t[s], o = r && St(r) ? \"element\" : Xn(r);\r\n    if (!new RegExp(n).test(o))\r\n      throw new Error(\r\n        `${i.toUpperCase()}: Option \"${s}\" provided type \"${o}\" but expected type \"${n}\".`\r\n      );\r\n  });\r\n}, kt = (i) => {\r\n  if (!i)\r\n    return !1;\r\n  if (i.style && i.parentNode && i.parentNode.style) {\r\n    const t = getComputedStyle(i), e = getComputedStyle(i.parentNode);\r\n    return t.display !== \"none\" && e.display !== \"none\" && t.visibility !== \"hidden\";\r\n  }\r\n  return !1;\r\n}, gt = (i) => !i || i.nodeType !== Node.ELEMENT_NODE || i.classList.contains(\"disabled\") ? !0 : typeof i.disabled < \"u\" ? i.disabled : i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\", Ms = (i) => {\r\n  if (!document.documentElement.attachShadow)\r\n    return null;\r\n  if (typeof i.getRootNode == \"function\") {\r\n    const t = i.getRootNode();\r\n    return t instanceof ShadowRoot ? t : null;\r\n  }\r\n  return i instanceof ShadowRoot ? i : i.parentNode ? Ms(i.parentNode) : null;\r\n}, me = () => function() {\r\n}, Xt = (i) => {\r\n  i.offsetHeight;\r\n}, Hs = () => {\r\n  const { jQuery: i } = window;\r\n  return i && !document.body.hasAttribute(\"data-twe-no-jquery\") ? i : null;\r\n}, Le = [], Vs = (i) => {\r\n  document.readyState === \"loading\" ? (Le.length || document.addEventListener(\"DOMContentLoaded\", () => {\r\n    Le.forEach((t) => t());\r\n  }), Le.push(i)) : i();\r\n}, M = () => document.documentElement.dir === \"rtl\", Ft = (i) => document.createElement(i), _t = (i) => {\r\n  typeof i == \"function\" && i();\r\n}, Ws = (i, t, e = !0) => {\r\n  if (!e) {\r\n    _t(i);\r\n    return;\r\n  }\r\n  const s = 5, n = Je(t) + s;\r\n  let r = !1;\r\n  const o = ({ target: a }) => {\r\n    a === t && (r = !0, t.removeEventListener(Ze, o), _t(i));\r\n  };\r\n  t.addEventListener(Ze, o), setTimeout(() => {\r\n    r || Ps(t);\r\n  }, n);\r\n}, Bs = (i, t, e, s) => {\r\n  let n = i.indexOf(t);\r\n  if (n === -1)\r\n    return i[!e && s ? i.length - 1 : 0];\r\n  const r = i.length;\r\n  return n += e ? 1 : -1, s && (n = (n + r) % r), i[Math.max(0, Math.min(n, r - 1))];\r\n}, Qn = /[^.]*(?=\\..*)\\.|.*/, Zn = /\\..*/, Jn = /::\\d+$/, $e = {};\r\nlet ki = 1;\r\nconst tr = {\r\n  mouseenter: \"mouseover\",\r\n  mouseleave: \"mouseout\"\r\n}, er = /^(mouseenter|mouseleave)/i, js = /* @__PURE__ */ new Set([\r\n  \"click\",\r\n  \"dblclick\",\r\n  \"mouseup\",\r\n  \"mousedown\",\r\n  \"contextmenu\",\r\n  \"mousewheel\",\r\n  \"DOMMouseScroll\",\r\n  \"mouseover\",\r\n  \"mouseout\",\r\n  \"mousemove\",\r\n  \"selectstart\",\r\n  \"selectend\",\r\n  \"keydown\",\r\n  \"keypress\",\r\n  \"keyup\",\r\n  \"orientationchange\",\r\n  \"touchstart\",\r\n  \"touchmove\",\r\n  \"touchend\",\r\n  \"touchcancel\",\r\n  \"pointerdown\",\r\n  \"pointermove\",\r\n  \"pointerup\",\r\n  \"pointerleave\",\r\n  \"pointercancel\",\r\n  \"gesturestart\",\r\n  \"gesturechange\",\r\n  \"gestureend\",\r\n  \"focus\",\r\n  \"blur\",\r\n  \"change\",\r\n  \"reset\",\r\n  \"select\",\r\n  \"submit\",\r\n  \"focusin\",\r\n  \"focusout\",\r\n  \"load\",\r\n  \"unload\",\r\n  \"beforeunload\",\r\n  \"resize\",\r\n  \"move\",\r\n  \"DOMContentLoaded\",\r\n  \"readystatechange\",\r\n  \"error\",\r\n  \"abort\",\r\n  \"scroll\"\r\n]);\r\nfunction Us(i, t) {\r\n  return t && `${t}::${ki++}` || i.uidEvent || ki++;\r\n}\r\nfunction Fs(i) {\r\n  const t = Us(i);\r\n  return i.uidEvent = t, $e[t] = $e[t] || {}, $e[t];\r\n}\r\nfunction ir(i, t) {\r\n  return function e(s) {\r\n    return s.delegateTarget = i, e.oneOff && d.off(i, s.type, t), t.apply(i, [s]);\r\n  };\r\n}\r\nfunction sr(i, t, e) {\r\n  return function s(n) {\r\n    const r = i.querySelectorAll(t);\r\n    for (let { target: o } = n; o && o !== this; o = o.parentNode)\r\n      for (let a = r.length; a--; \"\")\r\n        if (r[a] === o)\r\n          return n.delegateTarget = o, s.oneOff && d.off(i, n.type, e), e.apply(o, [n]);\r\n    return null;\r\n  };\r\n}\r\nfunction Ys(i, t, e = null) {\r\n  const s = Object.keys(i);\r\n  for (let n = 0, r = s.length; n < r; n++) {\r\n    const o = i[s[n]];\r\n    if (o.originalHandler === t && o.delegationSelector === e)\r\n      return o;\r\n  }\r\n  return null;\r\n}\r\nfunction Ks(i, t, e) {\r\n  const s = typeof t == \"string\", n = s ? e : t;\r\n  let r = zs(i);\r\n  return js.has(r) || (r = i), [s, n, r];\r\n}\r\nfunction Pi(i, t, e, s, n) {\r\n  if (typeof t != \"string\" || !i)\r\n    return;\r\n  if (e || (e = s, s = null), er.test(t)) {\r\n    const g = (O) => function(T) {\r\n      if (!T.relatedTarget || T.relatedTarget !== T.delegateTarget && !T.delegateTarget.contains(T.relatedTarget))\r\n        return O.call(this, T);\r\n    };\r\n    s ? s = g(s) : e = g(e);\r\n  }\r\n  const [r, o, a] = Ks(\r\n    t,\r\n    e,\r\n    s\r\n  ), l = Fs(i), u = l[a] || (l[a] = {}), c = Ys(\r\n    u,\r\n    o,\r\n    r ? e : null\r\n  );\r\n  if (c) {\r\n    c.oneOff = c.oneOff && n;\r\n    return;\r\n  }\r\n  const f = Us(\r\n    o,\r\n    t.replace(Qn, \"\")\r\n  ), v = r ? sr(i, e, s) : ir(i, e);\r\n  v.delegationSelector = r ? e : null, v.originalHandler = o, v.oneOff = n, v.uidEvent = f, u[f] = v, i.addEventListener(a, v, r);\r\n}\r\nfunction ti(i, t, e, s, n) {\r\n  const r = Ys(t[e], s, n);\r\n  r && (i.removeEventListener(e, r, !!n), delete t[e][r.uidEvent]);\r\n}\r\nfunction nr(i, t, e, s) {\r\n  const n = t[e] || {};\r\n  Object.keys(n).forEach((r) => {\r\n    if (r.includes(s)) {\r\n      const o = n[r];\r\n      ti(\r\n        i,\r\n        t,\r\n        e,\r\n        o.originalHandler,\r\n        o.delegationSelector\r\n      );\r\n    }\r\n  });\r\n}\r\nfunction zs(i) {\r\n  return i = i.replace(Zn, \"\"), tr[i] || i;\r\n}\r\nconst d = {\r\n  on(i, t, e, s) {\r\n    Pi(i, t, e, s, !1);\r\n  },\r\n  one(i, t, e, s) {\r\n    Pi(i, t, e, s, !0);\r\n  },\r\n  off(i, t, e, s) {\r\n    if (typeof t != \"string\" || !i)\r\n      return;\r\n    const [n, r, o] = Ks(\r\n      t,\r\n      e,\r\n      s\r\n    ), a = o !== t, l = Fs(i), u = t.startsWith(\".\");\r\n    if (typeof r < \"u\") {\r\n      if (!l || !l[o])\r\n        return;\r\n      ti(\r\n        i,\r\n        l,\r\n        o,\r\n        r,\r\n        n ? e : null\r\n      );\r\n      return;\r\n    }\r\n    u && Object.keys(l).forEach((f) => {\r\n      nr(\r\n        i,\r\n        l,\r\n        f,\r\n        t.slice(1)\r\n      );\r\n    });\r\n    const c = l[o] || {};\r\n    Object.keys(c).forEach((f) => {\r\n      const v = f.replace(Jn, \"\");\r\n      if (!a || t.includes(v)) {\r\n        const g = c[f];\r\n        ti(\r\n          i,\r\n          l,\r\n          o,\r\n          g.originalHandler,\r\n          g.delegationSelector\r\n        );\r\n      }\r\n    });\r\n  },\r\n  trigger(i, t, e) {\r\n    if (typeof t != \"string\" || !i)\r\n      return null;\r\n    const s = Hs(), n = zs(t), r = t !== n, o = js.has(n);\r\n    let a, l = !0, u = !0, c = !1, f = null;\r\n    return r && s && (a = s.Event(t, e), s(i).trigger(a), l = !a.isPropagationStopped(), u = !a.isImmediatePropagationStopped(), c = a.isDefaultPrevented()), o ? (f = document.createEvent(\"HTMLEvents\"), f.initEvent(n, l, !0)) : f = new CustomEvent(t, {\r\n      bubbles: l,\r\n      cancelable: !0\r\n    }), typeof e < \"u\" && Object.keys(e).forEach((v) => {\r\n      Object.defineProperty(f, v, {\r\n        get() {\r\n          return e[v];\r\n        }\r\n      });\r\n    }), c && f.preventDefault(), u && i.dispatchEvent(f), f.defaultPrevented && typeof a < \"u\" && a.preventDefault(), f;\r\n  }\r\n}, rr = \"5.1.3\";\r\nclass tt {\r\n  constructor(t) {\r\n    t = rt(t), t && (this._element = t, V.setData(this._element, this.constructor.DATA_KEY, this));\r\n  }\r\n  dispose() {\r\n    V.removeData(this._element, this.constructor.DATA_KEY), d.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {\r\n      this[t] = null;\r\n    });\r\n  }\r\n  _queueCallback(t, e, s = !0) {\r\n    Ws(t, e, s);\r\n  }\r\n  /** Static */\r\n  static getInstance(t) {\r\n    return V.getData(rt(t), this.DATA_KEY);\r\n  }\r\n  static getOrCreateInstance(t, e = {}) {\r\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\r\n  }\r\n  static get VERSION() {\r\n    return rr;\r\n  }\r\n  static get NAME() {\r\n    throw new Error(\r\n      'You have to implement the static method \"NAME\", for each component!'\r\n    );\r\n  }\r\n  static get DATA_KEY() {\r\n    return `twe.${this.NAME}`;\r\n  }\r\n  static get EVENT_KEY() {\r\n    return `.${this.DATA_KEY}`;\r\n  }\r\n}\r\nconst or = \"button\", ar = \"active\";\r\nclass qs extends tt {\r\n  // Getters\r\n  static get NAME() {\r\n    return or;\r\n  }\r\n  // Public\r\n  toggle() {\r\n    this._element.setAttribute(\r\n      \"aria-pressed\",\r\n      this._element.classList.toggle(ar)\r\n    );\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = qs.getOrCreateInstance(this);\r\n      t === \"toggle\" && e[t]();\r\n    });\r\n  }\r\n}\r\nvar k = \"top\", W = \"bottom\", B = \"right\", P = \"left\", ve = \"auto\", Pt = [k, W, B, P], Et = \"start\", Lt = \"end\", Xs = \"clippingParents\", di = \"viewport\", Ct = \"popper\", Gs = \"reference\", ei = /* @__PURE__ */ Pt.reduce(function(i, t) {\r\n  return i.concat([t + \"-\" + Et, t + \"-\" + Lt]);\r\n}, []), ui = /* @__PURE__ */ [].concat(Pt, [ve]).reduce(function(i, t) {\r\n  return i.concat([t, t + \"-\" + Et, t + \"-\" + Lt]);\r\n}, []), Qs = \"beforeRead\", Zs = \"read\", Js = \"afterRead\", tn = \"beforeMain\", en = \"main\", sn = \"afterMain\", nn = \"beforeWrite\", rn = \"write\", on = \"afterWrite\", an = [Qs, Zs, Js, tn, en, sn, nn, rn, on];\r\nfunction Q(i) {\r\n  return i ? (i.nodeName || \"\").toLowerCase() : null;\r\n}\r\nfunction j(i) {\r\n  if (i == null)\r\n    return window;\r\n  if (i.toString() !== \"[object Window]\") {\r\n    var t = i.ownerDocument;\r\n    return t && t.defaultView || window;\r\n  }\r\n  return i;\r\n}\r\nfunction vt(i) {\r\n  var t = j(i).Element;\r\n  return i instanceof t || i instanceof Element;\r\n}\r\nfunction F(i) {\r\n  var t = j(i).HTMLElement;\r\n  return i instanceof t || i instanceof HTMLElement;\r\n}\r\nfunction hi(i) {\r\n  if (typeof ShadowRoot > \"u\")\r\n    return !1;\r\n  var t = j(i).ShadowRoot;\r\n  return i instanceof t || i instanceof ShadowRoot;\r\n}\r\nfunction lr(i) {\r\n  var t = i.state;\r\n  Object.keys(t.elements).forEach(function(e) {\r\n    var s = t.styles[e] || {}, n = t.attributes[e] || {}, r = t.elements[e];\r\n    !F(r) || !Q(r) || (Object.assign(r.style, s), Object.keys(n).forEach(function(o) {\r\n      var a = n[o];\r\n      a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? \"\" : a);\r\n    }));\r\n  });\r\n}\r\nfunction cr(i) {\r\n  var t = i.state, e = {\r\n    popper: {\r\n      position: t.options.strategy,\r\n      left: \"0\",\r\n      top: \"0\",\r\n      margin: \"0\"\r\n    },\r\n    arrow: {\r\n      position: \"absolute\"\r\n    },\r\n    reference: {}\r\n  };\r\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\r\n    Object.keys(t.elements).forEach(function(s) {\r\n      var n = t.elements[s], r = t.attributes[s] || {}, o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = o.reduce(function(l, u) {\r\n        return l[u] = \"\", l;\r\n      }, {});\r\n      !F(n) || !Q(n) || (Object.assign(n.style, a), Object.keys(r).forEach(function(l) {\r\n        n.removeAttribute(l);\r\n      }));\r\n    });\r\n  };\r\n}\r\nconst fi = {\r\n  name: \"applyStyles\",\r\n  enabled: !0,\r\n  phase: \"write\",\r\n  fn: lr,\r\n  effect: cr,\r\n  requires: [\"computeStyles\"]\r\n};\r\nfunction G(i) {\r\n  return i.split(\"-\")[0];\r\n}\r\nvar mt = Math.max, Ee = Math.min, $t = Math.round;\r\nfunction ii() {\r\n  var i = navigator.userAgentData;\r\n  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {\r\n    return t.brand + \"/\" + t.version;\r\n  }).join(\" \") : navigator.userAgent;\r\n}\r\nfunction ln() {\r\n  return !/^((?!chrome|android).)*safari/i.test(ii());\r\n}\r\nfunction It(i, t, e) {\r\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\r\n  var s = i.getBoundingClientRect(), n = 1, r = 1;\r\n  t && F(i) && (n = i.offsetWidth > 0 && $t(s.width) / i.offsetWidth || 1, r = i.offsetHeight > 0 && $t(s.height) / i.offsetHeight || 1);\r\n  var o = vt(i) ? j(i) : window, a = o.visualViewport, l = !ln() && e, u = (s.left + (l && a ? a.offsetLeft : 0)) / n, c = (s.top + (l && a ? a.offsetTop : 0)) / r, f = s.width / n, v = s.height / r;\r\n  return {\r\n    width: f,\r\n    height: v,\r\n    top: c,\r\n    right: u + f,\r\n    bottom: c + v,\r\n    left: u,\r\n    x: u,\r\n    y: c\r\n  };\r\n}\r\nfunction pi(i) {\r\n  var t = It(i), e = i.offsetWidth, s = i.offsetHeight;\r\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {\r\n    x: i.offsetLeft,\r\n    y: i.offsetTop,\r\n    width: e,\r\n    height: s\r\n  };\r\n}\r\nfunction cn(i, t) {\r\n  var e = t.getRootNode && t.getRootNode();\r\n  if (i.contains(t))\r\n    return !0;\r\n  if (e && hi(e)) {\r\n    var s = t;\r\n    do {\r\n      if (s && i.isSameNode(s))\r\n        return !0;\r\n      s = s.parentNode || s.host;\r\n    } while (s);\r\n  }\r\n  return !1;\r\n}\r\nfunction J(i) {\r\n  return j(i).getComputedStyle(i);\r\n}\r\nfunction dr(i) {\r\n  return [\"table\", \"td\", \"th\"].indexOf(Q(i)) >= 0;\r\n}\r\nfunction ot(i) {\r\n  return ((vt(i) ? i.ownerDocument : (\r\n    // $FlowFixMe[prop-missing]\r\n    i.document\r\n  )) || window.document).documentElement;\r\n}\r\nfunction be(i) {\r\n  return Q(i) === \"html\" ? i : (\r\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\r\n    // $FlowFixMe[incompatible-return]\r\n    // $FlowFixMe[prop-missing]\r\n    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node\r\n    i.parentNode || // DOM Element detected\r\n    (hi(i) ? i.host : null) || // ShadowRoot detected\r\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\r\n    ot(i)\r\n  );\r\n}\r\nfunction Mi(i) {\r\n  return !F(i) || // https://github.com/popperjs/popper-core/issues/837\r\n  J(i).position === \"fixed\" ? null : i.offsetParent;\r\n}\r\nfunction ur(i) {\r\n  var t = /firefox/i.test(ii()), e = /Trident/i.test(ii());\r\n  if (e && F(i)) {\r\n    var s = J(i);\r\n    if (s.position === \"fixed\")\r\n      return null;\r\n  }\r\n  var n = be(i);\r\n  for (hi(n) && (n = n.host); F(n) && [\"html\", \"body\"].indexOf(Q(n)) < 0; ) {\r\n    var r = J(n);\r\n    if (r.transform !== \"none\" || r.perspective !== \"none\" || r.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(r.willChange) !== -1 || t && r.willChange === \"filter\" || t && r.filter && r.filter !== \"none\")\r\n      return n;\r\n    n = n.parentNode;\r\n  }\r\n  return null;\r\n}\r\nfunction Gt(i) {\r\n  for (var t = j(i), e = Mi(i); e && dr(e) && J(e).position === \"static\"; )\r\n    e = Mi(e);\r\n  return e && (Q(e) === \"html\" || Q(e) === \"body\" && J(e).position === \"static\") ? t : e || ur(i) || t;\r\n}\r\nfunction _i(i) {\r\n  return [\"top\", \"bottom\"].indexOf(i) >= 0 ? \"x\" : \"y\";\r\n}\r\nfunction zt(i, t, e) {\r\n  return mt(i, Ee(t, e));\r\n}\r\nfunction hr(i, t, e) {\r\n  var s = zt(i, t, e);\r\n  return s > e ? e : s;\r\n}\r\nfunction dn() {\r\n  return {\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n    left: 0\r\n  };\r\n}\r\nfunction un(i) {\r\n  return Object.assign({}, dn(), i);\r\n}\r\nfunction hn(i, t) {\r\n  return t.reduce(function(e, s) {\r\n    return e[s] = i, e;\r\n  }, {});\r\n}\r\nvar fr = function(t, e) {\r\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\r\n    placement: e.placement\r\n  })) : t, un(typeof t != \"number\" ? t : hn(t, Pt));\r\n};\r\nfunction pr(i) {\r\n  var t, e = i.state, s = i.name, n = i.options, r = e.elements.arrow, o = e.modifiersData.popperOffsets, a = G(e.placement), l = _i(a), u = [P, B].indexOf(a) >= 0, c = u ? \"height\" : \"width\";\r\n  if (!(!r || !o)) {\r\n    var f = fr(n.padding, e), v = pi(r), g = l === \"y\" ? k : P, O = l === \"y\" ? W : B, T = e.rects.reference[c] + e.rects.reference[l] - o[l] - e.rects.popper[c], A = o[l] - e.rects.reference[l], D = Gt(r), L = D ? l === \"y\" ? D.clientHeight || 0 : D.clientWidth || 0 : 0, m = T / 2 - A / 2, p = f[g], _ = L - v[c] - f[O], b = L / 2 - v[c] / 2 + m, w = zt(p, b, _), C = l;\r\n    e.modifiersData[s] = (t = {}, t[C] = w, t.centerOffset = w - b, t);\r\n  }\r\n}\r\nfunction _r(i) {\r\n  var t = i.state, e = i.options, s = e.element, n = s === void 0 ? \"[data-popper-arrow]\" : s;\r\n  n != null && (typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n) || cn(t.elements.popper, n) && (t.elements.arrow = n));\r\n}\r\nconst fn = {\r\n  name: \"arrow\",\r\n  enabled: !0,\r\n  phase: \"main\",\r\n  fn: pr,\r\n  effect: _r,\r\n  requires: [\"popperOffsets\"],\r\n  requiresIfExists: [\"preventOverflow\"]\r\n};\r\nfunction Rt(i) {\r\n  return i.split(\"-\")[1];\r\n}\r\nvar gr = {\r\n  top: \"auto\",\r\n  right: \"auto\",\r\n  bottom: \"auto\",\r\n  left: \"auto\"\r\n};\r\nfunction mr(i, t) {\r\n  var e = i.x, s = i.y, n = t.devicePixelRatio || 1;\r\n  return {\r\n    x: $t(e * n) / n || 0,\r\n    y: $t(s * n) / n || 0\r\n  };\r\n}\r\nfunction Hi(i) {\r\n  var t, e = i.popper, s = i.popperRect, n = i.placement, r = i.variation, o = i.offsets, a = i.position, l = i.gpuAcceleration, u = i.adaptive, c = i.roundOffsets, f = i.isFixed, v = o.x, g = v === void 0 ? 0 : v, O = o.y, T = O === void 0 ? 0 : O, A = typeof c == \"function\" ? c({\r\n    x: g,\r\n    y: T\r\n  }) : {\r\n    x: g,\r\n    y: T\r\n  };\r\n  g = A.x, T = A.y;\r\n  var D = o.hasOwnProperty(\"x\"), L = o.hasOwnProperty(\"y\"), m = P, p = k, _ = window;\r\n  if (u) {\r\n    var b = Gt(e), w = \"clientHeight\", C = \"clientWidth\";\r\n    if (b === j(e) && (b = ot(e), J(b).position !== \"static\" && a === \"absolute\" && (w = \"scrollHeight\", C = \"scrollWidth\")), b = b, n === k || (n === P || n === B) && r === Lt) {\r\n      p = W;\r\n      var y = f && b === _ && _.visualViewport ? _.visualViewport.height : (\r\n        // $FlowFixMe[prop-missing]\r\n        b[w]\r\n      );\r\n      T -= y - s.height, T *= l ? 1 : -1;\r\n    }\r\n    if (n === P || (n === k || n === W) && r === Lt) {\r\n      m = B;\r\n      var N = f && b === _ && _.visualViewport ? _.visualViewport.width : (\r\n        // $FlowFixMe[prop-missing]\r\n        b[C]\r\n      );\r\n      g -= N - s.width, g *= l ? 1 : -1;\r\n    }\r\n  }\r\n  var S = Object.assign({\r\n    position: a\r\n  }, u && gr), x = c === !0 ? mr({\r\n    x: g,\r\n    y: T\r\n  }, j(e)) : {\r\n    x: g,\r\n    y: T\r\n  };\r\n  if (g = x.x, T = x.y, l) {\r\n    var I;\r\n    return Object.assign({}, S, (I = {}, I[p] = L ? \"0\" : \"\", I[m] = D ? \"0\" : \"\", I.transform = (_.devicePixelRatio || 1) <= 1 ? \"translate(\" + g + \"px, \" + T + \"px)\" : \"translate3d(\" + g + \"px, \" + T + \"px, 0)\", I));\r\n  }\r\n  return Object.assign({}, S, (t = {}, t[p] = L ? T + \"px\" : \"\", t[m] = D ? g + \"px\" : \"\", t.transform = \"\", t));\r\n}\r\nfunction Er(i) {\r\n  var t = i.state, e = i.options, s = e.gpuAcceleration, n = s === void 0 ? !0 : s, r = e.adaptive, o = r === void 0 ? !0 : r, a = e.roundOffsets, l = a === void 0 ? !0 : a, u = {\r\n    placement: G(t.placement),\r\n    variation: Rt(t.placement),\r\n    popper: t.elements.popper,\r\n    popperRect: t.rects.popper,\r\n    gpuAcceleration: n,\r\n    isFixed: t.options.strategy === \"fixed\"\r\n  };\r\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Hi(Object.assign({}, u, {\r\n    offsets: t.modifiersData.popperOffsets,\r\n    position: t.options.strategy,\r\n    adaptive: o,\r\n    roundOffsets: l\r\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Hi(Object.assign({}, u, {\r\n    offsets: t.modifiersData.arrow,\r\n    position: \"absolute\",\r\n    adaptive: !1,\r\n    roundOffsets: l\r\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\r\n    \"data-popper-placement\": t.placement\r\n  });\r\n}\r\nconst gi = {\r\n  name: \"computeStyles\",\r\n  enabled: !0,\r\n  phase: \"beforeWrite\",\r\n  fn: Er,\r\n  data: {}\r\n};\r\nvar se = {\r\n  passive: !0\r\n};\r\nfunction vr(i) {\r\n  var t = i.state, e = i.instance, s = i.options, n = s.scroll, r = n === void 0 ? !0 : n, o = s.resize, a = o === void 0 ? !0 : o, l = j(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper);\r\n  return r && u.forEach(function(c) {\r\n    c.addEventListener(\"scroll\", e.update, se);\r\n  }), a && l.addEventListener(\"resize\", e.update, se), function() {\r\n    r && u.forEach(function(c) {\r\n      c.removeEventListener(\"scroll\", e.update, se);\r\n    }), a && l.removeEventListener(\"resize\", e.update, se);\r\n  };\r\n}\r\nconst mi = {\r\n  name: \"eventListeners\",\r\n  enabled: !0,\r\n  phase: \"write\",\r\n  fn: function() {\r\n  },\r\n  effect: vr,\r\n  data: {}\r\n};\r\nvar br = {\r\n  left: \"right\",\r\n  right: \"left\",\r\n  bottom: \"top\",\r\n  top: \"bottom\"\r\n};\r\nfunction ue(i) {\r\n  return i.replace(/left|right|bottom|top/g, function(t) {\r\n    return br[t];\r\n  });\r\n}\r\nvar wr = {\r\n  start: \"end\",\r\n  end: \"start\"\r\n};\r\nfunction Vi(i) {\r\n  return i.replace(/start|end/g, function(t) {\r\n    return wr[t];\r\n  });\r\n}\r\nfunction Ei(i) {\r\n  var t = j(i), e = t.pageXOffset, s = t.pageYOffset;\r\n  return {\r\n    scrollLeft: e,\r\n    scrollTop: s\r\n  };\r\n}\r\nfunction vi(i) {\r\n  return It(ot(i)).left + Ei(i).scrollLeft;\r\n}\r\nfunction Tr(i, t) {\r\n  var e = j(i), s = ot(i), n = e.visualViewport, r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;\r\n  if (n) {\r\n    r = n.width, o = n.height;\r\n    var u = ln();\r\n    (u || !u && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\r\n  }\r\n  return {\r\n    width: r,\r\n    height: o,\r\n    x: a + vi(i),\r\n    y: l\r\n  };\r\n}\r\nfunction yr(i) {\r\n  var t, e = ot(i), s = Ei(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, r = mt(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = mt(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + vi(i), l = -s.scrollTop;\r\n  return J(n || e).direction === \"rtl\" && (a += mt(e.clientWidth, n ? n.clientWidth : 0) - r), {\r\n    width: r,\r\n    height: o,\r\n    x: a,\r\n    y: l\r\n  };\r\n}\r\nfunction bi(i) {\r\n  var t = J(i), e = t.overflow, s = t.overflowX, n = t.overflowY;\r\n  return /auto|scroll|overlay|hidden/.test(e + n + s);\r\n}\r\nfunction pn(i) {\r\n  return [\"html\", \"body\", \"#document\"].indexOf(Q(i)) >= 0 ? i.ownerDocument.body : F(i) && bi(i) ? i : pn(be(i));\r\n}\r\nfunction qt(i, t) {\r\n  var e;\r\n  t === void 0 && (t = []);\r\n  var s = pn(i), n = s === ((e = i.ownerDocument) == null ? void 0 : e.body), r = j(s), o = n ? [r].concat(r.visualViewport || [], bi(s) ? s : []) : s, a = t.concat(o);\r\n  return n ? a : (\r\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\r\n    a.concat(qt(be(o)))\r\n  );\r\n}\r\nfunction si(i) {\r\n  return Object.assign({}, i, {\r\n    left: i.x,\r\n    top: i.y,\r\n    right: i.x + i.width,\r\n    bottom: i.y + i.height\r\n  });\r\n}\r\nfunction Ar(i, t) {\r\n  var e = It(i, !1, t === \"fixed\");\r\n  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;\r\n}\r\nfunction Wi(i, t, e) {\r\n  return t === di ? si(Tr(i, e)) : vt(t) ? Ar(t, e) : si(yr(ot(i)));\r\n}\r\nfunction Cr(i) {\r\n  var t = qt(be(i)), e = [\"absolute\", \"fixed\"].indexOf(J(i).position) >= 0, s = e && F(i) ? Gt(i) : i;\r\n  return vt(s) ? t.filter(function(n) {\r\n    return vt(n) && cn(n, s) && Q(n) !== \"body\";\r\n  }) : [];\r\n}\r\nfunction Or(i, t, e, s) {\r\n  var n = t === \"clippingParents\" ? Cr(i) : [].concat(t), r = [].concat(n, [e]), o = r[0], a = r.reduce(function(l, u) {\r\n    var c = Wi(i, u, s);\r\n    return l.top = mt(c.top, l.top), l.right = Ee(c.right, l.right), l.bottom = Ee(c.bottom, l.bottom), l.left = mt(c.left, l.left), l;\r\n  }, Wi(i, o, s));\r\n  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;\r\n}\r\nfunction _n(i) {\r\n  var t = i.reference, e = i.element, s = i.placement, n = s ? G(s) : null, r = s ? Rt(s) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;\r\n  switch (n) {\r\n    case k:\r\n      l = {\r\n        x: o,\r\n        y: t.y - e.height\r\n      };\r\n      break;\r\n    case W:\r\n      l = {\r\n        x: o,\r\n        y: t.y + t.height\r\n      };\r\n      break;\r\n    case B:\r\n      l = {\r\n        x: t.x + t.width,\r\n        y: a\r\n      };\r\n      break;\r\n    case P:\r\n      l = {\r\n        x: t.x - e.width,\r\n        y: a\r\n      };\r\n      break;\r\n    default:\r\n      l = {\r\n        x: t.x,\r\n        y: t.y\r\n      };\r\n  }\r\n  var u = n ? _i(n) : null;\r\n  if (u != null) {\r\n    var c = u === \"y\" ? \"height\" : \"width\";\r\n    switch (r) {\r\n      case Et:\r\n        l[u] = l[u] - (t[c] / 2 - e[c] / 2);\r\n        break;\r\n      case Lt:\r\n        l[u] = l[u] + (t[c] / 2 - e[c] / 2);\r\n        break;\r\n    }\r\n  }\r\n  return l;\r\n}\r\nfunction xt(i, t) {\r\n  t === void 0 && (t = {});\r\n  var e = t, s = e.placement, n = s === void 0 ? i.placement : s, r = e.strategy, o = r === void 0 ? i.strategy : r, a = e.boundary, l = a === void 0 ? Xs : a, u = e.rootBoundary, c = u === void 0 ? di : u, f = e.elementContext, v = f === void 0 ? Ct : f, g = e.altBoundary, O = g === void 0 ? !1 : g, T = e.padding, A = T === void 0 ? 0 : T, D = un(typeof A != \"number\" ? A : hn(A, Pt)), L = v === Ct ? Gs : Ct, m = i.rects.popper, p = i.elements[O ? L : v], _ = Or(vt(p) ? p : p.contextElement || ot(i.elements.popper), l, c, o), b = It(i.elements.reference), w = _n({\r\n    reference: b,\r\n    element: m,\r\n    strategy: \"absolute\",\r\n    placement: n\r\n  }), C = si(Object.assign({}, m, w)), y = v === Ct ? C : b, N = {\r\n    top: _.top - y.top + D.top,\r\n    bottom: y.bottom - _.bottom + D.bottom,\r\n    left: _.left - y.left + D.left,\r\n    right: y.right - _.right + D.right\r\n  }, S = i.modifiersData.offset;\r\n  if (v === Ct && S) {\r\n    var x = S[n];\r\n    Object.keys(N).forEach(function(I) {\r\n      var at = [B, W].indexOf(I) >= 0 ? 1 : -1, lt = [k, W].indexOf(I) >= 0 ? \"y\" : \"x\";\r\n      N[I] += x[lt] * at;\r\n    });\r\n  }\r\n  return N;\r\n}\r\nfunction Dr(i, t) {\r\n  t === void 0 && (t = {});\r\n  var e = t, s = e.placement, n = e.boundary, r = e.rootBoundary, o = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, u = l === void 0 ? ui : l, c = Rt(s), f = c ? a ? ei : ei.filter(function(O) {\r\n    return Rt(O) === c;\r\n  }) : Pt, v = f.filter(function(O) {\r\n    return u.indexOf(O) >= 0;\r\n  });\r\n  v.length === 0 && (v = f);\r\n  var g = v.reduce(function(O, T) {\r\n    return O[T] = xt(i, {\r\n      placement: T,\r\n      boundary: n,\r\n      rootBoundary: r,\r\n      padding: o\r\n    })[G(T)], O;\r\n  }, {});\r\n  return Object.keys(g).sort(function(O, T) {\r\n    return g[O] - g[T];\r\n  });\r\n}\r\nfunction Nr(i) {\r\n  if (G(i) === ve)\r\n    return [];\r\n  var t = ue(i);\r\n  return [Vi(i), t, Vi(t)];\r\n}\r\nfunction Sr(i) {\r\n  var t = i.state, e = i.options, s = i.name;\r\n  if (!t.modifiersData[s]._skip) {\r\n    for (var n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !0 : o, l = e.fallbackPlacements, u = e.padding, c = e.boundary, f = e.rootBoundary, v = e.altBoundary, g = e.flipVariations, O = g === void 0 ? !0 : g, T = e.allowedAutoPlacements, A = t.options.placement, D = G(A), L = D === A, m = l || (L || !O ? [ue(A)] : Nr(A)), p = [A].concat(m).reduce(function(wt, et) {\r\n      return wt.concat(G(et) === ve ? Dr(t, {\r\n        placement: et,\r\n        boundary: c,\r\n        rootBoundary: f,\r\n        padding: u,\r\n        flipVariations: O,\r\n        allowedAutoPlacements: T\r\n      }) : et);\r\n    }, []), _ = t.rects.reference, b = t.rects.popper, w = /* @__PURE__ */ new Map(), C = !0, y = p[0], N = 0; N < p.length; N++) {\r\n      var S = p[N], x = G(S), I = Rt(S) === Et, at = [k, W].indexOf(x) >= 0, lt = at ? \"width\" : \"height\", H = xt(t, {\r\n        placement: S,\r\n        boundary: c,\r\n        rootBoundary: f,\r\n        altBoundary: v,\r\n        padding: u\r\n      }), Y = at ? I ? B : P : I ? W : k;\r\n      _[lt] > b[lt] && (Y = ue(Y));\r\n      var Zt = ue(Y), ct = [];\r\n      if (r && ct.push(H[x] <= 0), a && ct.push(H[Y] <= 0, H[Zt] <= 0), ct.every(function(wt) {\r\n        return wt;\r\n      })) {\r\n        y = S, C = !1;\r\n        break;\r\n      }\r\n      w.set(S, ct);\r\n    }\r\n    if (C)\r\n      for (var Jt = O ? 3 : 1, Ae = function(et) {\r\n        var Vt = p.find(function(ee) {\r\n          var dt = w.get(ee);\r\n          if (dt)\r\n            return dt.slice(0, et).every(function(Ce) {\r\n              return Ce;\r\n            });\r\n        });\r\n        if (Vt)\r\n          return y = Vt, \"break\";\r\n      }, Ht = Jt; Ht > 0; Ht--) {\r\n        var te = Ae(Ht);\r\n        if (te === \"break\")\r\n          break;\r\n      }\r\n    t.placement !== y && (t.modifiersData[s]._skip = !0, t.placement = y, t.reset = !0);\r\n  }\r\n}\r\nconst gn = {\r\n  name: \"flip\",\r\n  enabled: !0,\r\n  phase: \"main\",\r\n  fn: Sr,\r\n  requiresIfExists: [\"offset\"],\r\n  data: {\r\n    _skip: !1\r\n  }\r\n};\r\nfunction Bi(i, t, e) {\r\n  return e === void 0 && (e = {\r\n    x: 0,\r\n    y: 0\r\n  }), {\r\n    top: i.top - t.height - e.y,\r\n    right: i.right - t.width + e.x,\r\n    bottom: i.bottom - t.height + e.y,\r\n    left: i.left - t.width - e.x\r\n  };\r\n}\r\nfunction ji(i) {\r\n  return [k, B, W, P].some(function(t) {\r\n    return i[t] >= 0;\r\n  });\r\n}\r\nfunction Lr(i) {\r\n  var t = i.state, e = i.name, s = t.rects.reference, n = t.rects.popper, r = t.modifiersData.preventOverflow, o = xt(t, {\r\n    elementContext: \"reference\"\r\n  }), a = xt(t, {\r\n    altBoundary: !0\r\n  }), l = Bi(o, s), u = Bi(a, n, r), c = ji(l), f = ji(u);\r\n  t.modifiersData[e] = {\r\n    referenceClippingOffsets: l,\r\n    popperEscapeOffsets: u,\r\n    isReferenceHidden: c,\r\n    hasPopperEscaped: f\r\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\r\n    \"data-popper-reference-hidden\": c,\r\n    \"data-popper-escaped\": f\r\n  });\r\n}\r\nconst mn = {\r\n  name: \"hide\",\r\n  enabled: !0,\r\n  phase: \"main\",\r\n  requiresIfExists: [\"preventOverflow\"],\r\n  fn: Lr\r\n};\r\nfunction $r(i, t, e) {\r\n  var s = G(i), n = [P, k].indexOf(s) >= 0 ? -1 : 1, r = typeof e == \"function\" ? e(Object.assign({}, t, {\r\n    placement: i\r\n  })) : e, o = r[0], a = r[1];\r\n  return o = o || 0, a = (a || 0) * n, [P, B].indexOf(s) >= 0 ? {\r\n    x: a,\r\n    y: o\r\n  } : {\r\n    x: o,\r\n    y: a\r\n  };\r\n}\r\nfunction Ir(i) {\r\n  var t = i.state, e = i.options, s = i.name, n = e.offset, r = n === void 0 ? [0, 0] : n, o = ui.reduce(function(c, f) {\r\n    return c[f] = $r(f, t.rects, r), c;\r\n  }, {}), a = o[t.placement], l = a.x, u = a.y;\r\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += u), t.modifiersData[s] = o;\r\n}\r\nconst En = {\r\n  name: \"offset\",\r\n  enabled: !0,\r\n  phase: \"main\",\r\n  requires: [\"popperOffsets\"],\r\n  fn: Ir\r\n};\r\nfunction Rr(i) {\r\n  var t = i.state, e = i.name;\r\n  t.modifiersData[e] = _n({\r\n    reference: t.rects.reference,\r\n    element: t.rects.popper,\r\n    strategy: \"absolute\",\r\n    placement: t.placement\r\n  });\r\n}\r\nconst wi = {\r\n  name: \"popperOffsets\",\r\n  enabled: !0,\r\n  phase: \"read\",\r\n  fn: Rr,\r\n  data: {}\r\n};\r\nfunction xr(i) {\r\n  return i === \"x\" ? \"y\" : \"x\";\r\n}\r\nfunction kr(i) {\r\n  var t = i.state, e = i.options, s = i.name, n = e.mainAxis, r = n === void 0 ? !0 : n, o = e.altAxis, a = o === void 0 ? !1 : o, l = e.boundary, u = e.rootBoundary, c = e.altBoundary, f = e.padding, v = e.tether, g = v === void 0 ? !0 : v, O = e.tetherOffset, T = O === void 0 ? 0 : O, A = xt(t, {\r\n    boundary: l,\r\n    rootBoundary: u,\r\n    padding: f,\r\n    altBoundary: c\r\n  }), D = G(t.placement), L = Rt(t.placement), m = !L, p = _i(D), _ = xr(p), b = t.modifiersData.popperOffsets, w = t.rects.reference, C = t.rects.popper, y = typeof T == \"function\" ? T(Object.assign({}, t.rects, {\r\n    placement: t.placement\r\n  })) : T, N = typeof y == \"number\" ? {\r\n    mainAxis: y,\r\n    altAxis: y\r\n  } : Object.assign({\r\n    mainAxis: 0,\r\n    altAxis: 0\r\n  }, y), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, x = {\r\n    x: 0,\r\n    y: 0\r\n  };\r\n  if (b) {\r\n    if (r) {\r\n      var I, at = p === \"y\" ? k : P, lt = p === \"y\" ? W : B, H = p === \"y\" ? \"height\" : \"width\", Y = b[p], Zt = Y + A[at], ct = Y - A[lt], Jt = g ? -C[H] / 2 : 0, Ae = L === Et ? w[H] : C[H], Ht = L === Et ? -C[H] : -w[H], te = t.elements.arrow, wt = g && te ? pi(te) : {\r\n        width: 0,\r\n        height: 0\r\n      }, et = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : dn(), Vt = et[at], ee = et[lt], dt = zt(0, w[H], wt[H]), Ce = m ? w[H] / 2 - Jt - dt - Vt - N.mainAxis : Ae - dt - Vt - N.mainAxis, Vn = m ? -w[H] / 2 + Jt + dt + ee + N.mainAxis : Ht + dt + ee + N.mainAxis, Oe = t.elements.arrow && Gt(t.elements.arrow), Wn = Oe ? p === \"y\" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Oi = (I = S == null ? void 0 : S[p]) != null ? I : 0, Bn = Y + Ce - Oi - Wn, jn = Y + Vn - Oi, Di = zt(g ? Ee(Zt, Bn) : Zt, Y, g ? mt(ct, jn) : ct);\r\n      b[p] = Di, x[p] = Di - Y;\r\n    }\r\n    if (a) {\r\n      var Ni, Un = p === \"x\" ? k : P, Fn = p === \"x\" ? W : B, ut = b[_], ie = _ === \"y\" ? \"height\" : \"width\", Si = ut + A[Un], Li = ut - A[Fn], De = [k, P].indexOf(D) !== -1, $i = (Ni = S == null ? void 0 : S[_]) != null ? Ni : 0, Ii = De ? Si : ut - w[ie] - C[ie] - $i + N.altAxis, Ri = De ? ut + w[ie] + C[ie] - $i - N.altAxis : Li, xi = g && De ? hr(Ii, ut, Ri) : zt(g ? Ii : Si, ut, g ? Ri : Li);\r\n      b[_] = xi, x[_] = xi - ut;\r\n    }\r\n    t.modifiersData[s] = x;\r\n  }\r\n}\r\nconst vn = {\r\n  name: \"preventOverflow\",\r\n  enabled: !0,\r\n  phase: \"main\",\r\n  fn: kr,\r\n  requiresIfExists: [\"offset\"]\r\n};\r\nfunction Pr(i) {\r\n  return {\r\n    scrollLeft: i.scrollLeft,\r\n    scrollTop: i.scrollTop\r\n  };\r\n}\r\nfunction Mr(i) {\r\n  return i === j(i) || !F(i) ? Ei(i) : Pr(i);\r\n}\r\nfunction Hr(i) {\r\n  var t = i.getBoundingClientRect(), e = $t(t.width) / i.offsetWidth || 1, s = $t(t.height) / i.offsetHeight || 1;\r\n  return e !== 1 || s !== 1;\r\n}\r\nfunction Vr(i, t, e) {\r\n  e === void 0 && (e = !1);\r\n  var s = F(t), n = F(t) && Hr(t), r = ot(t), o = It(i, n, e), a = {\r\n    scrollLeft: 0,\r\n    scrollTop: 0\r\n  }, l = {\r\n    x: 0,\r\n    y: 0\r\n  };\r\n  return (s || !s && !e) && ((Q(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\r\n  bi(r)) && (a = Mr(t)), F(t) ? (l = It(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : r && (l.x = vi(r))), {\r\n    x: o.left + a.scrollLeft - l.x,\r\n    y: o.top + a.scrollTop - l.y,\r\n    width: o.width,\r\n    height: o.height\r\n  };\r\n}\r\nfunction Wr(i) {\r\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), s = [];\r\n  i.forEach(function(r) {\r\n    t.set(r.name, r);\r\n  });\r\n  function n(r) {\r\n    e.add(r.name);\r\n    var o = [].concat(r.requires || [], r.requiresIfExists || []);\r\n    o.forEach(function(a) {\r\n      if (!e.has(a)) {\r\n        var l = t.get(a);\r\n        l && n(l);\r\n      }\r\n    }), s.push(r);\r\n  }\r\n  return i.forEach(function(r) {\r\n    e.has(r.name) || n(r);\r\n  }), s;\r\n}\r\nfunction Br(i) {\r\n  var t = Wr(i);\r\n  return an.reduce(function(e, s) {\r\n    return e.concat(t.filter(function(n) {\r\n      return n.phase === s;\r\n    }));\r\n  }, []);\r\n}\r\nfunction jr(i) {\r\n  var t;\r\n  return function() {\r\n    return t || (t = new Promise(function(e) {\r\n      Promise.resolve().then(function() {\r\n        t = void 0, e(i());\r\n      });\r\n    })), t;\r\n  };\r\n}\r\nfunction Ur(i) {\r\n  var t = i.reduce(function(e, s) {\r\n    var n = e[s.name];\r\n    return e[s.name] = n ? Object.assign({}, n, s, {\r\n      options: Object.assign({}, n.options, s.options),\r\n      data: Object.assign({}, n.data, s.data)\r\n    }) : s, e;\r\n  }, {});\r\n  return Object.keys(t).map(function(e) {\r\n    return t[e];\r\n  });\r\n}\r\nvar Ui = {\r\n  placement: \"bottom\",\r\n  modifiers: [],\r\n  strategy: \"absolute\"\r\n};\r\nfunction Fi() {\r\n  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)\r\n    t[e] = arguments[e];\r\n  return !t.some(function(s) {\r\n    return !(s && typeof s.getBoundingClientRect == \"function\");\r\n  });\r\n}\r\nfunction we(i) {\r\n  i === void 0 && (i = {});\r\n  var t = i, e = t.defaultModifiers, s = e === void 0 ? [] : e, n = t.defaultOptions, r = n === void 0 ? Ui : n;\r\n  return function(a, l, u) {\r\n    u === void 0 && (u = r);\r\n    var c = {\r\n      placement: \"bottom\",\r\n      orderedModifiers: [],\r\n      options: Object.assign({}, Ui, r),\r\n      modifiersData: {},\r\n      elements: {\r\n        reference: a,\r\n        popper: l\r\n      },\r\n      attributes: {},\r\n      styles: {}\r\n    }, f = [], v = !1, g = {\r\n      state: c,\r\n      setOptions: function(D) {\r\n        var L = typeof D == \"function\" ? D(c.options) : D;\r\n        T(), c.options = Object.assign({}, r, c.options, L), c.scrollParents = {\r\n          reference: vt(a) ? qt(a) : a.contextElement ? qt(a.contextElement) : [],\r\n          popper: qt(l)\r\n        };\r\n        var m = Br(Ur([].concat(s, c.options.modifiers)));\r\n        return c.orderedModifiers = m.filter(function(p) {\r\n          return p.enabled;\r\n        }), O(), g.update();\r\n      },\r\n      // Sync update – it will always be executed, even if not necessary. This\r\n      // is useful for low frequency updates where sync behavior simplifies the\r\n      // logic.\r\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\r\n      // prefer the async Popper#update method\r\n      forceUpdate: function() {\r\n        if (!v) {\r\n          var D = c.elements, L = D.reference, m = D.popper;\r\n          if (Fi(L, m)) {\r\n            c.rects = {\r\n              reference: Vr(L, Gt(m), c.options.strategy === \"fixed\"),\r\n              popper: pi(m)\r\n            }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(N) {\r\n              return c.modifiersData[N.name] = Object.assign({}, N.data);\r\n            });\r\n            for (var p = 0; p < c.orderedModifiers.length; p++) {\r\n              if (c.reset === !0) {\r\n                c.reset = !1, p = -1;\r\n                continue;\r\n              }\r\n              var _ = c.orderedModifiers[p], b = _.fn, w = _.options, C = w === void 0 ? {} : w, y = _.name;\r\n              typeof b == \"function\" && (c = b({\r\n                state: c,\r\n                options: C,\r\n                name: y,\r\n                instance: g\r\n              }) || c);\r\n            }\r\n          }\r\n        }\r\n      },\r\n      // Async and optimistically optimized update – it will not be executed if\r\n      // not necessary (debounced to run at most once-per-tick)\r\n      update: jr(function() {\r\n        return new Promise(function(A) {\r\n          g.forceUpdate(), A(c);\r\n        });\r\n      }),\r\n      destroy: function() {\r\n        T(), v = !0;\r\n      }\r\n    };\r\n    if (!Fi(a, l))\r\n      return g;\r\n    g.setOptions(u).then(function(A) {\r\n      !v && u.onFirstUpdate && u.onFirstUpdate(A);\r\n    });\r\n    function O() {\r\n      c.orderedModifiers.forEach(function(A) {\r\n        var D = A.name, L = A.options, m = L === void 0 ? {} : L, p = A.effect;\r\n        if (typeof p == \"function\") {\r\n          var _ = p({\r\n            state: c,\r\n            name: D,\r\n            instance: g,\r\n            options: m\r\n          }), b = function() {\r\n          };\r\n          f.push(_ || b);\r\n        }\r\n      });\r\n    }\r\n    function T() {\r\n      f.forEach(function(A) {\r\n        return A();\r\n      }), f = [];\r\n    }\r\n    return g;\r\n  };\r\n}\r\nvar Fr = /* @__PURE__ */ we(), Yr = [mi, wi, gi, fi], Kr = /* @__PURE__ */ we({\r\n  defaultModifiers: Yr\r\n}), zr = [mi, wi, gi, fi, En, gn, vn, fn, mn], Ti = /* @__PURE__ */ we({\r\n  defaultModifiers: zr\r\n});\r\nconst bn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\r\n  __proto__: null,\r\n  afterMain: sn,\r\n  afterRead: Js,\r\n  afterWrite: on,\r\n  applyStyles: fi,\r\n  arrow: fn,\r\n  auto: ve,\r\n  basePlacements: Pt,\r\n  beforeMain: tn,\r\n  beforeRead: Qs,\r\n  beforeWrite: nn,\r\n  bottom: W,\r\n  clippingParents: Xs,\r\n  computeStyles: gi,\r\n  createPopper: Ti,\r\n  createPopperBase: Fr,\r\n  createPopperLite: Kr,\r\n  detectOverflow: xt,\r\n  end: Lt,\r\n  eventListeners: mi,\r\n  flip: gn,\r\n  hide: mn,\r\n  left: P,\r\n  main: en,\r\n  modifierPhases: an,\r\n  offset: En,\r\n  placements: ui,\r\n  popper: Ct,\r\n  popperGenerator: we,\r\n  popperOffsets: wi,\r\n  preventOverflow: vn,\r\n  read: Zs,\r\n  reference: Gs,\r\n  right: B,\r\n  start: Et,\r\n  top: k,\r\n  variationPlacements: ei,\r\n  viewport: di,\r\n  write: rn\r\n}, Symbol.toStringTag, { value: \"Module\" }));\r\nfunction Ie(i) {\r\n  return i === \"true\" ? !0 : i === \"false\" ? !1 : i === Number(i).toString() ? Number(i) : i === \"\" || i === \"null\" ? null : i;\r\n}\r\nfunction Re(i) {\r\n  return i.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);\r\n}\r\nconst E = {\r\n  setDataAttribute(i, t, e) {\r\n    i.setAttribute(`data-twe-${Re(t)}`, e);\r\n  },\r\n  removeDataAttribute(i, t) {\r\n    i.removeAttribute(`data-twe-${Re(t)}`);\r\n  },\r\n  getDataAttributes(i) {\r\n    if (!i)\r\n      return {};\r\n    const t = {};\r\n    return Object.keys(i.dataset).filter((e) => e.startsWith(\"twe\")).forEach((e) => {\r\n      if (e.startsWith(\"tweClass\"))\r\n        return;\r\n      let s = e.replace(/^twe/, \"\");\r\n      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Ie(i.dataset[e]);\r\n    }), t;\r\n  },\r\n  getDataClassAttributes(i) {\r\n    if (!i)\r\n      return {};\r\n    const t = {\r\n      ...i.dataset\r\n    };\r\n    return Object.keys(t).filter((e) => e.startsWith(\"tweClass\")).forEach((e) => {\r\n      let s = e.replace(/^tweClass/, \"\");\r\n      s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Ie(t[e]);\r\n    }), t;\r\n  },\r\n  getDataAttribute(i, t) {\r\n    return Ie(\r\n      i.getAttribute(`data-twe-${Re(t)}`)\r\n    );\r\n  },\r\n  offset(i) {\r\n    const t = i.getBoundingClientRect();\r\n    return {\r\n      top: t.top + document.body.scrollTop,\r\n      left: t.left + document.body.scrollLeft\r\n    };\r\n  },\r\n  position(i) {\r\n    return {\r\n      top: i.offsetTop,\r\n      left: i.offsetLeft\r\n    };\r\n  },\r\n  style(i, t) {\r\n    Object.assign(i.style, t);\r\n  },\r\n  toggleClass(i, t) {\r\n    i && xe(t).forEach((e) => {\r\n      i.classList.contains(e) ? i.classList.remove(e) : i.classList.add(e);\r\n    });\r\n  },\r\n  addClass(i, t) {\r\n    xe(t).forEach(\r\n      (e) => !i.classList.contains(e) && i.classList.add(e)\r\n    );\r\n  },\r\n  addStyle(i, t) {\r\n    Object.keys(t).forEach((e) => {\r\n      i.style[e] = t[e];\r\n    });\r\n  },\r\n  removeClass(i, t) {\r\n    xe(t).forEach(\r\n      (e) => i.classList.contains(e) && i.classList.remove(e)\r\n    );\r\n  },\r\n  hasClass(i, t) {\r\n    return i.classList.contains(t);\r\n  },\r\n  maxOffset(i) {\r\n    const t = i.getBoundingClientRect();\r\n    return {\r\n      top: t.top + Math.max(\r\n        document.body.scrollTop,\r\n        document.documentElement.scrollTop,\r\n        window.scrollY\r\n      ),\r\n      left: t.left + Math.max(\r\n        document.body.scrollLeft,\r\n        document.documentElement.scrollLeft,\r\n        window.scrollX\r\n      )\r\n    };\r\n  }\r\n};\r\nfunction xe(i) {\r\n  return typeof i == \"string\" ? i.split(\" \") : Array.isArray(i) ? i : !1;\r\n}\r\nconst qr = 3, h = {\r\n  closest(i, t) {\r\n    return i.closest(t);\r\n  },\r\n  matches(i, t) {\r\n    return i.matches(t);\r\n  },\r\n  find(i, t = document.documentElement) {\r\n    return [].concat(\r\n      ...Element.prototype.querySelectorAll.call(t, i)\r\n    );\r\n  },\r\n  findOne(i, t = document.documentElement) {\r\n    return Element.prototype.querySelector.call(t, i);\r\n  },\r\n  children(i, t) {\r\n    return [].concat(...i.children).filter((s) => s.matches(t));\r\n  },\r\n  parents(i, t) {\r\n    const e = [];\r\n    let s = i.parentNode;\r\n    for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== qr; )\r\n      this.matches(s, t) && e.push(s), s = s.parentNode;\r\n    return e;\r\n  },\r\n  prev(i, t) {\r\n    let e = i.previousElementSibling;\r\n    for (; e; ) {\r\n      if (e.matches(t))\r\n        return [e];\r\n      e = e.previousElementSibling;\r\n    }\r\n    return [];\r\n  },\r\n  next(i, t) {\r\n    let e = i.nextElementSibling;\r\n    for (; e; ) {\r\n      if (this.matches(e, t))\r\n        return [e];\r\n      e = e.nextElementSibling;\r\n    }\r\n    return [];\r\n  },\r\n  focusableChildren(i) {\r\n    const t = [\r\n      \"a\",\r\n      \"button\",\r\n      \"input\",\r\n      \"textarea\",\r\n      \"select\",\r\n      \"details\",\r\n      \"[tabindex]\",\r\n      '[contenteditable=\"true\"]'\r\n    ].map((e) => `${e}:not([tabindex^=\"-\"])`).join(\", \");\r\n    return this.find(t, i).filter(\r\n      (e) => !gt(e) && kt(e)\r\n    );\r\n  }\r\n}, ke = \"dropdown\", Xr = \"twe.dropdown\", bt = `.${Xr}`, yi = \".data-api\", he = \"Escape\", Yi = \"Space\", Ki = \"Tab\", ni = \"ArrowUp\", fe = \"ArrowDown\", Gr = 2, Qr = new RegExp(\r\n  `${ni}|${fe}|${he}`\r\n), Zr = `hide${bt}`, Jr = `hidden${bt}`, to = `show${bt}`, eo = `shown${bt}`, io = `click${bt}${yi}`, zi = `keydown${bt}${yi}`, so = `keyup${bt}${yi}`, it = \"show\", no = \"dropup\", ro = \"dropend\", oo = \"dropstart\", ao = \"[data-twe-navbar-ref]\", ne = \"[data-twe-dropdown-toggle-ref]\", Pe = \"[data-twe-dropdown-menu-ref]\", lo = \"[data-twe-navbar-nav-ref]\", co = \"[data-twe-dropdown-menu-ref] [data-twe-dropdown-item-ref]:not(.disabled):not(:disabled)\", uo = M() ? \"top-end\" : \"top-start\", ho = M() ? \"top-start\" : \"top-end\", fo = M() ? \"bottom-end\" : \"bottom-start\", po = M() ? \"bottom-start\" : \"bottom-end\", _o = M() ? \"left-start\" : \"right-start\", go = M() ? \"right-start\" : \"left-start\", mo = [{ opacity: \"0\" }, { opacity: \"1\" }], Eo = [{ opacity: \"1\" }, { opacity: \"0\" }], qi = {\r\n  iterations: 1,\r\n  easing: \"ease\",\r\n  fill: \"both\"\r\n}, vo = {\r\n  offset: [0, 2],\r\n  boundary: \"clippingParents\",\r\n  reference: \"toggle\",\r\n  display: \"dynamic\",\r\n  popperConfig: null,\r\n  autoClose: !0,\r\n  dropdownAnimation: \"on\",\r\n  animationDuration: 550\r\n}, bo = {\r\n  offset: \"(array|string|function)\",\r\n  boundary: \"(string|element)\",\r\n  reference: \"(string|element|object)\",\r\n  display: \"string\",\r\n  popperConfig: \"(null|object|function)\",\r\n  autoClose: \"(boolean|string)\",\r\n  dropdownAnimation: \"string\",\r\n  animationDuration: \"number\"\r\n};\r\nclass X extends tt {\r\n  constructor(t, e) {\r\n    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;\r\n    const s = window.matchMedia(\r\n      \"(prefers-reduced-motion: reduce)\"\r\n    ).matches;\r\n    this._animationCanPlay = this._config.dropdownAnimation === \"on\" && !s, this._didInit = !1, this._init();\r\n  }\r\n  // Getters\r\n  static get Default() {\r\n    return vo;\r\n  }\r\n  static get DefaultType() {\r\n    return bo;\r\n  }\r\n  static get NAME() {\r\n    return ke;\r\n  }\r\n  // Public\r\n  toggle() {\r\n    return this._isShown() ? this.hide() : this.show();\r\n  }\r\n  show() {\r\n    if (gt(this._element) || this._isShown(this._menu))\r\n      return;\r\n    const t = {\r\n      relatedTarget: this._element\r\n    };\r\n    if (d.trigger(\r\n      this._element,\r\n      to,\r\n      t\r\n    ).defaultPrevented)\r\n      return;\r\n    const s = X.getParentFromElement(this._element);\r\n    this._inNavbar ? E.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(s), \"ontouchstart\" in document.documentElement && !s.closest(lo) && [].concat(...document.body.children).forEach((n) => d.on(n, \"mouseover\", me)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.setAttribute(`data-twe-dropdown-${it}`, \"\"), this._animationCanPlay && this._menu.animate(mo, {\r\n      ...qi,\r\n      duration: this._config.animationDuration\r\n    }), this._element.setAttribute(`data-twe-dropdown-${it}`, \"\"), setTimeout(\r\n      () => {\r\n        d.trigger(this._element, eo, t);\r\n      },\r\n      this._animationCanPlay ? this._config.animationDuration : 0\r\n    );\r\n  }\r\n  hide() {\r\n    if (gt(this._element) || !this._isShown(this._menu))\r\n      return;\r\n    const t = {\r\n      relatedTarget: this._element\r\n    };\r\n    this._completeHide(t);\r\n  }\r\n  dispose() {\r\n    this._popper && this._popper.destroy(), super.dispose();\r\n  }\r\n  update() {\r\n    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\r\n  }\r\n  // Private\r\n  _init() {\r\n    this._didInit || (d.on(\r\n      document,\r\n      zi,\r\n      ne,\r\n      X.dataApiKeydownHandler\r\n    ), d.on(\r\n      document,\r\n      zi,\r\n      Pe,\r\n      X.dataApiKeydownHandler\r\n    ), d.on(document, io, X.clearMenus), d.on(document, so, X.clearMenus), this._didInit = !0);\r\n  }\r\n  _completeHide(t) {\r\n    this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\" || d.trigger(\r\n      this._element,\r\n      Zr,\r\n      t\r\n    ).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((s) => d.off(s, \"mouseover\", me)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(Eo, {\r\n      ...qi,\r\n      duration: this._config.animationDuration\r\n    })), setTimeout(\r\n      () => {\r\n        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-twe-dropdown-${it}`), this._element.removeAttribute(`data-twe-dropdown-${it}`), this._element.setAttribute(\"aria-expanded\", \"false\"), E.removeDataAttribute(this._menu, \"popper\"), d.trigger(this._element, Jr, t);\r\n      },\r\n      this._animationCanPlay ? this._config.animationDuration : 0\r\n    ));\r\n  }\r\n  _getConfig(t) {\r\n    if (t = {\r\n      ...this.constructor.Default,\r\n      ...E.getDataAttributes(this._element),\r\n      ...t\r\n    }, R(ke, t, this.constructor.DefaultType), typeof t.reference == \"object\" && !St(t.reference) && typeof t.reference.getBoundingClientRect != \"function\")\r\n      throw new TypeError(\r\n        `${ke.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\r\n      );\r\n    return t;\r\n  }\r\n  _createPopper(t) {\r\n    if (typeof bn > \"u\")\r\n      throw new TypeError(\r\n        \"Bootstrap's dropdowns require Popper (https://popper.js.org)\"\r\n      );\r\n    let e = this._element;\r\n    this._config.reference === \"parent\" ? e = t : St(this._config.reference) ? e = rt(this._config.reference) : typeof this._config.reference == \"object\" && (e = this._config.reference);\r\n    const s = this._getPopperConfig(), n = s.modifiers.find(\r\n      (r) => r.name === \"applyStyles\" && r.enabled === !1\r\n    );\r\n    this._popper = Ti(\r\n      e,\r\n      this._menu,\r\n      s\r\n    ), n && E.setDataAttribute(this._menu, \"popper\", \"static\");\r\n  }\r\n  _isShown(t = this._element) {\r\n    return t.dataset[`tweDropdown${it.charAt(0).toUpperCase() + it.slice(1)}`] === \"\";\r\n  }\r\n  _getMenuElement() {\r\n    return h.next(this._element, Pe)[0];\r\n  }\r\n  _getPlacement() {\r\n    const t = this._element.parentNode;\r\n    if (t.dataset.tweDropdownPosition === ro)\r\n      return _o;\r\n    if (t.dataset.tweDropdownPosition === oo)\r\n      return go;\r\n    const e = t.dataset.tweDropdownAlignment === \"end\";\r\n    return t.dataset.tweDropdownPosition === no ? e ? ho : uo : e ? po : fo;\r\n  }\r\n  _detectNavbar() {\r\n    return this._element.closest(ao) !== null;\r\n  }\r\n  _getOffset() {\r\n    const { offset: t } = this._config;\r\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\r\n  }\r\n  _getPopperConfig() {\r\n    const t = {\r\n      placement: this._getPlacement(),\r\n      modifiers: [\r\n        {\r\n          name: \"preventOverflow\",\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        },\r\n        {\r\n          name: \"offset\",\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        }\r\n      ]\r\n    };\r\n    return this._config.display === \"static\" && (t.modifiers = [\r\n      {\r\n        name: \"applyStyles\",\r\n        enabled: !1\r\n      }\r\n    ]), {\r\n      ...t,\r\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(t) : this._config.popperConfig\r\n    };\r\n  }\r\n  _selectMenuItem({ key: t, target: e }) {\r\n    const s = h.find(\r\n      co,\r\n      this._menu\r\n    ).filter(kt);\r\n    s.length && Bs(\r\n      s,\r\n      e,\r\n      t === fe,\r\n      !s.includes(e)\r\n    ).focus();\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = X.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n  static clearMenus(t) {\r\n    if (t && (t.button === Gr || t.type === \"keyup\" && t.key !== Ki))\r\n      return;\r\n    const e = h.find(ne);\r\n    for (let s = 0, n = e.length; s < n; s++) {\r\n      const r = X.getInstance(e[s]);\r\n      if (!r || r._config.autoClose === !1 || !r._isShown())\r\n        continue;\r\n      const o = {\r\n        relatedTarget: r._element\r\n      };\r\n      if (t) {\r\n        const a = t.composedPath(), l = a.includes(r._menu);\r\n        if (a.includes(r._element) || r._config.autoClose === \"inside\" && !l || r._config.autoClose === \"outside\" && l || r._menu.contains(t.target) && (t.type === \"keyup\" && t.key === Ki || /input|select|option|textarea|form/i.test(t.target.tagName)))\r\n          continue;\r\n        t.type === \"click\" && (o.clickEvent = t);\r\n      }\r\n      r._completeHide(o);\r\n    }\r\n  }\r\n  static getParentFromElement(t) {\r\n    return nt(t) || t.parentNode;\r\n  }\r\n  static dataApiKeydownHandler(t) {\r\n    if (/input|textarea/i.test(t.target.tagName) ? t.key === Yi || t.key !== he && (t.key !== fe && t.key !== ni || t.target.closest(Pe)) : !Qr.test(t.key))\r\n      return;\r\n    const e = this.dataset[`tweDropdown${it.charAt(0).toUpperCase() + it.slice(1)}`] === \"\";\r\n    if (!e && t.key === he || (t.preventDefault(), t.stopPropagation(), gt(this)))\r\n      return;\r\n    const s = this.matches(ne) ? this : h.prev(this, ne)[0], n = X.getOrCreateInstance(s);\r\n    if (t.key === he) {\r\n      n.hide();\r\n      return;\r\n    }\r\n    if (t.key === ni || t.key === fe) {\r\n      e || n.show(), n._selectMenuItem(t);\r\n      return;\r\n    }\r\n    (!e || t.key === Yi) && X.clearMenus();\r\n  }\r\n}\r\nconst Me = \"collapse\", wn = \"twe.collapse\", Te = `.${wn}`, Xi = {\r\n  toggle: !0,\r\n  parent: null\r\n}, wo = {\r\n  toggle: \"boolean\",\r\n  parent: \"(null|element)\"\r\n}, To = `show${Te}`, yo = `shown${Te}`, Ao = `hide${Te}`, Co = `hidden${Te}`, He = \"data-twe-collapse-show\", Gi = \"data-twe-collapse-collapsed\", re = \"data-twe-collapse-collapsing\", Oo = \"data-twe-collapse-horizontal\", Nt = \"data-twe-collapse-item\", Qi = `:scope [${Nt}] [${Nt}]`, Do = \"width\", No = \"height\", So = \"[data-twe-collapse-item][data-twe-collapse-show], [data-twe-collapse-item][data-twe-collapse-collapsing]\", Zi = \"[data-twe-collapse-init]\", Lo = {\r\n  visible: \"!visible\",\r\n  hidden: \"hidden\",\r\n  baseTransition: \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\r\n  collapsing: \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\r\n  collapsingHorizontal: \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"\r\n}, $o = {\r\n  visible: \"string\",\r\n  hidden: \"string\",\r\n  baseTransition: \"string\",\r\n  collapsing: \"string\",\r\n  collapsingHorizontal: \"string\"\r\n};\r\nclass pe extends tt {\r\n  constructor(t, e, s) {\r\n    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._triggerArray = [];\r\n    const n = h.find(Zi);\r\n    for (let r = 0, o = n.length; r < o; r++) {\r\n      const a = n[r], l = ci(a), u = h.find(l).filter(\r\n        (c) => c === this._element\r\n      );\r\n      l !== null && u.length && (this._selector = l, this._triggerArray.push(a));\r\n    }\r\n    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\r\n  }\r\n  // Getters\r\n  static get Default() {\r\n    return Xi;\r\n  }\r\n  static get NAME() {\r\n    return Me;\r\n  }\r\n  // Public\r\n  toggle() {\r\n    this._isShown() ? this.hide() : this.show();\r\n  }\r\n  show() {\r\n    if (this._isTransitioning || this._isShown())\r\n      return;\r\n    let t = [], e;\r\n    if (this._config.parent) {\r\n      const c = h.find(\r\n        Qi,\r\n        this._config.parent\r\n      );\r\n      t = h.find(\r\n        So,\r\n        this._config.parent\r\n      ).filter((f) => !c.includes(f));\r\n    }\r\n    const s = h.findOne(this._selector);\r\n    if (t.length) {\r\n      const c = t.find((f) => s !== f);\r\n      if (e = c ? pe.getInstance(c) : null, e && e._isTransitioning)\r\n        return;\r\n    }\r\n    if (d.trigger(this._element, To).defaultPrevented)\r\n      return;\r\n    t.forEach((c) => {\r\n      s !== c && pe.getOrCreateInstance(c, { toggle: !1 }).hide(), e || V.setData(c, wn, null);\r\n    });\r\n    const r = this._getDimension(), o = r === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\r\n    E.removeClass(this._element, this._classes.visible), E.removeClass(this._element, this._classes.hidden), E.addClass(this._element, o), this._element.removeAttribute(Nt), this._element.setAttribute(re, \"\"), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\r\n    const a = () => {\r\n      this._isTransitioning = !1, E.removeClass(this._element, this._classes.hidden), E.removeClass(this._element, o), E.addClass(this._element, this._classes.visible), this._element.removeAttribute(re), this._element.setAttribute(Nt, \"\"), this._element.setAttribute(He, \"\"), this._element.style[r] = \"\", d.trigger(this._element, yo);\r\n    }, u = `scroll${r[0].toUpperCase() + r.slice(1)}`;\r\n    this._queueCallback(a, this._element, !0), this._element.style[r] = `${this._element[u]}px`;\r\n  }\r\n  hide() {\r\n    if (this._isTransitioning || !this._isShown() || d.trigger(this._element, Ao).defaultPrevented)\r\n      return;\r\n    const e = this._getDimension(), s = e === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\r\n    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Xt(this._element), E.addClass(this._element, s), E.removeClass(this._element, this._classes.visible), E.removeClass(this._element, this._classes.hidden), this._element.setAttribute(re, \"\"), this._element.removeAttribute(Nt), this._element.removeAttribute(He);\r\n    const n = this._triggerArray.length;\r\n    for (let o = 0; o < n; o++) {\r\n      const a = this._triggerArray[o], l = nt(a);\r\n      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);\r\n    }\r\n    this._isTransitioning = !0;\r\n    const r = () => {\r\n      this._isTransitioning = !1, E.removeClass(this._element, s), E.addClass(this._element, this._classes.visible), E.addClass(this._element, this._classes.hidden), this._element.removeAttribute(re), this._element.setAttribute(Nt, \"\"), d.trigger(this._element, Co);\r\n    };\r\n    this._element.style[e] = \"\", this._queueCallback(r, this._element, !0);\r\n  }\r\n  _isShown(t = this._element) {\r\n    return t.hasAttribute(He);\r\n  }\r\n  // Private\r\n  _getConfig(t) {\r\n    return t = {\r\n      ...Xi,\r\n      ...E.getDataAttributes(this._element),\r\n      ...t\r\n    }, t.toggle = !!t.toggle, t.parent = rt(t.parent), R(Me, t, wo), t;\r\n  }\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...Lo,\r\n      ...e,\r\n      ...t\r\n    }, R(Me, t, $o), t;\r\n  }\r\n  _getDimension() {\r\n    return this._element.hasAttribute(Oo) ? Do : No;\r\n  }\r\n  _initializeChildren() {\r\n    if (!this._config.parent)\r\n      return;\r\n    const t = h.find(\r\n      Qi,\r\n      this._config.parent\r\n    );\r\n    h.find(Zi, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {\r\n      const s = nt(e);\r\n      s && this._addAriaAndCollapsedClass([e], this._isShown(s));\r\n    });\r\n  }\r\n  _addAriaAndCollapsedClass(t, e) {\r\n    t.length && t.forEach((s) => {\r\n      e ? s.removeAttribute(Gi) : s.setAttribute(`${Gi}`, \"\"), s.setAttribute(\"aria-expanded\", e);\r\n    });\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = {};\r\n      typeof t == \"string\" && /show|hide/.test(t) && (e.toggle = !1);\r\n      const s = pe.getOrCreateInstance(this, e);\r\n      if (typeof t == \"string\") {\r\n        if (typeof s[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        s[t]();\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Ji = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", ts = \".sticky-top\";\r\nclass ri {\r\n  constructor() {\r\n    this._element = document.body;\r\n  }\r\n  getWidth() {\r\n    const t = document.documentElement.clientWidth;\r\n    return Math.abs(window.innerWidth - t);\r\n  }\r\n  hide() {\r\n    const t = this.getWidth();\r\n    this._disableOverFlow(), this._setElementAttributes(\r\n      this._element,\r\n      \"paddingRight\",\r\n      (e) => e + t\r\n    ), this._setElementAttributes(\r\n      Ji,\r\n      \"paddingRight\",\r\n      (e) => e + t\r\n    ), this._setElementAttributes(\r\n      ts,\r\n      \"marginRight\",\r\n      (e) => e - t\r\n    );\r\n  }\r\n  _disableOverFlow() {\r\n    this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\r\n  }\r\n  _setElementAttributes(t, e, s) {\r\n    const n = this.getWidth(), r = (o) => {\r\n      if (o !== this._element && window.innerWidth > o.clientWidth + n)\r\n        return;\r\n      this._saveInitialAttribute(o, e);\r\n      const a = window.getComputedStyle(o)[e];\r\n      o.style[e] = `${s(\r\n        Number.parseFloat(a)\r\n      )}px`;\r\n    };\r\n    this._applyManipulationCallback(t, r);\r\n  }\r\n  reset() {\r\n    this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(Ji, \"paddingRight\"), this._resetElementAttributes(ts, \"marginRight\");\r\n  }\r\n  _saveInitialAttribute(t, e) {\r\n    const s = t.style[e];\r\n    s && E.setDataAttribute(t, e, s);\r\n  }\r\n  _resetElementAttributes(t, e) {\r\n    const s = (n) => {\r\n      const r = E.getDataAttribute(n, e);\r\n      typeof r > \"u\" ? n.style.removeProperty(e) : (E.removeDataAttribute(n, e), n.style[e] = r);\r\n    };\r\n    this._applyManipulationCallback(t, s);\r\n  }\r\n  _applyManipulationCallback(t, e) {\r\n    St(t) ? e(t) : h.find(t, this._element).forEach(e);\r\n  }\r\n  isOverflowing() {\r\n    return this.getWidth() > 0;\r\n  }\r\n}\r\nconst Io = {\r\n  isVisible: !0,\r\n  // if false, we use the backdrop helper without adding any element to the dom\r\n  isAnimated: !1,\r\n  rootElement: \"body\",\r\n  // give the choice to place backdrop under different elements\r\n  clickCallback: null,\r\n  backdropClasses: null\r\n}, Ro = {\r\n  isVisible: \"boolean\",\r\n  isAnimated: \"boolean\",\r\n  rootElement: \"(element|string)\",\r\n  clickCallback: \"(function|null)\",\r\n  backdropClasses: \"(array|string|null)\"\r\n}, Tn = \"backdrop\", es = `mousedown.twe.${Tn}`;\r\nclass yn {\r\n  constructor(t) {\r\n    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\r\n  }\r\n  show(t) {\r\n    if (!this._config.isVisible) {\r\n      _t(t);\r\n      return;\r\n    }\r\n    this._append(), this._config.isAnimated && Xt(this._getElement());\r\n    const e = this._config.backdropClasses || [\r\n      \"opacity-50\",\r\n      \"transition-all\",\r\n      \"duration-300\",\r\n      \"ease-in-out\",\r\n      \"fixed\",\r\n      \"top-0\",\r\n      \"left-0\",\r\n      \"z-[1040]\",\r\n      \"bg-black\",\r\n      \"w-screen\",\r\n      \"h-screen\"\r\n    ];\r\n    E.removeClass(this._getElement(), \"opacity-0\"), E.addClass(this._getElement(), e), this._element.setAttribute(\"data-twe-backdrop-show\", \"\"), this._emulateAnimation(() => {\r\n      _t(t);\r\n    });\r\n  }\r\n  hide(t) {\r\n    if (!this._config.isVisible) {\r\n      _t(t);\r\n      return;\r\n    }\r\n    this._element.removeAttribute(\"data-twe-backdrop-show\"), this._getElement().classList.add(\"opacity-0\"), this._getElement().classList.remove(\"opacity-50\"), this._emulateAnimation(() => {\r\n      this.dispose(), _t(t);\r\n    });\r\n  }\r\n  update(t = {}) {\r\n    this._config = this._getConfig({ ...this._config, ...t });\r\n  }\r\n  // Private\r\n  _getElement() {\r\n    if (!this._element) {\r\n      const t = document.createElement(\"div\");\r\n      this._element = t;\r\n    }\r\n    return this._element;\r\n  }\r\n  _getConfig(t) {\r\n    return t = {\r\n      ...Io,\r\n      ...typeof t == \"object\" ? t : {}\r\n    }, t.rootElement = rt(t.rootElement), R(Tn, t, Ro), t;\r\n  }\r\n  _append() {\r\n    this._isAppended || (this._config.rootElement.append(this._getElement()), d.on(this._getElement(), es, () => {\r\n      _t(this._config.clickCallback);\r\n    }), this._isAppended = !0);\r\n  }\r\n  dispose() {\r\n    this._isAppended && (d.off(this._element, es), this._element.remove(), this._isAppended = !1);\r\n  }\r\n  _emulateAnimation(t) {\r\n    Ws(\r\n      t,\r\n      this._getElement(),\r\n      this._config.isAnimated\r\n    );\r\n  }\r\n}\r\nclass An {\r\n  constructor(t, e = {}, s) {\r\n    this._element = t, this._toggler = s, this._event = e.event || \"blur\", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {\r\n      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());\r\n    };\r\n  }\r\n  trap() {\r\n    this._setElements(), this._init(), this._setFocusTrap();\r\n  }\r\n  disable() {\r\n    this._focusableElements.forEach((t) => {\r\n      t.removeEventListener(this._event, this.handler);\r\n    }), this._toggler && this._toggler.focus();\r\n  }\r\n  update() {\r\n    this._setElements(), this._setFocusTrap();\r\n  }\r\n  _init() {\r\n    const t = (e) => {\r\n      !this._firstElement || e.key !== \"Tab\" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener(\"keydown\", t));\r\n    };\r\n    window.addEventListener(\"keydown\", t);\r\n  }\r\n  _filterVisible(t) {\r\n    return t.filter((e) => {\r\n      if (!kt(e))\r\n        return !1;\r\n      const s = h.parents(e, \"*\");\r\n      for (let n = 0; n < s.length; n++) {\r\n        const r = window.getComputedStyle(s[n]);\r\n        if (r && (r.display === \"none\" || r.visibility === \"hidden\"))\r\n          return !1;\r\n      }\r\n      return !0;\r\n    });\r\n  }\r\n  _setElements() {\r\n    const t = h.find(this._selector, this._element);\r\n    this._focusableElements = t.filter((e) => {\r\n      const s = e.getAttribute(\"data-twe-disabled\") === \"true\" || e.hasAttribute(\"disabled\");\r\n      return e.disabled || s ? null : e;\r\n    }), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];\r\n  }\r\n  _setFocusTrap() {\r\n    this._focusableElements.forEach((t, e) => {\r\n      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);\r\n    });\r\n  }\r\n}\r\nlet is = [];\r\nconst Cn = (i, t = \"hide\") => {\r\n  const e = `click.dismiss${i.EVENT_KEY}`, s = i.NAME;\r\n  is.includes(s) || (is.push(s), d.on(\r\n    document,\r\n    e,\r\n    `[data-twe-${s}-dismiss]`,\r\n    function(n) {\r\n      if ([\"A\", \"AREA\"].includes(this.tagName) && n.preventDefault(), gt(this))\r\n        return;\r\n      const r = nt(this) || this.closest(`.${s}`) || this.closest(`[data-twe-${s}-init]`);\r\n      if (!r)\r\n        return;\r\n      i.getOrCreateInstance(r)[t]();\r\n    }\r\n  ));\r\n}, xo = 9, ss = \"offcanvas\", ko = \"twe.offcanvas\", Mt = `.${ko}`, Po = \".data-api\", Mo = `load${Mt}${Po}`, Ho = \"Escape\", ns = {\r\n  backdrop: !0,\r\n  keyboard: !0,\r\n  scroll: !1\r\n}, Vo = {\r\n  backdrop: \"boolean\",\r\n  keyboard: \"boolean\",\r\n  scroll: \"boolean\"\r\n}, rs = \"show\", Wo = \"[data-twe-offcanvas-init][data-twe-offcanvas-show]\", Bo = `show${Mt}`, jo = `shown${Mt}`, Uo = `hide${Mt}`, Fo = `hidden${Mt}`, Yo = `keydown.dismiss${Mt}`;\r\nclass _e extends tt {\r\n  constructor(t, e) {\r\n    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();\r\n  }\r\n  // Getters\r\n  static get NAME() {\r\n    return ss;\r\n  }\r\n  static get Default() {\r\n    return ns;\r\n  }\r\n  // Public\r\n  toggle(t) {\r\n    return this._isShown ? this.hide() : this.show(t);\r\n  }\r\n  show(t) {\r\n    if (this._isShown || d.trigger(this._element, Bo, {\r\n      relatedTarget: t\r\n    }).defaultPrevented)\r\n      return;\r\n    this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new ri().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`data-twe-offcanvas-${rs}`, \"\");\r\n    const s = () => {\r\n      this._config.scroll || this._focustrap.trap(), d.trigger(this._element, jo, { relatedTarget: t });\r\n    };\r\n    this._queueCallback(s, this._element, !0);\r\n  }\r\n  hide() {\r\n    if (!this._isShown || d.trigger(this._element, Uo).defaultPrevented)\r\n      return;\r\n    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-twe-offcanvas-${rs}`), this._backdrop.hide();\r\n    const e = () => {\r\n      this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new ri().reset(), d.trigger(this._element, Fo);\r\n    };\r\n    this._queueCallback(e, this._element, !0);\r\n  }\r\n  dispose() {\r\n    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\r\n  }\r\n  // Private\r\n  _init() {\r\n    this._didInit || (d.on(\r\n      window,\r\n      Mo,\r\n      () => h.find(Wo).forEach(\r\n        (t) => _e.getOrCreateInstance(t).show()\r\n      )\r\n    ), this._didInit = !0, Cn(_e));\r\n  }\r\n  _getConfig(t) {\r\n    return t = {\r\n      ...ns,\r\n      ...E.getDataAttributes(this._element),\r\n      ...typeof t == \"object\" ? t : {}\r\n    }, R(ss, t, Vo), t;\r\n  }\r\n  _initializeBackDrop() {\r\n    return new yn({\r\n      isVisible: this._config.backdrop,\r\n      isAnimated: !0,\r\n      rootElement: this._element.parentNode,\r\n      clickCallback: () => this.hide()\r\n    });\r\n  }\r\n  _initializeFocusTrap() {\r\n    return new An(this._element, {\r\n      event: \"keydown\",\r\n      condition: (t) => t.keyCode === xo,\r\n      onlyVisible: !0\r\n    });\r\n  }\r\n  _addEventListeners() {\r\n    d.on(this._element, Yo, (t) => {\r\n      this._config.keyboard && t.key === Ho && this.hide();\r\n    });\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = _e.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t](this);\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Ve = \"carousel\", Ko = \"twe.carousel\", U = `.${Ko}`, On = \".data-api\", zo = \"ArrowLeft\", qo = \"ArrowRight\", Xo = 500, Go = 40, os = {\r\n  interval: 5e3,\r\n  keyboard: !0,\r\n  ride: !1,\r\n  pause: \"hover\",\r\n  wrap: !0,\r\n  touch: !0\r\n}, Qo = {\r\n  interval: \"(number|boolean)\",\r\n  keyboard: \"boolean\",\r\n  ride: \"(boolean|string)\",\r\n  pause: \"(string|boolean)\",\r\n  wrap: \"boolean\",\r\n  touch: \"boolean\"\r\n}, Zo = {\r\n  pointer: \"touch-pan-y\",\r\n  block: \"!block\",\r\n  visible: \"data-[twe-carousel-fade]:opacity-100 data-[twe-carousel-fade]:z-[1]\",\r\n  invisible: \"data-[twe-carousel-fade]:z-0 data-[twe-carousel-fade]:opacity-0 data-[twe-carousel-fade]:duration-[600ms] data-[twe-carousel-fade]:delay-600\",\r\n  slideRight: \"translate-x-full\",\r\n  slideLeft: \"-translate-x-full\"\r\n}, Jo = {\r\n  pointer: \"string\",\r\n  block: \"string\",\r\n  visible: \"string\",\r\n  invisible: \"string\",\r\n  slideRight: \"string\",\r\n  slideLeft: \"string\"\r\n}, ht = \"next\", ft = \"prev\", pt = \"left\", Yt = \"right\", ta = {\r\n  [zo]: Yt,\r\n  [qo]: pt\r\n}, ea = `slide${U}`, We = `slid${U}`, ia = `keydown${U}`, sa = `mouseenter${U}`, na = `mouseleave${U}`, ra = `touchstart${U}`, oa = `touchmove${U}`, aa = `touchend${U}`, la = `pointerdown${U}`, ca = `pointerup${U}`, da = `dragstart${U}`, as = `load${U}${On}`, ls = `click${U}${On}`, Wt = \"data-twe-carousel-active\", ua = \"data-twe-carousel-item-end\", Be = \"data-twe-carousel-item-start\", ha = \"data-twe-carousel-item-next\", fa = \"data-twe-carousel-item-prev\", pa = \"data-twe-carousel-pointer-event\", _a = \"[data-twe-carousel-init]\", Dn = \"[data-twe-carousel-active]\", Ai = \"[data-twe-carousel-item]\", Tt = `${Dn}${Ai}`, ga = `${Ai} img`, ma = \"[data-twe-carousel-item-next], [data-twe-carousel-item-prev]\", Ea = \"[data-twe-carousel-indicators]\", va = \"[data-twe-target]\", cs = \"[data-twe-slide], [data-twe-slide-to]\", ba = \"touch\", wa = \"pen\";\r\nclass Z extends tt {\r\n  constructor(t, e, s) {\r\n    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._indicatorsElement = h.findOne(\r\n      Ea,\r\n      this._element\r\n    ), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === \"carousel\" && this.cycle();\r\n  }\r\n  // Getters\r\n  static get Default() {\r\n    return os;\r\n  }\r\n  static get NAME() {\r\n    return Ve;\r\n  }\r\n  // Public\r\n  next() {\r\n    this._slide(ht);\r\n  }\r\n  nextWhenVisible() {\r\n    !document.hidden && kt(this._element) && this.next();\r\n  }\r\n  prev() {\r\n    this._slide(ft);\r\n  }\r\n  pause(t) {\r\n    t || (this._isPaused = !0), h.findOne(ma, this._element) && (Ps(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\r\n  }\r\n  cycle(t) {\r\n    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(\r\n      (document.visibilityState ? this.nextWhenVisible : this.next).bind(\r\n        this\r\n      ),\r\n      this._config.interval\r\n    ));\r\n  }\r\n  to(t) {\r\n    this._activeElement = h.findOne(\r\n      Tt,\r\n      this._element\r\n    );\r\n    const e = this._getItemIndex(this._activeElement);\r\n    if (t > this._items.length - 1 || t < 0)\r\n      return;\r\n    if (this._isSliding) {\r\n      d.one(this._element, We, () => this.to(t));\r\n      return;\r\n    }\r\n    if (e === t) {\r\n      this.pause(), this.cycle();\r\n      return;\r\n    }\r\n    const s = t > e ? ht : ft;\r\n    this._slide(s, this._items[t]);\r\n  }\r\n  dispose() {\r\n    d.off(\r\n      document,\r\n      ls,\r\n      cs,\r\n      Z.dataApiClickHandler\r\n    ), d.off(window, as), super.dispose();\r\n  }\r\n  // Private\r\n  _init() {\r\n    this._didInit || (d.on(\r\n      document,\r\n      ls,\r\n      cs,\r\n      Z.dataApiClickHandler\r\n    ), d.on(window, as, () => {\r\n      const t = h.find(_a);\r\n      for (let e = 0, s = t.length; e < s; e++)\r\n        Z.carouselInterface(\r\n          t[e],\r\n          Z.getInstance(t[e])\r\n        );\r\n    }), this._didInit = !0);\r\n  }\r\n  _getConfig(t) {\r\n    return t = {\r\n      ...os,\r\n      ...E.getDataAttributes(this._element),\r\n      ...typeof t == \"object\" ? t : {}\r\n    }, R(Ve, t, Qo), t;\r\n  }\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...Zo,\r\n      ...e,\r\n      ...t\r\n    }, R(Ve, t, Jo), t;\r\n  }\r\n  _enableCycle() {\r\n    if (this._config.ride) {\r\n      if (this._isSliding) {\r\n        d.one(this._element, We, () => this.cycle());\r\n        return;\r\n      }\r\n      this.cycle();\r\n    }\r\n  }\r\n  _applyInitialClasses() {\r\n    const t = h.findOne(\r\n      Tt,\r\n      this._element\r\n    );\r\n    t.classList.add(\r\n      this._classes.block,\r\n      ...this._classes.visible.split(\" \")\r\n    ), this._setActiveIndicatorElement(t);\r\n  }\r\n  _handleSwipe() {\r\n    const t = Math.abs(this.touchDeltaX);\r\n    if (t <= Go)\r\n      return;\r\n    const e = t / this.touchDeltaX;\r\n    this.touchDeltaX = 0, e && this._slide(e > 0 ? Yt : pt);\r\n  }\r\n  _setActiveElementClass() {\r\n    this._activeElement = h.findOne(\r\n      Tt,\r\n      this._element\r\n    ), E.addClass(this._activeElement, \"hidden\");\r\n  }\r\n  _addEventListeners() {\r\n    this._config.keyboard && d.on(\r\n      this._element,\r\n      ia,\r\n      (t) => this._keydown(t)\r\n    ), this._config.pause === \"hover\" && (d.on(\r\n      this._element,\r\n      sa,\r\n      (t) => this.pause(t)\r\n    ), d.on(\r\n      this._element,\r\n      na,\r\n      (t) => this._enableCycle(t)\r\n    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();\r\n  }\r\n  _addTouchEventListeners() {\r\n    const t = (r) => this._pointerEvent && (r.pointerType === wa || r.pointerType === ba), e = (r) => {\r\n      t(r) ? this.touchStartX = r.clientX : this._pointerEvent || (this.touchStartX = r.touches[0].clientX);\r\n    }, s = (r) => {\r\n      this.touchDeltaX = r.touches && r.touches.length > 1 ? 0 : r.touches[0].clientX - this.touchStartX;\r\n    }, n = (r) => {\r\n      t(r) && (this.touchDeltaX = r.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === \"hover\" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(\r\n        (o) => this._enableCycle(o),\r\n        Xo + this._config.interval\r\n      ));\r\n    };\r\n    h.find(ga, this._element).forEach(\r\n      (r) => {\r\n        d.on(\r\n          r,\r\n          da,\r\n          (o) => o.preventDefault()\r\n        );\r\n      }\r\n    ), this._pointerEvent ? (d.on(\r\n      this._element,\r\n      la,\r\n      (r) => e(r)\r\n    ), d.on(this._element, ca, (r) => n(r)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${pa}`, \"\")) : (d.on(this._element, ra, (r) => e(r)), d.on(this._element, oa, (r) => s(r)), d.on(this._element, aa, (r) => n(r)));\r\n  }\r\n  _keydown(t) {\r\n    if (/input|textarea/i.test(t.target.tagName))\r\n      return;\r\n    const e = ta[t.key];\r\n    e && (t.preventDefault(), this._slide(e));\r\n  }\r\n  _getItemIndex(t) {\r\n    return this._items = t && t.parentNode ? h.find(Ai, t.parentNode) : [], this._items.indexOf(t);\r\n  }\r\n  _getItemByOrder(t, e) {\r\n    const s = t === ht;\r\n    return Bs(\r\n      this._items,\r\n      e,\r\n      s,\r\n      this._config.wrap\r\n    );\r\n  }\r\n  _triggerSlideEvent(t, e) {\r\n    const s = this._getItemIndex(t), n = this._getItemIndex(\r\n      h.findOne(Tt, this._element)\r\n    );\r\n    return d.trigger(this._element, ea, {\r\n      relatedTarget: t,\r\n      direction: e,\r\n      from: n,\r\n      to: s\r\n    });\r\n  }\r\n  _setActiveIndicatorElement(t) {\r\n    if (this._indicatorsElement) {\r\n      const e = h.findOne(\r\n        Dn,\r\n        this._indicatorsElement\r\n      );\r\n      e.removeAttribute(Wt), e.removeAttribute(\"aria-current\"), e.classList.remove(\"!opacity-100\");\r\n      const s = h.find(\r\n        va,\r\n        this._indicatorsElement\r\n      );\r\n      for (let n = 0; n < s.length; n++)\r\n        if (Number.parseInt(\r\n          s[n].getAttribute(\"data-twe-slide-to\"),\r\n          10\r\n        ) === this._getItemIndex(t)) {\r\n          s[n].setAttribute(`${Wt}`, \"\"), s[n].setAttribute(\"aria-current\", \"true\"), s[n].classList.add(\"!opacity-100\");\r\n          break;\r\n        }\r\n    }\r\n  }\r\n  _updateInterval() {\r\n    const t = this._activeElement || h.findOne(Tt, this._element);\r\n    if (!t)\r\n      return;\r\n    const e = Number.parseInt(\r\n      t.getAttribute(\"data-twe-interval\"),\r\n      10\r\n    );\r\n    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\r\n  }\r\n  _slide(t, e) {\r\n    const s = this._directionToOrder(t), n = h.findOne(\r\n      Tt,\r\n      this._element\r\n    ), r = this._getItemIndex(n), o = e || this._getItemByOrder(s, n), a = this._getItemIndex(o), l = !!this._interval, u = s === ht, c = u ? Be : ua, f = u ? ha : fa, v = this._orderToDirection(s), g = c === Be ? this._classes.slideLeft : this._classes.slideRight, O = c !== Be ? this._classes.slideLeft : this._classes.slideRight;\r\n    if (o && o.hasAttribute(Wt)) {\r\n      this._isSliding = !1;\r\n      return;\r\n    }\r\n    if (this._isSliding || this._triggerSlideEvent(o, v).defaultPrevented || !n || !o)\r\n      return;\r\n    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;\r\n    const A = () => {\r\n      d.trigger(this._element, We, {\r\n        relatedTarget: o,\r\n        direction: v,\r\n        from: r,\r\n        to: a\r\n      });\r\n    };\r\n    o.setAttribute(`${f}`, \"\"), o.classList.add(this._classes.block, O), Xt(o), n.setAttribute(`${c}`, \"\"), n.classList.add(\r\n      g,\r\n      ...this._classes.invisible.split(\" \")\r\n    ), n.classList.remove(...this._classes.visible.split(\" \")), o.setAttribute(`${c}`, \"\"), o.classList.add(...this._classes.visible.split(\" \")), o.classList.remove(\r\n      this._classes.slideRight,\r\n      this._classes.slideLeft\r\n    );\r\n    const D = () => {\r\n      o.removeAttribute(c), o.removeAttribute(f), o.setAttribute(`${Wt}`, \"\"), n.removeAttribute(Wt), n.classList.remove(\r\n        g,\r\n        ...this._classes.invisible.split(\" \"),\r\n        this._classes.block\r\n      ), n.removeAttribute(f), n.removeAttribute(c), this._isSliding = !1, setTimeout(A, 0);\r\n    };\r\n    this._queueCallback(D, n, !0), (l || this._config.ride === !0) && this.cycle();\r\n  }\r\n  _directionToOrder(t) {\r\n    return [Yt, pt].includes(t) ? M() ? t === pt ? ft : ht : t === pt ? ht : ft : t;\r\n  }\r\n  _orderToDirection(t) {\r\n    return [ht, ft].includes(t) ? M() ? t === ft ? pt : Yt : t === ft ? Yt : pt : t;\r\n  }\r\n  // Static\r\n  static carouselInterface(t, e) {\r\n    const s = Z.getOrCreateInstance(t, e);\r\n    let { _config: n } = s;\r\n    typeof e == \"object\" && (n = {\r\n      ...n,\r\n      ...e\r\n    });\r\n    const r = typeof e == \"string\" ? e : e.slide;\r\n    if (typeof e == \"number\") {\r\n      s.to(e);\r\n      return;\r\n    }\r\n    if (typeof r == \"string\") {\r\n      if (typeof s[r] > \"u\")\r\n        throw new TypeError(`No method named \"${r}\"`);\r\n      s[r]();\r\n    } else\r\n      n.interval && n.ride === !0 && s.pause();\r\n  }\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      let e = Z.getOrCreateInstance(this);\r\n      if (typeof t == \"number\") {\r\n        e.to(t);\r\n        return;\r\n      }\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n  static dataApiClickHandler(t) {\r\n    const e = nt(this);\r\n    if (!e)\r\n      return;\r\n    const s = {\r\n      ...E.getDataAttributes(e),\r\n      ...E.getDataAttributes(this)\r\n    }, n = this.getAttribute(\"data-twe-slide-to\");\r\n    n && (s.interval = !1), Z.carouselInterface(e, s), n && Z.getInstance(e).to(n), t.preventDefault();\r\n  }\r\n}\r\nconst Ta = /* @__PURE__ */ new Set([\r\n  \"background\",\r\n  \"cite\",\r\n  \"href\",\r\n  \"itemtype\",\r\n  \"longdesc\",\r\n  \"poster\",\r\n  \"src\",\r\n  \"xlink:href\"\r\n]), ya = /^aria-[\\w-]*$/i, Aa = /^data-twe-[\\w-]*$/i, Ca = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Oa = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, Da = (i, t) => {\r\n  const e = i.nodeName.toLowerCase();\r\n  if (t.includes(e))\r\n    return Ta.has(e) ? !!(Ca.test(i.nodeValue) || Oa.test(i.nodeValue)) : !0;\r\n  const s = t.filter(\r\n    (n) => n instanceof RegExp\r\n  );\r\n  for (let n = 0, r = s.length; n < r; n++)\r\n    if (s[n].test(e))\r\n      return !0;\r\n  return !1;\r\n}, Na = {\r\n  // Global attributes allowed on any supplied element below.\r\n  \"*\": [\r\n    \"class\",\r\n    \"dir\",\r\n    \"id\",\r\n    \"lang\",\r\n    \"role\",\r\n    ya,\r\n    Aa\r\n  ],\r\n  a: [\"target\", \"href\", \"title\", \"rel\"],\r\n  area: [],\r\n  b: [],\r\n  br: [],\r\n  col: [],\r\n  code: [],\r\n  div: [],\r\n  em: [],\r\n  hr: [],\r\n  h1: [],\r\n  h2: [],\r\n  h3: [],\r\n  h4: [],\r\n  h5: [],\r\n  h6: [],\r\n  i: [],\r\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\r\n  li: [],\r\n  ol: [],\r\n  p: [],\r\n  pre: [],\r\n  s: [],\r\n  small: [],\r\n  span: [],\r\n  sub: [],\r\n  sup: [],\r\n  strong: [],\r\n  u: [],\r\n  ul: []\r\n};\r\nfunction ds(i, t, e) {\r\n  if (!i.length)\r\n    return i;\r\n  if (e && typeof e == \"function\")\r\n    return e(i);\r\n  const n = new window.DOMParser().parseFromString(i, \"text/html\"), r = [].concat(...n.body.querySelectorAll(\"*\"));\r\n  for (let o = 0, a = r.length; o < a; o++) {\r\n    const l = r[o], u = l.nodeName.toLowerCase();\r\n    if (!Object.keys(t).includes(u)) {\r\n      l.remove();\r\n      continue;\r\n    }\r\n    const c = [].concat(...l.attributes), f = [].concat(\r\n      t[\"*\"] || [],\r\n      t[u] || []\r\n    );\r\n    c.forEach((v) => {\r\n      Da(v, f) || l.removeAttribute(v.nodeName);\r\n    });\r\n  }\r\n  return n.body.innerHTML;\r\n}\r\nconst us = \"tooltip\", Sa = \"twe.tooltip\", z = `.${Sa}`, La = \"te-tooltip\", $a = /* @__PURE__ */ new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]), Ia = {\r\n  animation: \"boolean\",\r\n  template: \"string\",\r\n  title: \"(string|element|function)\",\r\n  trigger: \"string\",\r\n  delay: \"(number|object)\",\r\n  html: \"boolean\",\r\n  selector: \"(string|boolean)\",\r\n  placement: \"(string|function)\",\r\n  offset: \"(array|string|function)\",\r\n  container: \"(string|element|boolean)\",\r\n  fallbackPlacements: \"array\",\r\n  boundary: \"(string|element)\",\r\n  customClass: \"(string|function)\",\r\n  sanitize: \"boolean\",\r\n  sanitizeFn: \"(null|function)\",\r\n  allowList: \"object\",\r\n  popperConfig: \"(null|object|function)\"\r\n}, Ra = {\r\n  AUTO: \"auto\",\r\n  TOP: \"top\",\r\n  RIGHT: M() ? \"left\" : \"right\",\r\n  BOTTOM: \"bottom\",\r\n  LEFT: M() ? \"right\" : \"left\"\r\n}, xa = {\r\n  animation: !0,\r\n  template: `\r\n    <div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\">\r\n      <div data-twe-tooltip-inner-ref class=\"max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div>\r\n    </div>\r\n    `,\r\n  trigger: \"hover focus\",\r\n  title: \"\",\r\n  delay: 0,\r\n  html: !1,\r\n  selector: !1,\r\n  placement: \"top\",\r\n  offset: [0, 0],\r\n  container: !1,\r\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\r\n  boundary: \"clippingParents\",\r\n  customClass: \"\",\r\n  sanitize: !0,\r\n  sanitizeFn: null,\r\n  allowList: Na,\r\n  popperConfig: { hide: !0 }\r\n}, ka = {\r\n  HIDE: `hide${z}`,\r\n  HIDDEN: `hidden${z}`,\r\n  SHOW: `show${z}`,\r\n  SHOWN: `shown${z}`,\r\n  INSERTED: `inserted${z}`,\r\n  CLICK: `click${z}`,\r\n  FOCUSIN: `focusin${z}`,\r\n  FOCUSOUT: `focusout${z}`,\r\n  MOUSEENTER: `mouseenter${z}`,\r\n  MOUSELEAVE: `mouseleave${z}`\r\n}, Pa = \"fade\", Ma = \"modal\", je = \"show\", Bt = \"show\", Ue = \"out\", hs = \"[data-twe-tooltip-inner-ref]\", fs = `.${Ma}`, ps = \"hide.twe.modal\", jt = \"hover\", Fe = \"focus\", Ha = \"click\", Va = \"manual\";\r\nclass Qt extends tt {\r\n  constructor(t, e) {\r\n    if (typeof bn > \"u\")\r\n      throw new TypeError(\r\n        \"Bootstrap's tooltips require Popper (https://popper.js.org)\"\r\n      );\r\n    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\r\n  }\r\n  // Getters\r\n  static get Default() {\r\n    return xa;\r\n  }\r\n  static get NAME() {\r\n    return us;\r\n  }\r\n  static get Event() {\r\n    return ka;\r\n  }\r\n  static get DefaultType() {\r\n    return Ia;\r\n  }\r\n  // Public\r\n  enable() {\r\n    this._isEnabled = !0;\r\n  }\r\n  disable() {\r\n    this._isEnabled = !1;\r\n  }\r\n  toggleEnabled() {\r\n    this._isEnabled = !this._isEnabled;\r\n  }\r\n  toggle(t) {\r\n    if (this._isEnabled)\r\n      if (t) {\r\n        const e = this._initializeOnDelegatedTarget(t);\r\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\r\n      } else {\r\n        if (this.getTipElement().classList.contains(je)) {\r\n          this._leave(null, this);\r\n          return;\r\n        }\r\n        this._enter(null, this);\r\n      }\r\n  }\r\n  dispose() {\r\n    clearTimeout(this._timeout), d.off(\r\n      this._element.closest(fs),\r\n      ps,\r\n      this._hideModalHandler\r\n    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\r\n  }\r\n  show() {\r\n    if (this._element.style.display === \"none\")\r\n      throw new Error(\"Please use show on visible elements\");\r\n    if (!(this.isWithContent() && this._isEnabled))\r\n      return;\r\n    const t = d.trigger(\r\n      this._element,\r\n      this.constructor.Event.SHOW\r\n    ), e = Ms(this._element), s = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\r\n    if (t.defaultPrevented || !s)\r\n      return;\r\n    this.constructor.NAME === \"tooltip\" && this.tip && this.getTitle() !== this.tip.querySelector(hs).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\r\n    const n = this.getTipElement(), r = Gn(this.constructor.NAME);\r\n    n.setAttribute(\"id\", r), this._element.setAttribute(\"aria-describedby\", r), this._config.animation && setTimeout(() => {\r\n      this.tip.classList.add(\"opacity-100\"), this.tip.classList.remove(\"opacity-0\");\r\n    }, 100);\r\n    const o = typeof this._config.placement == \"function\" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(o);\r\n    this._addAttachmentClass(a);\r\n    const { container: l } = this._config;\r\n    if (V.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), d.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ti(\r\n      this._element,\r\n      n,\r\n      this._getPopperConfig(a)\r\n    ), n.getAttribute(\"id\").includes(\"tooltip\"))\r\n      switch (o) {\r\n        case \"bottom\":\r\n          n.classList.add(\"py-[0.4rem]\");\r\n          break;\r\n        case \"left\":\r\n          n.classList.add(\"px-[0.4rem]\");\r\n          break;\r\n        case \"right\":\r\n          n.classList.add(\"px-[0.4rem]\");\r\n          break;\r\n        default:\r\n          n.classList.add(\"py-[0.4rem]\");\r\n          break;\r\n      }\r\n    const c = this._resolvePossibleFunction(this._config.customClass);\r\n    c && n.classList.add(...c.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((g) => {\r\n      d.on(g, \"mouseover\", me);\r\n    });\r\n    const f = () => {\r\n      const g = this._hoverState;\r\n      this._hoverState = null, d.trigger(this._element, this.constructor.Event.SHOWN), g === Ue && this._leave(null, this);\r\n    }, v = this.tip.classList.contains(\"transition-opacity\");\r\n    this._queueCallback(f, this.tip, v);\r\n  }\r\n  hide() {\r\n    if (!this._popper)\r\n      return;\r\n    const t = this.getTipElement(), e = () => {\r\n      this._isWithActiveTrigger() || (this._hoverState !== Bt && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), d.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\r\n    };\r\n    if (d.trigger(\r\n      this._element,\r\n      this.constructor.Event.HIDE\r\n    ).defaultPrevented)\r\n      return;\r\n    t.classList.add(\"opacity-0\"), t.classList.remove(\"opacity-100\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((r) => d.off(r, \"mouseover\", me)), this._activeTrigger[Ha] = !1, this._activeTrigger[Fe] = !1, this._activeTrigger[jt] = !1;\r\n    const n = this.tip.classList.contains(\"opacity-0\");\r\n    this._queueCallback(e, this.tip, n), this._hoverState = \"\";\r\n  }\r\n  update() {\r\n    this._popper !== null && this._popper.update();\r\n  }\r\n  // Protected\r\n  isWithContent() {\r\n    return !!this.getTitle();\r\n  }\r\n  getTipElement() {\r\n    if (this.tip)\r\n      return this.tip;\r\n    const t = document.createElement(\"div\");\r\n    t.innerHTML = this._config.template;\r\n    const e = t.children[0];\r\n    return this.setContent(e), e.classList.remove(Pa, je), this.tip = e, this.tip;\r\n  }\r\n  setContent(t) {\r\n    this._sanitizeAndSetContent(t, this.getTitle(), hs);\r\n  }\r\n  _sanitizeAndSetContent(t, e, s) {\r\n    const n = h.findOne(s, t);\r\n    if (!e && n) {\r\n      n.remove();\r\n      return;\r\n    }\r\n    this.setElementContent(n, e);\r\n  }\r\n  setElementContent(t, e) {\r\n    if (t !== null) {\r\n      if (St(e)) {\r\n        e = rt(e), this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent;\r\n        return;\r\n      }\r\n      this._config.html ? (this._config.sanitize && (e = ds(\r\n        e,\r\n        this._config.allowList,\r\n        this._config.sanitizeFn\r\n      )), t.innerHTML = e) : t.textContent = e;\r\n    }\r\n  }\r\n  getTitle() {\r\n    const t = this._element.getAttribute(\"data-twe-original-title\") || this._config.title;\r\n    return this._resolvePossibleFunction(t);\r\n  }\r\n  updateAttachment(t) {\r\n    return t === \"right\" ? \"end\" : t === \"left\" ? \"start\" : t;\r\n  }\r\n  // Private\r\n  _initializeOnDelegatedTarget(t, e) {\r\n    return e || this.constructor.getOrCreateInstance(\r\n      t.delegateTarget,\r\n      this._getDelegateConfig()\r\n    );\r\n  }\r\n  _getOffset() {\r\n    const { offset: t } = this._config;\r\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\r\n  }\r\n  _resolvePossibleFunction(t) {\r\n    return typeof t == \"function\" ? t.call(this._element) : t;\r\n  }\r\n  _getPopperConfig(t) {\r\n    const e = {\r\n      placement: t,\r\n      modifiers: [\r\n        {\r\n          name: \"flip\",\r\n          options: {\r\n            fallbackPlacements: this._config.fallbackPlacements\r\n          }\r\n        },\r\n        {\r\n          name: \"offset\",\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        },\r\n        {\r\n          name: \"preventOverflow\",\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        },\r\n        {\r\n          name: \"arrow\",\r\n          options: {\r\n            element: `.${this.constructor.NAME}-arrow`\r\n          }\r\n        },\r\n        {\r\n          name: \"onChange\",\r\n          enabled: !0,\r\n          phase: \"afterWrite\",\r\n          fn: (s) => this._handlePopperPlacementChange(s)\r\n        }\r\n      ],\r\n      onFirstUpdate: (s) => {\r\n        s.options.placement !== s.placement && this._handlePopperPlacementChange(s);\r\n      }\r\n    };\r\n    return {\r\n      ...e,\r\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(e) : this._config.popperConfig\r\n    };\r\n  }\r\n  _addAttachmentClass(t) {\r\n    this.getTipElement().classList.add(\r\n      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`\r\n    );\r\n  }\r\n  _getAttachment(t) {\r\n    return Ra[t.toUpperCase()];\r\n  }\r\n  _setListeners() {\r\n    this._config.trigger.split(\" \").forEach((e) => {\r\n      if (e === \"click\")\r\n        d.on(\r\n          this._element,\r\n          this.constructor.Event.CLICK,\r\n          this._config.selector,\r\n          (s) => this.toggle(s)\r\n        );\r\n      else if (e !== Va) {\r\n        const s = e === jt ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === jt ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\r\n        d.on(\r\n          this._element,\r\n          s,\r\n          this._config.selector,\r\n          (r) => this._enter(r)\r\n        ), d.on(\r\n          this._element,\r\n          n,\r\n          this._config.selector,\r\n          (r) => this._leave(r)\r\n        );\r\n      }\r\n    }), this._hideModalHandler = () => {\r\n      this._element && this.hide();\r\n    }, d.on(\r\n      this._element.closest(fs),\r\n      ps,\r\n      this._hideModalHandler\r\n    ), this._config.selector ? this._config = {\r\n      ...this._config,\r\n      trigger: \"manual\",\r\n      selector: \"\"\r\n    } : this._fixTitle();\r\n  }\r\n  _fixTitle() {\r\n    const t = this._element.getAttribute(\"title\"), e = typeof this._element.getAttribute(\r\n      \"data-twe-original-title\"\r\n    );\r\n    (t || e !== \"string\") && (this._element.setAttribute(\"data-twe-original-title\", t || \"\"), t && !this._element.getAttribute(\"aria-label\") && !this._element.textContent && this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\r\n  }\r\n  _enter(t, e) {\r\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusin\" ? Fe : jt] = !0), e.getTipElement().classList.contains(je) || e._hoverState === Bt) {\r\n      e._hoverState = Bt;\r\n      return;\r\n    }\r\n    if (clearTimeout(e._timeout), e._hoverState = Bt, !e._config.delay || !e._config.delay.show) {\r\n      e.show();\r\n      return;\r\n    }\r\n    e._timeout = setTimeout(() => {\r\n      e._hoverState === Bt && e.show();\r\n    }, e._config.delay.show);\r\n  }\r\n  _leave(t, e) {\r\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusout\" ? Fe : jt] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {\r\n      if (clearTimeout(e._timeout), e._hoverState = Ue, !e._config.delay || !e._config.delay.hide) {\r\n        e.hide();\r\n        return;\r\n      }\r\n      e._timeout = setTimeout(() => {\r\n        e._hoverState === Ue && e.hide();\r\n      }, e._config.delay.hide);\r\n    }\r\n  }\r\n  _isWithActiveTrigger() {\r\n    for (const t in this._activeTrigger)\r\n      if (this._activeTrigger[t])\r\n        return !0;\r\n    return !1;\r\n  }\r\n  _getConfig(t) {\r\n    const e = E.getDataAttributes(this._element);\r\n    return Object.keys(e).forEach((s) => {\r\n      $a.has(s) && delete e[s];\r\n    }), t = {\r\n      ...this.constructor.Default,\r\n      ...e,\r\n      ...typeof t == \"object\" && t ? t : {}\r\n    }, t.container = t.container === !1 ? document.body : rt(t.container), typeof t.delay == \"number\" && (t.delay = {\r\n      show: t.delay,\r\n      hide: t.delay\r\n    }), typeof t.title == \"number\" && (t.title = t.title.toString()), typeof t.content == \"number\" && (t.content = t.content.toString()), R(us, t, this.constructor.DefaultType), t.sanitize && (t.template = ds(\r\n      t.template,\r\n      t.allowList,\r\n      t.sanitizeFn\r\n    )), t;\r\n  }\r\n  _getDelegateConfig() {\r\n    const t = {};\r\n    for (const e in this._config)\r\n      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\r\n    return t;\r\n  }\r\n  _cleanTipClass() {\r\n    const t = this.getTipElement(), e = new RegExp(\r\n      `(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\r\n      \"g\"\r\n    ), s = t.getAttribute(\"class\").match(e);\r\n    s !== null && s.length > 0 && s.map((n) => n.trim()).forEach((n) => t.classList.remove(n));\r\n  }\r\n  _getBasicClassPrefix() {\r\n    return La;\r\n  }\r\n  _handlePopperPlacementChange(t) {\r\n    const { state: e } = t;\r\n    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\r\n  }\r\n  _disposePopper() {\r\n    this._popper && (this._popper.destroy(), this._popper = null);\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = Qt.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Wa = \"popover\", Ba = \"twe.popover\", q = `.${Ba}`, ja = \"te-popover\", Ua = {\r\n  ...Qt.Default,\r\n  placement: \"right\",\r\n  offset: [0, 8],\r\n  trigger: \"click\",\r\n  content: \"\",\r\n  template: `\r\n    <div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-2 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:border-white/10 dark:bg-surface-dark dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\">\r\n      <h3 data-twe-popover-header-ref class=\"py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-white/10\"></h3>\r\n      <div data-twe-popover-body-ref class=\"p-4 text-surface dark:text-white\"></div>\r\n    </div>\r\n    `\r\n}, Fa = {\r\n  ...Qt.DefaultType,\r\n  content: \"(string|element|function)\"\r\n}, Ya = {\r\n  HIDE: `hide${q}`,\r\n  HIDDEN: `hidden${q}`,\r\n  SHOW: `show${q}`,\r\n  SHOWN: `shown${q}`,\r\n  INSERTED: `inserted${q}`,\r\n  CLICK: `click${q}`,\r\n  FOCUSIN: `focusin${q}`,\r\n  FOCUSOUT: `focusout${q}`,\r\n  MOUSEENTER: `mouseenter${q}`,\r\n  MOUSELEAVE: `mouseleave${q}`\r\n}, Ka = \"[data-twe-popover-header-ref]\", za = \"[data-twe-popover-body-ref]\";\r\nclass Nn extends Qt {\r\n  // Getters\r\n  static get Default() {\r\n    return Ua;\r\n  }\r\n  static get NAME() {\r\n    return Wa;\r\n  }\r\n  static get Event() {\r\n    return Ya;\r\n  }\r\n  static get DefaultType() {\r\n    return Fa;\r\n  }\r\n  // Overrides\r\n  isWithContent() {\r\n    return this.getTitle() || this._getContent();\r\n  }\r\n  setContent(t) {\r\n    this._sanitizeAndSetContent(t, this.getTitle(), Ka), this._sanitizeAndSetContent(t, this._getContent(), za);\r\n  }\r\n  // Private\r\n  _getContent() {\r\n    return this._resolvePossibleFunction(this._config.content);\r\n  }\r\n  _getBasicClassPrefix() {\r\n    return ja;\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = Nn.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Ye = \"scrollspy\", qa = \"twe.scrollspy\", Ci = `.${qa}`, _s = {\r\n  offset: 10,\r\n  method: \"auto\",\r\n  target: \"\"\r\n}, Xa = {\r\n  offset: \"number\",\r\n  method: \"string\",\r\n  target: \"(string|element)\"\r\n}, Ga = {\r\n  active: \"!text-primary font-semibold border-s-[0.125rem] border-solid border-primary\"\r\n}, Qa = {\r\n  active: \"string\"\r\n}, Ke = `activate${Ci}`, Za = `scroll${Ci}`, Kt = \"data-twe-nav-link-active\", Sn = \"data-twe-collapsible-scrollspy-ref\", Ln = \"[data-twe-dropdown-item-ref]\", Ja = \"[data-twe-nav-list-ref]\", oi = \"[data-twe-nav-link-ref]\", tl = \"[data-twe-nav-item-ref]\", $n = \"[data-twe-list-group-item-ref]\", ze = `${oi}, ${$n}, ${Ln}`, el = \"[data-twe-dropdown-ref]\", il = \"[data-twe-dropdown-toggle-ref]\", gs = `[${Sn}]`, sl = `[${Kt}]`, qe = \"ul\", nl = \"maxOffset\", ms = \"position\";\r\nclass In extends tt {\r\n  constructor(t, e, s) {\r\n    super(t), this._scrollElement = this._element.tagName === \"BODY\" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(s), this._offsets = [], this._targets = [], this._collapsibles = [], this._activeTarget = null, this._scrollHeight = 0, d.on(this._scrollElement, Za, () => this._process()), this.refresh(), this._process(), this._bindActivateEvent(), this._getCollapsibles(), this._collapsibles.length !== 0 && (this._showSubsection(), this._hideSubsection());\r\n  }\r\n  // Getters\r\n  static get Default() {\r\n    return _s;\r\n  }\r\n  static get NAME() {\r\n    return Ye;\r\n  }\r\n  // Public\r\n  refresh() {\r\n    const t = this._scrollElement === this._scrollElement.window ? nl : ms, e = this._config.method === \"auto\" ? t : this._config.method, s = e === ms ? this._getScrollTop() : 0;\r\n    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), h.find(\r\n      ze,\r\n      this._config.target\r\n    ).map((r) => {\r\n      const o = ci(r), a = o ? h.findOne(o) : null;\r\n      if (a) {\r\n        const l = a.getBoundingClientRect();\r\n        if (l.width || l.height)\r\n          return [\r\n            E[e](a).top + s,\r\n            o\r\n          ];\r\n      }\r\n      return null;\r\n    }).filter((r) => r).sort((r, o) => r[0] - o[0]).forEach((r) => {\r\n      this._offsets.push(r[0]), this._targets.push(r[1]);\r\n    });\r\n  }\r\n  dispose() {\r\n    d.off(this._scrollElement, Ci), d.off(this._scrollElement, Ke), super.dispose();\r\n  }\r\n  // Private\r\n  _getConfig(t) {\r\n    return t = {\r\n      ..._s,\r\n      ...E.getDataAttributes(this._element),\r\n      ...typeof t == \"object\" && t ? t : {}\r\n    }, t.target = rt(t.target) || document.documentElement, R(Ye, t, Xa), t;\r\n  }\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...Ga,\r\n      ...e,\r\n      ...t\r\n    }, R(Ye, t, Qa), t;\r\n  }\r\n  _getScrollTop() {\r\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\r\n  }\r\n  _getScrollHeight() {\r\n    return this._scrollElement.scrollHeight || Math.max(\r\n      document.body.scrollHeight,\r\n      document.documentElement.scrollHeight\r\n    );\r\n  }\r\n  _getOffsetHeight() {\r\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\r\n  }\r\n  _process() {\r\n    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), s = this._config.offset + e - this._getOffsetHeight();\r\n    if (this._scrollHeight !== e && this.refresh(), t >= s) {\r\n      const n = this._targets[this._targets.length - 1];\r\n      this._activeTarget !== n && this._activate(n);\r\n      return;\r\n    }\r\n    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {\r\n      this._activeTarget = null, this._clear();\r\n      return;\r\n    }\r\n    for (let n = this._offsets.length; n--; )\r\n      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > \"u\" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);\r\n  }\r\n  _activate(t) {\r\n    this._activeTarget = t, this._clear();\r\n    const e = ze.split(\",\").map(\r\n      (n) => `${n}[data-twe-target=\"${t}\"],${n}[href=\"${t}\"]`\r\n    ), s = h.findOne(e.join(\",\"), this._config.target);\r\n    s.classList.add(...this._classes.active.split(\" \")), s.setAttribute(Kt, \"\"), s.getAttribute(Ln) ? h.findOne(\r\n      il,\r\n      s.closest(el)\r\n    ).classList.add(...this._classes.active.split(\" \")) : h.parents(s, Ja).forEach(\r\n      (n) => {\r\n        h.prev(\r\n          n,\r\n          `${oi}, ${$n}`\r\n        ).forEach((r) => {\r\n          r.classList.add(...this._classes.active.split(\" \")), r.setAttribute(Kt, \"\");\r\n        }), h.prev(n, tl).forEach(\r\n          (r) => {\r\n            h.children(r, oi).forEach(\r\n              (o) => o.classList.add(...this._classes.active.split(\" \"))\r\n            );\r\n          }\r\n        );\r\n      }\r\n    ), d.trigger(this._scrollElement, Ke, {\r\n      relatedTarget: t\r\n    });\r\n  }\r\n  _clear() {\r\n    h.find(ze, this._config.target).filter(\r\n      (t) => t.classList.contains(...this._classes.active.split(\" \"))\r\n    ).forEach((t) => {\r\n      t.classList.remove(...this._classes.active.split(\" \")), t.removeAttribute(Kt);\r\n    });\r\n  }\r\n  _hide(t) {\r\n    const e = h.findOne(\r\n      qe,\r\n      t.parentNode\r\n    );\r\n    e.style.overflow = \"hidden\", e.style.height = \"0px\";\r\n  }\r\n  _show(t, e) {\r\n    t.style.height = e;\r\n  }\r\n  _getCollapsibles() {\r\n    const t = h.find(\r\n      gs\r\n    );\r\n    t && t.forEach((e) => {\r\n      const s = e.parentNode, n = h.findOne(qe, s), r = n.offsetHeight || n.scrollHeight;\r\n      this._collapsibles.push({\r\n        element: n,\r\n        relatedTarget: e.getAttribute(\"href\"),\r\n        height: `${r}px`\r\n      });\r\n    });\r\n  }\r\n  _showSubsection() {\r\n    h.find(sl).filter((s) => s.hasAttribute(Sn)).forEach((s) => {\r\n      const n = h.findOne(qe, s.parentNode), r = this._collapsibles.find((o) => o.relatedTarget = s.getAttribute(\"href\")).height;\r\n      this._show(n, r);\r\n    });\r\n  }\r\n  _hideSubsection() {\r\n    h.find(\r\n      gs\r\n    ).filter((e) => e.hasAttribute(Kt) === !1).forEach((e) => {\r\n      this._hide(e);\r\n    });\r\n  }\r\n  _bindActivateEvent() {\r\n    d.on(this._element, Ke, () => {\r\n      this._showSubsection(), this._hideSubsection();\r\n    });\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = In.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Es = \"tab\", rl = \"twe.tab\", ye = `.${rl}`, ol = `hide${ye}`, al = `hidden${ye}`, ll = `show${ye}`, cl = `shown${ye}`, dl = \"data-twe-dropdown-menu-ref\", Ot = \"data-twe-tab-active\", ge = \"data-twe-nav-active\", ul = \"[data-twe-dropdown-ref]\", hl = \"[data-twe-nav-ref]\", vs = `[${Ot}]`, fl = `[${ge}]`, bs = \":scope > li > .active\", pl = \"[data-twe-dropdown-toggle-ref]\", _l = \":scope > [data-twe-dropdown-menu-ref] [data-twe-dropdown-show]\", gl = {\r\n  show: \"opacity-100\",\r\n  hide: \"opacity-0\"\r\n}, ml = {\r\n  show: \"string\",\r\n  hide: \"string\"\r\n};\r\nclass Rn extends tt {\r\n  constructor(t, e) {\r\n    super(t), this._classes = this._getClasses(e);\r\n  }\r\n  // Getters\r\n  static get NAME() {\r\n    return Es;\r\n  }\r\n  // Public\r\n  show() {\r\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(ge) === \"\")\r\n      return;\r\n    let t;\r\n    const e = nt(this._element), s = this._element.closest(hl), n = h.findOne(\r\n      fl,\r\n      s\r\n    );\r\n    if (s) {\r\n      const l = s.nodeName === \"UL\" || s.nodeName === \"OL\" ? bs : vs;\r\n      t = h.find(l, s), t = t[t.length - 1];\r\n    }\r\n    const r = t ? d.trigger(t, ol, {\r\n      relatedTarget: this._element\r\n    }) : null;\r\n    if (d.trigger(this._element, ll, {\r\n      relatedTarget: t\r\n    }).defaultPrevented || r !== null && r.defaultPrevented)\r\n      return;\r\n    this._activate(\r\n      this._element,\r\n      s,\r\n      null,\r\n      n,\r\n      this._element\r\n    );\r\n    const a = () => {\r\n      d.trigger(t, al, {\r\n        relatedTarget: this._element\r\n      }), d.trigger(this._element, cl, {\r\n        relatedTarget: t\r\n      });\r\n    };\r\n    e ? this._activate(\r\n      e,\r\n      e.parentNode,\r\n      a,\r\n      n,\r\n      this._element\r\n    ) : a();\r\n  }\r\n  // Private\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...gl,\r\n      ...e,\r\n      ...t\r\n    }, R(Es, t, ml), t;\r\n  }\r\n  _activate(t, e, s, n, r) {\r\n    const a = (e && (e.nodeName === \"UL\" || e.nodeName === \"OL\") ? h.find(bs, e) : h.children(e, vs))[0], l = s && a && a.hasAttribute(Ot), u = () => this._transitionComplete(\r\n      t,\r\n      a,\r\n      s,\r\n      n,\r\n      r\r\n    );\r\n    a && l ? (E.removeClass(a, this._classes.show), E.addClass(a, this._classes.hide), this._queueCallback(u, t, !0)) : u();\r\n  }\r\n  _transitionComplete(t, e, s, n, r) {\r\n    if (e && n) {\r\n      e.removeAttribute(Ot), n.removeAttribute(ge);\r\n      const a = h.findOne(\r\n        _l,\r\n        e.parentNode\r\n      );\r\n      a && a.removeAttribute(Ot), e.getAttribute(\"role\") === \"tab\" && e.setAttribute(\"aria-selected\", !1);\r\n    }\r\n    t.setAttribute(Ot, \"\"), r.setAttribute(ge, \"\"), t.getAttribute(\"role\") === \"tab\" && t.setAttribute(\"aria-selected\", !0), Xt(t), t.classList.contains(this._classes.hide) && (E.removeClass(t, this._classes.hide), E.addClass(t, this._classes.show));\r\n    let o = t.parentNode;\r\n    if (o && o.nodeName === \"LI\" && (o = o.parentNode), o && o.hasAttribute(dl)) {\r\n      const a = t.closest(ul);\r\n      a && h.find(pl, a).forEach(\r\n        (l) => l.setAttribute(Ot, \"\")\r\n      ), t.setAttribute(\"aria-expanded\", !0);\r\n    }\r\n    s && s();\r\n  }\r\n  // Static\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      const e = Rn.getOrCreateInstance(this);\r\n      if (typeof t == \"string\") {\r\n        if (typeof e[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        e[t]();\r\n      }\r\n    });\r\n  }\r\n}\r\n(() => {\r\n  var i = { 454: (s, n, r) => {\r\n    r.d(n, { Z: () => l });\r\n    var o = r(645), a = r.n(o)()(function(u) {\r\n      return u[1];\r\n    });\r\n    a.push([s.id, \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\", \"\"]);\r\n    const l = a;\r\n  }, 645: (s) => {\r\n    s.exports = function(n) {\r\n      var r = [];\r\n      return r.toString = function() {\r\n        return this.map(function(o) {\r\n          var a = n(o);\r\n          return o[2] ? \"@media \".concat(o[2], \" {\").concat(a, \"}\") : a;\r\n        }).join(\"\");\r\n      }, r.i = function(o, a, l) {\r\n        typeof o == \"string\" && (o = [[null, o, \"\"]]);\r\n        var u = {};\r\n        if (l)\r\n          for (var c = 0; c < this.length; c++) {\r\n            var f = this[c][0];\r\n            f != null && (u[f] = !0);\r\n          }\r\n        for (var v = 0; v < o.length; v++) {\r\n          var g = [].concat(o[v]);\r\n          l && u[g[0]] || (a && (g[2] ? g[2] = \"\".concat(a, \" and \").concat(g[2]) : g[2] = a), r.push(g));\r\n        }\r\n      }, r;\r\n    };\r\n  }, 810: () => {\r\n    (function() {\r\n      if (typeof window < \"u\")\r\n        try {\r\n          var s = new window.CustomEvent(\"test\", { cancelable: !0 });\r\n          if (s.preventDefault(), s.defaultPrevented !== !0)\r\n            throw new Error(\"Could not prevent default\");\r\n        } catch {\r\n          var n = function(o, a) {\r\n            var l, u;\r\n            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent(\"CustomEvent\")).initCustomEvent(o, a.bubbles, a.cancelable, a.detail), u = l.preventDefault, l.preventDefault = function() {\r\n              u.call(this);\r\n              try {\r\n                Object.defineProperty(this, \"defaultPrevented\", { get: function() {\r\n                  return !0;\r\n                } });\r\n              } catch {\r\n                this.defaultPrevented = !0;\r\n              }\r\n            }, l;\r\n          };\r\n          n.prototype = window.Event.prototype, window.CustomEvent = n;\r\n        }\r\n    })();\r\n  }, 379: (s, n, r) => {\r\n    var o, a = function() {\r\n      var m = {};\r\n      return function(p) {\r\n        if (m[p] === void 0) {\r\n          var _ = document.querySelector(p);\r\n          if (window.HTMLIFrameElement && _ instanceof window.HTMLIFrameElement)\r\n            try {\r\n              _ = _.contentDocument.head;\r\n            } catch {\r\n              _ = null;\r\n            }\r\n          m[p] = _;\r\n        }\r\n        return m[p];\r\n      };\r\n    }(), l = [];\r\n    function u(m) {\r\n      for (var p = -1, _ = 0; _ < l.length; _++)\r\n        if (l[_].identifier === m) {\r\n          p = _;\r\n          break;\r\n        }\r\n      return p;\r\n    }\r\n    function c(m, p) {\r\n      for (var _ = {}, b = [], w = 0; w < m.length; w++) {\r\n        var C = m[w], y = p.base ? C[0] + p.base : C[0], N = _[y] || 0, S = \"\".concat(y, \" \").concat(N);\r\n        _[y] = N + 1;\r\n        var x = u(S), I = { css: C[1], media: C[2], sourceMap: C[3] };\r\n        x !== -1 ? (l[x].references++, l[x].updater(I)) : l.push({ identifier: S, updater: L(I, p), references: 1 }), b.push(S);\r\n      }\r\n      return b;\r\n    }\r\n    function f(m) {\r\n      var p = document.createElement(\"style\"), _ = m.attributes || {};\r\n      if (_.nonce === void 0) {\r\n        var b = r.nc;\r\n        b && (_.nonce = b);\r\n      }\r\n      if (Object.keys(_).forEach(function(C) {\r\n        p.setAttribute(C, _[C]);\r\n      }), typeof m.insert == \"function\")\r\n        m.insert(p);\r\n      else {\r\n        var w = a(m.insert || \"head\");\r\n        if (!w)\r\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n        w.appendChild(p);\r\n      }\r\n      return p;\r\n    }\r\n    var v, g = (v = [], function(m, p) {\r\n      return v[m] = p, v.filter(Boolean).join(`\r\n`);\r\n    });\r\n    function O(m, p, _, b) {\r\n      var w = _ ? \"\" : b.media ? \"@media \".concat(b.media, \" {\").concat(b.css, \"}\") : b.css;\r\n      if (m.styleSheet)\r\n        m.styleSheet.cssText = g(p, w);\r\n      else {\r\n        var C = document.createTextNode(w), y = m.childNodes;\r\n        y[p] && m.removeChild(y[p]), y.length ? m.insertBefore(C, y[p]) : m.appendChild(C);\r\n      }\r\n    }\r\n    function T(m, p, _) {\r\n      var b = _.css, w = _.media, C = _.sourceMap;\r\n      if (w ? m.setAttribute(\"media\", w) : m.removeAttribute(\"media\"), C && typeof btoa < \"u\" && (b += `\r\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(C)))), \" */\")), m.styleSheet)\r\n        m.styleSheet.cssText = b;\r\n      else {\r\n        for (; m.firstChild; )\r\n          m.removeChild(m.firstChild);\r\n        m.appendChild(document.createTextNode(b));\r\n      }\r\n    }\r\n    var A = null, D = 0;\r\n    function L(m, p) {\r\n      var _, b, w;\r\n      if (p.singleton) {\r\n        var C = D++;\r\n        _ = A || (A = f(p)), b = O.bind(null, _, C, !1), w = O.bind(null, _, C, !0);\r\n      } else\r\n        _ = f(p), b = T.bind(null, _, p), w = function() {\r\n          (function(y) {\r\n            if (y.parentNode === null)\r\n              return !1;\r\n            y.parentNode.removeChild(y);\r\n          })(_);\r\n        };\r\n      return b(m), function(y) {\r\n        if (y) {\r\n          if (y.css === m.css && y.media === m.media && y.sourceMap === m.sourceMap)\r\n            return;\r\n          b(m = y);\r\n        } else\r\n          w();\r\n      };\r\n    }\r\n    s.exports = function(m, p) {\r\n      (p = p || {}).singleton || typeof p.singleton == \"boolean\" || (p.singleton = (o === void 0 && (o = !!(window && document && document.all && !window.atob)), o));\r\n      var _ = c(m = m || [], p);\r\n      return function(b) {\r\n        if (b = b || [], Object.prototype.toString.call(b) === \"[object Array]\") {\r\n          for (var w = 0; w < _.length; w++) {\r\n            var C = u(_[w]);\r\n            l[C].references--;\r\n          }\r\n          for (var y = c(b, p), N = 0; N < _.length; N++) {\r\n            var S = u(_[N]);\r\n            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));\r\n          }\r\n          _ = y;\r\n        }\r\n      };\r\n    };\r\n  } }, t = {};\r\n  function e(s) {\r\n    var n = t[s];\r\n    if (n !== void 0)\r\n      return n.exports;\r\n    var r = t[s] = { id: s, exports: {} };\r\n    return i[s](r, r.exports, e), r.exports;\r\n  }\r\n  e.n = (s) => {\r\n    var n = s && s.__esModule ? () => s.default : () => s;\r\n    return e.d(n, { a: n }), n;\r\n  }, e.d = (s, n) => {\r\n    for (var r in n)\r\n      e.o(n, r) && !e.o(s, r) && Object.defineProperty(s, r, { enumerable: !0, get: n[r] });\r\n  }, e.o = (s, n) => Object.prototype.hasOwnProperty.call(s, n), (() => {\r\n    var s = e(379), n = e.n(s), r = e(454);\r\n    function o(l) {\r\n      if (!l.hasAttribute(\"autocompleted\")) {\r\n        l.setAttribute(\"autocompleted\", \"\");\r\n        var u = new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !0, detail: null });\r\n        l.dispatchEvent(u) || (l.value = \"\");\r\n      }\r\n    }\r\n    function a(l) {\r\n      l.hasAttribute(\"autocompleted\") && (l.removeAttribute(\"autocompleted\"), l.dispatchEvent(new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !1, detail: null })));\r\n    }\r\n    n()(r.Z, { insert: \"head\", singleton: !1 }), r.Z.locals, e(810), document.addEventListener(\"animationstart\", function(l) {\r\n      l.animationName === \"onautofillstart\" ? o(l.target) : a(l.target);\r\n    }, !0), document.addEventListener(\"input\", function(l) {\r\n      l.inputType !== \"insertReplacementText\" && \"data\" in l ? a(l.target) : o(l.target);\r\n    }, !0);\r\n  })();\r\n})();\r\nconst Xe = \"input\", oe = \"twe.input\", xn = \"data-twe-input-wrapper-init\", kn = \"data-twe-input-notch-ref\", Pn = \"data-twe-input-notch-leading-ref\", Mn = \"data-twe-input-notch-middle-ref\", El = \"data-twe-input-notch-trailing-ref\", vl = \"data-twe-input-helper-ref\", bl = \"data-twe-input-placeholder-active\", st = \"data-twe-input-state-active\", ws = \"data-twe-input-focused\", Ts = \"data-twe-input-form-counter\", ae = `[${xn}] input`, le = `[${xn}] textarea`, yt = `[${kn}]`, ys = `[${Pn}]`, As = `[${Mn}]`, wl = `[${vl}]`, Tl = {\r\n  inputFormWhite: !1\r\n}, yl = {\r\n  inputFormWhite: \"(boolean)\"\r\n}, Al = {\r\n  notch: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\r\n  notchLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-e-0 rounded-s-[0.25rem] group-data-[twe-input-focused]:border-e-0 group-data-[twe-input-state-active]:border-e-0\",\r\n  notchLeadingNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-1 group-data-[twe-input-focused]:border-primary\",\r\n  notchLeadingWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-1 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\r\n  notchMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-e-0 border-s-0 group-data-[twe-input-focused]:border-x-0 group-data-[twe-input-state-active]:border-x-0 group-data-[twe-input-focused]:border-t group-data-[twe-input-state-active]:border-t group-data-[twe-input-focused]:border-solid group-data-[twe-input-state-active]:border-solid group-data-[twe-input-focused]:border-t-transparent group-data-[twe-input-state-active]:border-t-transparent\",\r\n  notchMiddleNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-2 group-data-[twe-input-focused]:border-primary\",\r\n  notchMiddleWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-2 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\r\n  notchTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-s-0 rounded-e-[0.25rem] group-data-[twe-input-focused]:border-s-0 group-data-[twe-input-state-active]:border-s-0\",\r\n  notchTrailingNormal: \"border-secondary-500 dark:border-neutral-400 group-data-[twe-input-focused]:shadow-notch-3 group-data-[twe-input-focused]:border-primary\",\r\n  notchTrailingWhite: \"border-neutral-200 group-data-[twe-input-focused]:shadow-notch-3 group-data-[twe-input-focused]:shadow-white group-data-[twe-input-focused]:border-white\",\r\n  counter: \"text-right leading-[1.6]\"\r\n}, Cl = {\r\n  notch: \"string\",\r\n  notchLeading: \"string\",\r\n  notchLeadingNormal: \"string\",\r\n  notchLeadingWhite: \"string\",\r\n  notchMiddle: \"string\",\r\n  notchMiddleNormal: \"string\",\r\n  notchMiddleWhite: \"string\",\r\n  notchTrailing: \"string\",\r\n  notchTrailingNormal: \"string\",\r\n  notchTrailingWhite: \"string\",\r\n  counter: \"string\"\r\n};\r\nclass $ {\r\n  constructor(t, e, s) {\r\n    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(s), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (V.setData(t, oe, this), this.init());\r\n  }\r\n  // Getters\r\n  static get NAME() {\r\n    return Xe;\r\n  }\r\n  get input() {\r\n    return h.findOne(\"input\", this._element) || h.findOne(\"textarea\", this._element);\r\n  }\r\n  // Public\r\n  init() {\r\n    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);\r\n  }\r\n  update() {\r\n    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();\r\n  }\r\n  forceActive() {\r\n    this.input.setAttribute(st, \"\"), h.findOne(yt, this.input.parentNode).setAttribute(\r\n      st,\r\n      \"\"\r\n    );\r\n  }\r\n  forceInactive() {\r\n    this.input.removeAttribute(st), h.findOne(\r\n      yt,\r\n      this.input.parentNode\r\n    ).removeAttribute(st);\r\n  }\r\n  dispose() {\r\n    this._removeBorder(), V.removeData(this._element, oe), this._element = null;\r\n  }\r\n  // Private\r\n  _getConfig(t, e) {\r\n    return t = {\r\n      ...Tl,\r\n      ...E.getDataAttributes(e),\r\n      ...typeof t == \"object\" ? t : {}\r\n    }, R(Xe, t, yl), t;\r\n  }\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...Al,\r\n      ...e,\r\n      ...t\r\n    }, R(Xe, t, Cl), t;\r\n  }\r\n  _getLabelData() {\r\n    this._label = h.findOne(\"label\", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());\r\n  }\r\n  _getHelper() {\r\n    this._helper = h.findOne(wl, this._element);\r\n  }\r\n  _getCounter() {\r\n    this._counter = E.getDataAttribute(\r\n      this.input,\r\n      \"inputShowcounter\"\r\n    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());\r\n  }\r\n  _getEvents() {\r\n    d.on(\r\n      this._element,\r\n      \"focus\",\r\n      \"input\",\r\n      $.activate(new $())\r\n    ), d.on(\r\n      this._element,\r\n      \"input\",\r\n      \"input\",\r\n      $.activate(new $())\r\n    ), d.on(\r\n      this._element,\r\n      \"blur\",\r\n      \"input\",\r\n      $.deactivate(new $())\r\n    ), d.on(\r\n      this._element,\r\n      \"focus\",\r\n      \"textarea\",\r\n      $.activate(new $())\r\n    ), d.on(\r\n      this._element,\r\n      \"input\",\r\n      \"textarea\",\r\n      $.activate(new $())\r\n    ), d.on(\r\n      this._element,\r\n      \"blur\",\r\n      \"textarea\",\r\n      $.deactivate(new $())\r\n    ), d.on(window, \"shown.twe.modal\", (t) => {\r\n      h.find(ae, t.target).forEach(\r\n        (e) => {\r\n          const s = $.getInstance(e.parentNode);\r\n          s && s.update();\r\n        }\r\n      ), h.find(le, t.target).forEach(\r\n        (e) => {\r\n          const s = $.getInstance(e.parentNode);\r\n          s && s.update();\r\n        }\r\n      );\r\n    }), d.on(window, \"shown.twe.dropdown\", (t) => {\r\n      const e = t.target.parentNode.querySelector(\r\n        \"[data-twe-dropdown-menu-ref]\"\r\n      );\r\n      e && (h.find(ae, e).forEach(\r\n        (s) => {\r\n          const n = $.getInstance(s.parentNode);\r\n          n && n.update();\r\n        }\r\n      ), h.find(le, e).forEach(\r\n        (s) => {\r\n          const n = $.getInstance(s.parentNode);\r\n          n && n.update();\r\n        }\r\n      ));\r\n    }), d.on(window, \"shown.twe.tab\", (t) => {\r\n      let e;\r\n      t.target.href ? e = t.target.href.split(\"#\")[1] : e = E.getDataAttribute(t.target, \"target\").split(\r\n        \"#\"\r\n      )[1];\r\n      const s = h.findOne(`#${e}`);\r\n      h.find(ae, s).forEach((n) => {\r\n        const r = $.getInstance(n.parentNode);\r\n        r && r.update();\r\n      }), h.find(le, s).forEach(\r\n        (n) => {\r\n          const r = $.getInstance(n.parentNode);\r\n          r && r.update();\r\n        }\r\n      );\r\n    }), d.on(window, \"reset\", (t) => {\r\n      h.find(ae, t.target).forEach(\r\n        (e) => {\r\n          const s = $.getInstance(e.parentNode);\r\n          s && s.forceInactive();\r\n        }\r\n      ), h.find(le, t.target).forEach(\r\n        (e) => {\r\n          const s = $.getInstance(e.parentNode);\r\n          s && s.forceInactive();\r\n        }\r\n      );\r\n    }), d.on(window, \"onautocomplete\", (t) => {\r\n      const e = $.getInstance(t.target.parentNode);\r\n      !e || !t.cancelable || e.forceActive();\r\n    });\r\n  }\r\n  _showCounter() {\r\n    if (h.find(\r\n      `[${Ts}]`,\r\n      this._element\r\n    ).length > 0)\r\n      return;\r\n    this._counterElement = document.createElement(\"div\"), E.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Ts, \"\");\r\n    const e = this.input.value.length;\r\n    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();\r\n  }\r\n  _bindCounter() {\r\n    d.on(this.input, \"input\", () => {\r\n      const t = this.input.value.length;\r\n      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;\r\n    });\r\n  }\r\n  _toggleDefaultDatePlaceholder(t = this.input) {\r\n    if (!(t.getAttribute(\"type\") === \"date\"))\r\n      return;\r\n    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;\r\n  }\r\n  _showPlaceholder() {\r\n    this.input.setAttribute(bl, \"\");\r\n  }\r\n  _getNotchData() {\r\n    this._notchMiddle = h.findOne(\r\n      As,\r\n      this._element\r\n    ), this._notchLeading = h.findOne(\r\n      ys,\r\n      this._element\r\n    );\r\n  }\r\n  _getLabelWidth() {\r\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\r\n  }\r\n  _getLabelPositionInInputGroup() {\r\n    if (this._labelMarginLeft = 0, !this._element.hasAttribute(\"data-twe-input-group-ref\"))\r\n      return;\r\n    const t = this.input, e = h.prev(\r\n      t,\r\n      \"[data-twe-input-group-text-ref]\"\r\n    )[0];\r\n    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;\r\n  }\r\n  _applyDivs() {\r\n    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, s = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = h.find(yt, this._element), r = Ft(\"div\");\r\n    E.addClass(r, this._classes.notch), r.setAttribute(kn, \"\"), this._notchLeading = Ft(\"div\"), E.addClass(\r\n      this._notchLeading,\r\n      `${this._classes.notchLeading} ${t}`\r\n    ), this._notchLeading.setAttribute(Pn, \"\"), this._notchMiddle = Ft(\"div\"), E.addClass(\r\n      this._notchMiddle,\r\n      `${this._classes.notchMiddle} ${e}`\r\n    ), this._notchMiddle.setAttribute(Mn, \"\"), this._notchTrailing = Ft(\"div\"), E.addClass(\r\n      this._notchTrailing,\r\n      `${this._classes.notchTrailing} ${s}`\r\n    ), this._notchTrailing.setAttribute(El, \"\"), !(n.length >= 1) && (r.append(this._notchLeading), r.append(this._notchMiddle), r.append(this._notchTrailing), this._element.append(r), r.dir = \"ltr\");\r\n  }\r\n  _applyNotch() {\r\n    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\r\n  }\r\n  _removeBorder() {\r\n    const t = h.findOne(yt, this._element);\r\n    t && t.remove();\r\n  }\r\n  _activate(t) {\r\n    Vs(() => {\r\n      this._getElements(t);\r\n      const e = t ? t.target : this.input, s = h.findOne(\r\n        yt,\r\n        this._element\r\n      );\r\n      t && t.type === \"focus\" && s && s.setAttribute(ws, \"\"), e.value !== \"\" && (e.setAttribute(st, \"\"), s && s.setAttribute(st, \"\")), this._toggleDefaultDatePlaceholder(e);\r\n    });\r\n  }\r\n  _getElements(t) {\r\n    if (t && (this._element = t.target.parentNode, this._label = h.findOne(\"label\", this._element)), t && this._label) {\r\n      const e = this._labelWidth;\r\n      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = h.findOne(\r\n        As,\r\n        t.target.parentNode\r\n      ), this._notchLeading = h.findOne(\r\n        ys,\r\n        t.target.parentNode\r\n      ), this._applyNotch());\r\n    }\r\n  }\r\n  _deactivate(t) {\r\n    const e = t ? t.target : this.input;\r\n    if (e.getAttribute(\"aria-expanded\") === \"true\")\r\n      return;\r\n    const s = h.findOne(\r\n      yt,\r\n      e.parentNode\r\n    );\r\n    s.removeAttribute(ws), e.value === \"\" && (e.removeAttribute(st), s.removeAttribute(st)), this._toggleDefaultDatePlaceholder(e);\r\n  }\r\n  static activate(t) {\r\n    return function(e) {\r\n      t._activate(e);\r\n    };\r\n  }\r\n  static deactivate(t) {\r\n    return function(e) {\r\n      t._deactivate(e);\r\n    };\r\n  }\r\n  static jQueryInterface(t, e) {\r\n    return this.each(function() {\r\n      let s = V.getData(this, oe);\r\n      const n = typeof t == \"object\" && t;\r\n      if (!(!s && /dispose/.test(t)) && (s || (s = new $(this, n)), typeof t == \"string\")) {\r\n        if (typeof s[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        s[t](e);\r\n      }\r\n    });\r\n  }\r\n  static getInstance(t) {\r\n    return V.getData(t, oe);\r\n  }\r\n  static getOrCreateInstance(t, e = {}) {\r\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\r\n  }\r\n}\r\nconst Ol = {\r\n  property: \"color\",\r\n  defaultValue: null,\r\n  inherit: !0\r\n}, At = (i, t) => {\r\n  const { property: e, defaultValue: s, inherit: n } = { ...Ol, ...t }, r = document.createElement(\"div\");\r\n  r.classList.add(i), document.body.appendChild(r);\r\n  const a = window.getComputedStyle(r)[e] || s, u = window.getComputedStyle(r.parentElement)[e];\r\n  return document.body.removeChild(r), !n && u && a === u ? s : a || s;\r\n}, Ge = \"ripple\", ce = \"twe.ripple\", Dl = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", Nl = [\"[data-twe-ripple-init]\"], de = [0, 0, 0], Sl = [\r\n  {\r\n    name: \"primary\",\r\n    gradientColor: At(\"text-primary\", { defaultValue: \"#3B71CA\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"secondary\",\r\n    gradientColor: At(\"text-primary-100\", { defaultValue: \"#9FA6B2\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"success\",\r\n    gradientColor: At(\"text-success\", { defaultValue: \"#14A44D\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"danger\",\r\n    gradientColor: At(\"text-danger\", { defaultValue: \"#DC4C64\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"warning\",\r\n    gradientColor: At(\"text-warning\", { defaultValue: \"#E4A11B\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"info\",\r\n    gradientColor: At(\"text-info\", { defaultValue: \"#54B4D3\", inherit: !1 })\r\n  },\r\n  {\r\n    name: \"light\",\r\n    gradientColor: \"#fbfbfb\"\r\n  },\r\n  {\r\n    name: \"dark\",\r\n    gradientColor: \"#262626\"\r\n  }\r\n], Cs = 0.5, Ll = {\r\n  rippleCentered: !1,\r\n  rippleColor: \"\",\r\n  rippleColorDark: \"\",\r\n  rippleDuration: \"500ms\",\r\n  rippleRadius: 0,\r\n  rippleUnbound: !1\r\n}, $l = {\r\n  rippleCentered: \"boolean\",\r\n  rippleColor: \"string\",\r\n  rippleColorDark: \"string\",\r\n  rippleDuration: \"string\",\r\n  rippleRadius: \"number\",\r\n  rippleUnbound: \"boolean\"\r\n}, Il = {\r\n  ripple: \"relative overflow-hidden inline-block align-bottom\",\r\n  rippleWave: \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\r\n  unbound: \"overflow-visible\"\r\n}, Rl = {\r\n  ripple: \"string\",\r\n  rippleWave: \"string\",\r\n  unbound: \"string\"\r\n};\r\nclass Hn {\r\n  constructor(t, e, s) {\r\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(s), this._currentColor = this._options.rippleColor, this._element && (V.setData(t, ce, this), E.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();\r\n  }\r\n  // Getters\r\n  static get NAME() {\r\n    return Ge;\r\n  }\r\n  // Public\r\n  init() {\r\n    this._addClickEvent(this._element);\r\n  }\r\n  dispose() {\r\n    V.removeData(this._element, ce), d.off(this._element, \"mousedown\", this._clickHandler), this._element = null, this._options = null;\r\n  }\r\n  // Private\r\n  _autoInit(t) {\r\n    Nl.forEach((e) => {\r\n      h.closest(t.target, e) && (this._element = h.closest(t.target, e));\r\n    }), this._element.style.minWidth || (E.style(this._element, {\r\n      \"min-width\": getComputedStyle(this._element).width\r\n    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], E.addClass(this._element, this._classes.ripple), this._createRipple(t);\r\n  }\r\n  _addClickEvent(t) {\r\n    d.on(t, \"mousedown\", this._clickHandler);\r\n  }\r\n  _createRipple(t) {\r\n    this._element.className.indexOf(this._classes.ripple) < 0 && E.addClass(this._element, this._classes.ripple);\r\n    const { layerX: e, layerY: s } = t, n = t.offsetX || e, r = t.offsetY || s, o = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), u = {\r\n      offsetX: this._options.rippleCentered ? o / 2 : n,\r\n      offsetY: this._options.rippleCentered ? a / 2 : r,\r\n      height: o,\r\n      width: a\r\n    }, c = this._getDiameter(u), f = this._options.rippleRadius || c / 2, v = {\r\n      delay: l * Cs,\r\n      duration: l - l * Cs\r\n    }, g = {\r\n      left: this._options.rippleCentered ? `${a / 2 - f}px` : `${n - f}px`,\r\n      top: this._options.rippleCentered ? `${o / 2 - f}px` : `${r - f}px`,\r\n      height: `${this._options.rippleRadius * 2 || c}px`,\r\n      width: `${this._options.rippleRadius * 2 || c}px`,\r\n      transitionDelay: `0s, ${v.delay}ms`,\r\n      transitionDuration: `${l}ms, ${v.duration}ms`\r\n    }, O = Ft(\"div\");\r\n    this._createHTMLRipple({\r\n      wrapper: this._element,\r\n      ripple: O,\r\n      styles: g\r\n    }), this._removeHTMLRipple({ ripple: O, duration: l });\r\n  }\r\n  _createHTMLRipple({ wrapper: t, ripple: e, styles: s }) {\r\n    Object.keys(s).forEach(\r\n      (n) => e.style[n] = s[n]\r\n    ), E.addClass(e, this._classes.rippleWave), e.setAttribute(\"data-twe-ripple-ref\", \"\"), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);\r\n  }\r\n  _removeHTMLRipple({ ripple: t, duration: e }) {\r\n    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {\r\n      t.classList.add(\"!opacity-0\");\r\n    }, 10), this._rippleTimer = setTimeout(() => {\r\n      if (t && (t.remove(), this._element)) {\r\n        h.find(\"[data-twe-ripple-ref]\", this._element).forEach(\r\n          (n) => {\r\n            n.remove();\r\n          }\r\n        ), this._isMinWidthSet && (E.style(this._element, { \"min-width\": \"\" }), this._isMinWidthSet = !1);\r\n        const s = this._initialClasses ? this._addedNewRippleClasses(\r\n          this._classes.ripple,\r\n          this._initialClasses\r\n        ) : this._classes.ripple.split(\" \");\r\n        E.removeClass(this._element, s);\r\n      }\r\n    }, e);\r\n  }\r\n  _addedNewRippleClasses(t, e) {\r\n    return t.split(\" \").filter(\r\n      (s) => e.findIndex((n) => s === n) === -1\r\n    );\r\n  }\r\n  _durationToMsNumber(t) {\r\n    return Number(t.replace(\"ms\", \"\").replace(\"s\", \"000\"));\r\n  }\r\n  _getConfig(t = {}) {\r\n    const e = E.getDataAttributes(this._element);\r\n    return t = {\r\n      ...Ll,\r\n      ...e,\r\n      ...t\r\n    }, R(Ge, t, $l), t;\r\n  }\r\n  _getClasses(t = {}) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...Il,\r\n      ...e,\r\n      ...t\r\n    }, R(Ge, t, Rl), t;\r\n  }\r\n  _getDiameter({ offsetX: t, offsetY: e, height: s, width: n }) {\r\n    const r = e <= s / 2, o = t <= n / 2, a = (v, g) => Math.sqrt(v ** 2 + g ** 2), l = e === s / 2 && t === n / 2, u = {\r\n      first: r === !0 && o === !1,\r\n      second: r === !0 && o === !0,\r\n      third: r === !1 && o === !0,\r\n      fourth: r === !1 && o === !1\r\n    }, c = {\r\n      topLeft: a(t, e),\r\n      topRight: a(n - t, e),\r\n      bottomLeft: a(t, s - e),\r\n      bottomRight: a(n - t, s - e)\r\n    };\r\n    let f = 0;\r\n    return l || u.fourth ? f = c.topLeft : u.third ? f = c.topRight : u.second ? f = c.bottomRight : u.first && (f = c.bottomLeft), f * 2;\r\n  }\r\n  _appendRipple(t, e) {\r\n    e.appendChild(t), setTimeout(() => {\r\n      E.addClass(t, \"opacity-0 scale-100\");\r\n    }, 50);\r\n  }\r\n  _toggleUnbound(t) {\r\n    this._options.rippleUnbound === !0 ? E.addClass(t, this._classes.unbound) : E.removeClass(t, this._classes.unbound);\r\n  }\r\n  _addColor(t) {\r\n    let e = this._options.rippleColor || \"rgb(0,0,0)\";\r\n    (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);\r\n    const s = Sl.find(\r\n      (o) => o.name === e.toLowerCase()\r\n    ), n = s ? this._colorToRGB(s.gradientColor).join(\",\") : this._colorToRGB(e).join(\",\"), r = Dl.split(\"{{color}}\").join(`${n}`);\r\n    t.style.backgroundImage = `radial-gradient(circle, ${r})`;\r\n  }\r\n  _colorToRGB(t) {\r\n    function e(r) {\r\n      return r.length < 7 && (r = `#${r[1]}${r[1]}${r[2]}${r[2]}${r[3]}${r[3]}`), [\r\n        parseInt(r.substr(1, 2), 16),\r\n        parseInt(r.substr(3, 2), 16),\r\n        parseInt(r.substr(5, 2), 16)\r\n      ];\r\n    }\r\n    function s(r) {\r\n      const o = document.body.appendChild(\r\n        document.createElement(\"fictum\")\r\n      ), a = \"rgb(1, 2, 3)\";\r\n      return o.style.color = a, o.style.color !== a || (o.style.color = r, o.style.color === a || o.style.color === \"\") ? de : (r = getComputedStyle(o).color, document.body.removeChild(o), r);\r\n    }\r\n    function n(r) {\r\n      return r = r.match(/[.\\d]+/g).map((o) => +Number(o)), r.length = 3, r;\r\n    }\r\n    return t.toLowerCase() === \"transparent\" ? de : t[0] === \"#\" ? e(t) : (t.indexOf(\"rgb\") === -1 && (t = s(t)), t.indexOf(\"rgb\") === 0 ? n(t) : de);\r\n  }\r\n  // Static\r\n  static autoInitial(t) {\r\n    return function(e) {\r\n      t._autoInit(e);\r\n    };\r\n  }\r\n  static jQueryInterface(t) {\r\n    return this.each(function() {\r\n      return V.getData(this, ce) ? null : new Hn(this, t);\r\n    });\r\n  }\r\n  static getInstance(t) {\r\n    return V.getData(t, ce);\r\n  }\r\n  static getOrCreateInstance(t, e = {}) {\r\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\r\n  }\r\n}\r\nconst Qe = \"modal\", xl = \"twe.modal\", K = `.${xl}`, Os = \"Escape\", Ds = {\r\n  backdrop: !0,\r\n  keyboard: !0,\r\n  focus: !0\r\n}, Ns = {\r\n  backdrop: \"(boolean|string)\",\r\n  keyboard: \"boolean\",\r\n  focus: \"boolean\"\r\n}, kl = {\r\n  show: \"transform-none\",\r\n  static: \"scale-[1.02]\",\r\n  staticProperties: \"transition-scale duration-300 ease-in-out\",\r\n  backdrop: \"opacity-50 transition-all duration-300 ease-in-out fixed top-0 left-0 z-[1040] bg-black w-screen h-screen\"\r\n}, Pl = {\r\n  show: \"string\",\r\n  static: \"string\",\r\n  staticProperties: \"string\",\r\n  backdrop: \"string\"\r\n}, Ml = `hide${K}`, Hl = `hidePrevented${K}`, Vl = `hidden${K}`, Wl = `show${K}`, Bl = `shown${K}`, Ss = `resize${K}`, Ls = `click.dismiss${K}`, $s = `keydown.dismiss${K}`, jl = `mouseup.dismiss${K}`, Is = `mousedown.dismiss${K}`, Rs = \"data-twe-modal-open\", xs = \"data-twe-open\", Ut = \"[data-twe-modal-dialog-ref]\", Ul = \"[data-twe-modal-body-ref]\";\r\nclass ai extends tt {\r\n  constructor(t, e, s) {\r\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(s), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._scrollBar = new ri(), this._dialog = h.findOne(Ut, this._element), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._didInit = !1, this._init();\r\n  }\r\n  // Getters\r\n  static get NAME() {\r\n    return Qe;\r\n  }\r\n  static get Default() {\r\n    return Ds;\r\n  }\r\n  static get getDefaultType() {\r\n    return Ns;\r\n  }\r\n  // Public\r\n  toggle(t) {\r\n    return this._isShown ? this.hide() : this.show(t);\r\n  }\r\n  show(t) {\r\n    this._isShown || this._isTransitioning || d.trigger(this._element, Wl, {\r\n      relatedTarget: t\r\n    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.setAttribute(Rs, \"true\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), d.on(this._dialog, Is, () => {\r\n      d.one(this._element, jl, (s) => {\r\n        s.target === this._element && (this._ignoreBackdropClick = !0);\r\n      });\r\n    }), this._showElement(t), this._showBackdrop());\r\n  }\r\n  hide() {\r\n    if (!this._isShown || this._isTransitioning || d.trigger(this._element, Ml).defaultPrevented)\r\n      return;\r\n    this._isShown = !1;\r\n    const e = this._isAnimated();\r\n    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), h.findOne(Ut, this._element).classList.remove(this._classes.show), d.off(this._element, Ls), d.off(this._dialog, Is), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(xs);\r\n  }\r\n  dispose() {\r\n    [window, document, this._dialog].forEach(\r\n      (t) => d.off(t, K)\r\n    ), this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\r\n  }\r\n  handleUpdate() {\r\n    this._adjustDialog();\r\n  }\r\n  // Private\r\n  _init() {\r\n    this._didInit || (Cn(ai), this._didInit = !0);\r\n  }\r\n  _initializeBackDrop() {\r\n    return new yn({\r\n      isVisible: !!this._config.backdrop,\r\n      // 'static' option will be translated to true, and booleans will keep their value\r\n      isAnimated: this._isAnimated(),\r\n      backdropClasses: this._classes.backdrop\r\n    });\r\n  }\r\n  _initializeFocusTrap() {\r\n    return new An(this._element, {\r\n      event: \"keydown\",\r\n      condition: (t) => t.key === \"Tab\"\r\n    });\r\n  }\r\n  _showElement(t) {\r\n    const e = this._isAnimated(), s = h.findOne(Ul, this._dialog);\r\n    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = \"block\", this._element.classList.remove(\"hidden\"), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`${xs}`, \"true\"), this._element.scrollTop = 0;\r\n    const n = h.findOne(Ut, this._element);\r\n    n.classList.add(this._classes.show), n.classList.remove(\"opacity-0\"), n.classList.add(\"opacity-100\"), s && (s.scrollTop = 0), e && Xt(this._element);\r\n    const r = () => {\r\n      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, d.trigger(this._element, Bl, {\r\n        relatedTarget: t\r\n      });\r\n    };\r\n    this._queueCallback(r, this._dialog, e);\r\n  }\r\n  _setEscapeEvent() {\r\n    this._isShown ? d.on(document, $s, (t) => {\r\n      this._config.keyboard && t.key === Os ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Os && this._triggerBackdropTransition();\r\n    }) : d.off(this._element, $s);\r\n  }\r\n  _setResizeEvent() {\r\n    this._isShown ? d.on(window, Ss, () => this._adjustDialog()) : d.off(window, Ss);\r\n  }\r\n  _hideModal() {\r\n    const t = h.findOne(Ut, this._element);\r\n    t.classList.remove(this._classes.show), t.classList.remove(\"opacity-100\"), t.classList.add(\"opacity-0\");\r\n    const e = Je(t);\r\n    setTimeout(() => {\r\n      this._element.style.display = \"none\";\r\n    }, e), this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop.hide(() => {\r\n      document.body.removeAttribute(Rs), this._resetAdjustments(), this._scrollBar.reset(), d.trigger(this._element, Vl);\r\n    });\r\n  }\r\n  _showBackdrop(t) {\r\n    d.on(this._element, Ls, (e) => {\r\n      if (this._ignoreBackdropClick) {\r\n        this._ignoreBackdropClick = !1;\r\n        return;\r\n      }\r\n      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === \"static\" && this._triggerBackdropTransition());\r\n    }), this._backdrop.show(t);\r\n  }\r\n  _isAnimated() {\r\n    return !!h.findOne(Ut, this._element);\r\n  }\r\n  _triggerBackdropTransition() {\r\n    if (d.trigger(this._element, Hl).defaultPrevented)\r\n      return;\r\n    const { classList: e, scrollHeight: s, style: n } = this._element, r = s > document.documentElement.clientHeight;\r\n    if (!r && n.overflowY === \"hidden\" || e.contains(this._classes.static))\r\n      return;\r\n    r || (n.overflowY = \"hidden\"), e.add(...this._classes.static.split(\" \")), e.add(...this._classes.staticProperties.split(\" \"));\r\n    const o = Je(this._element);\r\n    this._queueCallback(() => {\r\n      e.remove(this._classes.static), setTimeout(() => {\r\n        e.remove(...this._classes.staticProperties.split(\" \"));\r\n      }, o), r || this._queueCallback(() => {\r\n        n.overflowY = \"\";\r\n      }, this._dialog);\r\n    }, this._dialog), this._element.focus();\r\n  }\r\n  _getConfig(t) {\r\n    return t = {\r\n      ...Ds,\r\n      ...E.getDataAttributes(this._element),\r\n      ...typeof t == \"object\" ? t : {}\r\n    }, R(Qe, t, Ns), t;\r\n  }\r\n  _getClasses(t) {\r\n    const e = E.getDataClassAttributes(this._element);\r\n    return t = {\r\n      ...kl,\r\n      ...e,\r\n      ...t\r\n    }, R(Qe, t, Pl), t;\r\n  }\r\n  // ----------------------------------------------------------------------\r\n  // the following methods are used to handle overflowing modals\r\n  // ----------------------------------------------------------------------\r\n  _adjustDialog() {\r\n    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0;\r\n    (!s && t && !M() || s && !t && M()) && (this._element.style.paddingLeft = `${e}px`), (s && !t && !M() || !s && t && M()) && (this._element.style.paddingRight = `${e}px`);\r\n  }\r\n  _resetAdjustments() {\r\n    this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\r\n  }\r\n  // Static\r\n  static jQueryInterface(t, e) {\r\n    return this.each(function() {\r\n      const s = ai.getOrCreateInstance(this, t);\r\n      if (typeof t == \"string\") {\r\n        if (typeof s[t] > \"u\")\r\n          throw new TypeError(`No method named \"${t}\"`);\r\n        s[t](e);\r\n      }\r\n    });\r\n  }\r\n}\r\nconst Fl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}`,\r\n    t,\r\n    function(e) {\r\n      e.preventDefault(), i.getOrCreateInstance(this).toggle();\r\n    }\r\n  );\r\n}, Yl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}.data-api`,\r\n    t,\r\n    function(e) {\r\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), gt(this))\r\n        return;\r\n      i.getOrCreateInstance(this).show();\r\n    }\r\n  );\r\n}, Kl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}.data-api`,\r\n    t,\r\n    function(e) {\r\n      const s = nt(this);\r\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), gt(this))\r\n        return;\r\n      d.one(s, i.EVENT_HIDDEN, () => {\r\n        kt(this) && this.focus();\r\n      });\r\n      const n = h.findOne(i.OPEN_SELECTOR);\r\n      n && n !== s && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\r\n    }\r\n  );\r\n}, zl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}`,\r\n    t,\r\n    (e) => {\r\n      e.preventDefault();\r\n      const s = e.target.closest(t);\r\n      i.getOrCreateInstance(s).toggle();\r\n    }\r\n  );\r\n}, ql = (i, t) => {\r\n  d.one(\r\n    document,\r\n    \"mousedown\",\r\n    t,\r\n    i.autoInitial(new i())\r\n  );\r\n}, Xl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}.data-api`,\r\n    t,\r\n    function(e) {\r\n      (e.target.tagName === \"A\" || e.delegateTarget && e.delegateTarget.tagName === \"A\") && e.preventDefault();\r\n      const s = ci(this);\r\n      h.find(s).forEach((r) => {\r\n        i.getOrCreateInstance(r, { toggle: !1 }).toggle();\r\n      });\r\n    }\r\n  );\r\n}, Gl = (i, t) => {\r\n  [].slice.call(\r\n    document.querySelectorAll(t)\r\n  ).map(function(s) {\r\n    return new i(s);\r\n  });\r\n}, Ql = (i, t) => {\r\n  [].slice.call(\r\n    document.querySelectorAll(t)\r\n  ).map(function(s) {\r\n    return new i(s);\r\n  });\r\n}, Zl = (i, t) => {\r\n  d.on(\r\n    document,\r\n    `click.twe.${i.NAME}`,\r\n    t,\r\n    function(e) {\r\n      const s = nt(this);\r\n      [\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), d.one(s, i.EVENT_SHOW, (o) => {\r\n        o.defaultPrevented || d.one(s, i.EVENT_HIDDEN, () => {\r\n          kt(this) && this.focus();\r\n        });\r\n      });\r\n      const n = h.findOne(\r\n        `[${i.OPEN_SELECTOR}=\"true\"]`\r\n      );\r\n      n && i.getInstance(n).hide(), i.getOrCreateInstance(s).toggle(this);\r\n    }\r\n  );\r\n}, Jl = {\r\n  carousel: {\r\n    name: \"Carousel\",\r\n    selector: \"[data-twe-carousel-init]\",\r\n    isToggler: !1\r\n  },\r\n  input: {\r\n    name: \"Input\",\r\n    selector: \"[data-twe-input-wrapper-init]\",\r\n    isToggler: !1\r\n  },\r\n  scrollspy: {\r\n    name: \"ScrollSpy\",\r\n    selector: \"[data-twe-spy='scroll']\",\r\n    isToggler: !1\r\n  },\r\n  // togglers\r\n  button: {\r\n    name: \"Button\",\r\n    selector: \"[data-twe-toggle='button']\",\r\n    isToggler: !0,\r\n    callback: zl\r\n  },\r\n  collapse: {\r\n    name: \"Collapse\",\r\n    selector: \"[data-twe-collapse-init]\",\r\n    isToggler: !0,\r\n    callback: Xl\r\n  },\r\n  dropdown: {\r\n    name: \"Dropdown\",\r\n    selector: \"[data-twe-dropdown-toggle-ref]\",\r\n    isToggler: !0,\r\n    callback: Fl\r\n  },\r\n  ripple: {\r\n    name: \"Ripple\",\r\n    selector: \"[data-twe-ripple-init]\",\r\n    isToggler: !0,\r\n    callback: ql\r\n  },\r\n  offcanvas: {\r\n    name: \"Offcanvas\",\r\n    selector: \"[data-twe-offcanvas-toggle]\",\r\n    isToggler: !0,\r\n    callback: Kl\r\n  },\r\n  tab: {\r\n    name: \"Tab\",\r\n    selector: \"[data-twe-toggle='tab'], [data-twe-toggle='pill'], [data-twe-toggle='list']\",\r\n    isToggler: !0,\r\n    callback: Yl\r\n  },\r\n  tooltip: {\r\n    name: \"Tooltip\",\r\n    selector: \"[data-twe-toggle='tooltip']\",\r\n    isToggler: !1,\r\n    callback: Gl\r\n  },\r\n  popover: {\r\n    name: \"Popover\",\r\n    selector: \"[data-twe-toggle='popover']\",\r\n    isToggler: !0,\r\n    callback: Ql\r\n  },\r\n  modal: {\r\n    name: \"Modal\",\r\n    selector: \"[data-twe-toggle='modal']\",\r\n    isToggler: !0,\r\n    callback: Zl\r\n  }\r\n}, tc = (i) => {\r\n  Vs(() => {\r\n    const t = Hs();\r\n    if (t) {\r\n      const e = i.NAME, s = t.fn[e];\r\n      t.fn[e] = i.jQueryInterface, t.fn[e].Constructor = i, t.fn[e].noConflict = () => (t.fn[e] = s, i.jQueryInterface);\r\n    }\r\n  });\r\n};\r\nclass ec {\r\n  constructor() {\r\n    this.inits = [];\r\n  }\r\n  get initialized() {\r\n    return this.inits;\r\n  }\r\n  isInited(t) {\r\n    return this.inits.includes(t);\r\n  }\r\n  add(t) {\r\n    this.isInited(t) || this.inits.push(t);\r\n  }\r\n}\r\nconst li = new ec();\r\nlet Dt;\r\nconst ic = (i) => Dt[i.NAME] || null, sc = (i, t) => {\r\n  if (!i || !t.allowReinits && li.isInited(i.NAME))\r\n    return;\r\n  li.add(i.NAME);\r\n  const e = ic(i), s = (e == null ? void 0 : e.isToggler) || !1;\r\n  if (tc(i), e != null && e.advanced) {\r\n    e == null || e.advanced(i, e == null ? void 0 : e.selector);\r\n    return;\r\n  }\r\n  if (s) {\r\n    e == null || e.callback(i, e == null ? void 0 : e.selector);\r\n    return;\r\n  }\r\n  h.find(e == null ? void 0 : e.selector).forEach((n) => {\r\n    let r = i.getInstance(n);\r\n    r || (r = new i(n), e != null && e.onInit && r[e.onInit]());\r\n  });\r\n}, nc = {\r\n  allowReinits: !1,\r\n  checkOtherImports: !1\r\n};\r\nclass rc {\r\n  constructor(t) {\r\n    Ne(this, \"init\", (t, e) => {\r\n      t.forEach((s) => sc(s, e));\r\n    });\r\n    Ne(this, \"initTWE\", (t, e) => {\r\n      const s = { ...nc, ...e }, n = Object.keys(Dt).map((r) => {\r\n        if (!!document.querySelector(Dt[r].selector)) {\r\n          const a = t[Dt[r].name];\r\n          return !a && !li.isInited(r) && s.checkOtherImports && console.warn(\r\n            `Please import ${Dt[r].name} from \"tw-elements\" package and add it to a object parameter inside \"initTWE\" function`\r\n          ), a;\r\n        }\r\n      });\r\n      this.init(n, s);\r\n    });\r\n    Dt = t;\r\n  }\r\n}\r\nconst oc = new rc(Jl), lc = oc.initTWE;\r\n\r\n//# sourceMappingURL=tw-elements.es.min.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvanMvdHctZWxlbWVudHMuZXMubWluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1RUFBdUUsRUFBRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxRQUFRLDRDQUE0QztBQUNwRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0IsWUFBWSxFQUFFLG1CQUFtQixFQUFFLHVCQUF1QixFQUFFO0FBQ3ZGO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0QsVUFBVSxZQUFZO0FBQ3RCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxJQUFJLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxLQUFLLGlCQUFpQjtBQUNqRCw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBNEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0NBQXNDO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUUscUNBQXFDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEJBQTBCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlDQUF5QyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCxHQUFHO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QixHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YSxHQUFHLGFBQWEsR0FBRztBQUNwZ0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRyxJQUFJLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLElBQUksZ0JBQWdCO0FBQ2pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCLEVBQUUsRUFBRTtBQUN6QztBQUNBO0FBQ0EsU0FBUywyQkFBMkIsRUFBRSxFQUFFO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QixFQUFFLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQix5Q0FBeUMsMEJBQTBCLGdFQUFnRSxzQkFBc0I7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxVQUFVLDJDQUEyQyxJQUFJLGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpREFBaUQsT0FBTyxpQkFBaUIsT0FBTyxtQkFBbUIsT0FBTyxtQkFBbUIsT0FBTyxtQkFBbUIsT0FBTztBQUMvSjtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQztBQUM5RSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRDQUE0QyxzQ0FBc0M7QUFDbEYsR0FBRztBQUNIO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFzQztBQUM3RSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEMsVUFBVSxTQUFTLE1BQU07QUFDdkUsNkNBQTZDLFVBQVUsU0FBUyxNQUFNO0FBQ3RFLGlCQUFpQixvQ0FBb0M7QUFDckQsZ0JBQWdCLG9DQUFvQztBQUNwRCw4QkFBOEIsUUFBUTtBQUN0Qyw2QkFBNkIsRUFBRSxNQUFNLFdBQVc7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0QkFBNEIsd0JBQXdCO0FBQ3pEO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxPQUFPLFdBQVcsRUFBRTtBQUNoSSx5REFBeUQsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWMsRUFBRSx3QkFBd0IsRUFBRSxpQkFBaUIsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLEVBQUUsd0JBQXdCLEVBQUUsMEJBQTBCLEVBQUUsMEJBQTBCLEVBQUUsNEJBQTRCLEVBQUU7QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0WEFBNFgsR0FBRztBQUMvWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsRUFBRSxvRkFBb0YsRUFBRTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFlRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWVkdXotdGFpbC8uL25vZGVfbW9kdWxlcy90dy1lbGVtZW50cy9qcy90dy1lbGVtZW50cy5lcy5taW4uanM/ZmJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgWW4gPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbnZhciBLbiA9IChpLCB0LCBlKSA9PiB0IGluIGkgPyBZbihpLCB0LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBlIH0pIDogaVt0XSA9IGU7XHJcbnZhciBOZSA9IChpLCB0LCBlKSA9PiAoS24oaSwgdHlwZW9mIHQgIT0gXCJzeW1ib2xcIiA/IHQgKyBcIlwiIDogdCwgZSksIGUpO1xyXG4vKiFcclxuKiBUVyBFbGVtZW50c1xyXG4qIFZlcnNpb246IEZSRUUgMi4wLjBcclxuKiBcclxuKiBDb3B5cmlnaHQ6IE1hdGVyaWFsIERlc2lnbiBmb3IgQm9vdHN0cmFwXHJcbiogaHR0cHM6Ly9tZGJvb3RzdHJhcC5jb20vXHJcbiogXHJcbiogUmVhZCB0aGUgbGljZW5zZTogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vbGljZW5zZS9cclxuKlxyXG4qXHJcbiogRG9jdW1lbnRhdGlvbjogaHR0cHM6Ly90dy1lbGVtZW50cy5jb20vXHJcbipcclxuKiBTdXBwb3J0OiBodHRwczovL21kYm9vdHN0cmFwLmNvbS9zdXBwb3J0L2NhdC90d2VcclxuKlxyXG4qIENvbnRhY3Q6IHRhaWx3aW5kQG1kYm9vdHN0cmFwLmNvbVxyXG4qIFxyXG4qL1xyXG5jb25zdCBTZSA9ICgoKSA9PiB7XHJcbiAgY29uc3QgaSA9IHt9O1xyXG4gIGxldCB0ID0gMTtcclxuICByZXR1cm4ge1xyXG4gICAgc2V0KGUsIHMsIG4pIHtcclxuICAgICAgdHlwZW9mIGVbc10gPiBcInVcIiAmJiAoZVtzXSA9IHtcclxuICAgICAgICBrZXk6IHMsXHJcbiAgICAgICAgaWQ6IHRcclxuICAgICAgfSwgdCsrKSwgaVtlW3NdLmlkXSA9IG47XHJcbiAgICB9LFxyXG4gICAgZ2V0KGUsIHMpIHtcclxuICAgICAgaWYgKCFlIHx8IHR5cGVvZiBlW3NdID4gXCJ1XCIpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIGNvbnN0IG4gPSBlW3NdO1xyXG4gICAgICByZXR1cm4gbi5rZXkgPT09IHMgPyBpW24uaWRdIDogbnVsbDtcclxuICAgIH0sXHJcbiAgICBkZWxldGUoZSwgcykge1xyXG4gICAgICBpZiAodHlwZW9mIGVbc10gPiBcInVcIilcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNvbnN0IG4gPSBlW3NdO1xyXG4gICAgICBuLmtleSA9PT0gcyAmJiAoZGVsZXRlIGlbbi5pZF0sIGRlbGV0ZSBlW3NdKTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpLCBWID0ge1xyXG4gIHNldERhdGEoaSwgdCwgZSkge1xyXG4gICAgU2Uuc2V0KGksIHQsIGUpO1xyXG4gIH0sXHJcbiAgZ2V0RGF0YShpLCB0KSB7XHJcbiAgICByZXR1cm4gU2UuZ2V0KGksIHQpO1xyXG4gIH0sXHJcbiAgcmVtb3ZlRGF0YShpLCB0KSB7XHJcbiAgICBTZS5kZWxldGUoaSwgdCk7XHJcbiAgfVxyXG59LCB6biA9IDFlNiwgcW4gPSAxZTMsIFplID0gXCJ0cmFuc2l0aW9uZW5kXCIsIFhuID0gKGkpID0+IGkgPT0gbnVsbCA/IGAke2l9YCA6IHt9LnRvU3RyaW5nLmNhbGwoaSkubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCksIEduID0gKGkpID0+IHtcclxuICBkb1xyXG4gICAgaSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB6bik7XHJcbiAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGkpKTtcclxuICByZXR1cm4gaTtcclxufSwga3MgPSAoaSkgPT4ge1xyXG4gIGxldCB0ID0gaS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS10YXJnZXRcIik7XHJcbiAgaWYgKCF0IHx8IHQgPT09IFwiI1wiKSB7XHJcbiAgICBsZXQgZSA9IGkuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcclxuICAgIGlmICghZSB8fCAhZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIi5cIikpXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgZS5pbmNsdWRlcyhcIiNcIikgJiYgIWUuc3RhcnRzV2l0aChcIiNcIikgJiYgKGUgPSBgIyR7ZS5zcGxpdChcIiNcIilbMV19YCksIHQgPSBlICYmIGUgIT09IFwiI1wiID8gZS50cmltKCkgOiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gdDtcclxufSwgY2kgPSAoaSkgPT4ge1xyXG4gIGNvbnN0IHQgPSBrcyhpKTtcclxuICByZXR1cm4gdCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpID8gdCA6IG51bGw7XHJcbn0sIG50ID0gKGkpID0+IHtcclxuICBjb25zdCB0ID0ga3MoaSk7XHJcbiAgcmV0dXJuIHQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIDogbnVsbDtcclxufSwgSmUgPSAoaSkgPT4ge1xyXG4gIGlmICghaSlcclxuICAgIHJldHVybiAwO1xyXG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbjogdCwgdHJhbnNpdGlvbkRlbGF5OiBlIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpKTtcclxuICBjb25zdCBzID0gTnVtYmVyLnBhcnNlRmxvYXQodCksIG4gPSBOdW1iZXIucGFyc2VGbG9hdChlKTtcclxuICByZXR1cm4gIXMgJiYgIW4gPyAwIDogKHQgPSB0LnNwbGl0KFwiLFwiKVswXSwgZSA9IGUuc3BsaXQoXCIsXCIpWzBdLCAoTnVtYmVyLnBhcnNlRmxvYXQodCkgKyBOdW1iZXIucGFyc2VGbG9hdChlKSkgKiBxbik7XHJcbn0sIFBzID0gKGkpID0+IHtcclxuICBpLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFplKSk7XHJcbn0sIFN0ID0gKGkpID0+ICFpIHx8IHR5cGVvZiBpICE9IFwib2JqZWN0XCIgPyAhMSA6ICh0eXBlb2YgaS5qcXVlcnkgPCBcInVcIiAmJiAoaSA9IGlbMF0pLCB0eXBlb2YgaS5ub2RlVHlwZSA8IFwidVwiKSwgcnQgPSAoaSkgPT4gU3QoaSkgPyBpLmpxdWVyeSA/IGlbMF0gOiBpIDogdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiBpLmxlbmd0aCA+IDAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGkpIDogbnVsbCwgUiA9IChpLCB0LCBlKSA9PiB7XHJcbiAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgY29uc3QgbiA9IGVbc10sIHIgPSB0W3NdLCBvID0gciAmJiBTdChyKSA/IFwiZWxlbWVudFwiIDogWG4ocik7XHJcbiAgICBpZiAoIW5ldyBSZWdFeHAobikudGVzdChvKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGAke2kudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7c31cIiBwcm92aWRlZCB0eXBlIFwiJHtvfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtufVwiLmBcclxuICAgICAgKTtcclxuICB9KTtcclxufSwga3QgPSAoaSkgPT4ge1xyXG4gIGlmICghaSlcclxuICAgIHJldHVybiAhMTtcclxuICBpZiAoaS5zdHlsZSAmJiBpLnBhcmVudE5vZGUgJiYgaS5wYXJlbnROb2RlLnN0eWxlKSB7XHJcbiAgICBjb25zdCB0ID0gZ2V0Q29tcHV0ZWRTdHlsZShpKSwgZSA9IGdldENvbXB1dGVkU3R5bGUoaS5wYXJlbnROb2RlKTtcclxuICAgIHJldHVybiB0LmRpc3BsYXkgIT09IFwibm9uZVwiICYmIGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdC52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiO1xyXG4gIH1cclxuICByZXR1cm4gITE7XHJcbn0sIGd0ID0gKGkpID0+ICFpIHx8IGkubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IGkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgPyAhMCA6IHR5cGVvZiBpLmRpc2FibGVkIDwgXCJ1XCIgPyBpLmRpc2FibGVkIDogaS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiBpLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpICE9PSBcImZhbHNlXCIsIE1zID0gKGkpID0+IHtcclxuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICBpZiAodHlwZW9mIGkuZ2V0Um9vdE5vZGUgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICBjb25zdCB0ID0gaS5nZXRSb290Tm9kZSgpO1xyXG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gdCA6IG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBpIGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IGkgOiBpLnBhcmVudE5vZGUgPyBNcyhpLnBhcmVudE5vZGUpIDogbnVsbDtcclxufSwgbWUgPSAoKSA9PiBmdW5jdGlvbigpIHtcclxufSwgWHQgPSAoaSkgPT4ge1xyXG4gIGkub2Zmc2V0SGVpZ2h0O1xyXG59LCBIcyA9ICgpID0+IHtcclxuICBjb25zdCB7IGpRdWVyeTogaSB9ID0gd2luZG93O1xyXG4gIHJldHVybiBpICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZShcImRhdGEtdHdlLW5vLWpxdWVyeVwiKSA/IGkgOiBudWxsO1xyXG59LCBMZSA9IFtdLCBWcyA9IChpKSA9PiB7XHJcbiAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIgPyAoTGUubGVuZ3RoIHx8IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcclxuICAgIExlLmZvckVhY2goKHQpID0+IHQoKSk7XHJcbiAgfSksIExlLnB1c2goaSkpIDogaSgpO1xyXG59LCBNID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gXCJydGxcIiwgRnQgPSAoaSkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpKSwgX3QgPSAoaSkgPT4ge1xyXG4gIHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiAmJiBpKCk7XHJcbn0sIFdzID0gKGksIHQsIGUgPSAhMCkgPT4ge1xyXG4gIGlmICghZSkge1xyXG4gICAgX3QoaSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHMgPSA1LCBuID0gSmUodCkgKyBzO1xyXG4gIGxldCByID0gITE7XHJcbiAgY29uc3QgbyA9ICh7IHRhcmdldDogYSB9KSA9PiB7XHJcbiAgICBhID09PSB0ICYmIChyID0gITAsIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihaZSwgbyksIF90KGkpKTtcclxuICB9O1xyXG4gIHQuYWRkRXZlbnRMaXN0ZW5lcihaZSwgbyksIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgciB8fCBQcyh0KTtcclxuICB9LCBuKTtcclxufSwgQnMgPSAoaSwgdCwgZSwgcykgPT4ge1xyXG4gIGxldCBuID0gaS5pbmRleE9mKHQpO1xyXG4gIGlmIChuID09PSAtMSlcclxuICAgIHJldHVybiBpWyFlICYmIHMgPyBpLmxlbmd0aCAtIDEgOiAwXTtcclxuICBjb25zdCByID0gaS5sZW5ndGg7XHJcbiAgcmV0dXJuIG4gKz0gZSA/IDEgOiAtMSwgcyAmJiAobiA9IChuICsgcikgJSByKSwgaVtNYXRoLm1heCgwLCBNYXRoLm1pbihuLCByIC0gMSkpXTtcclxufSwgUW4gPSAvW14uXSooPz1cXC4uKilcXC58LiovLCBabiA9IC9cXC4uKi8sIEpuID0gLzo6XFxkKyQvLCAkZSA9IHt9O1xyXG5sZXQga2kgPSAxO1xyXG5jb25zdCB0ciA9IHtcclxuICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxyXG4gIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxyXG59LCBlciA9IC9eKG1vdXNlZW50ZXJ8bW91c2VsZWF2ZSkvaSwganMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXHJcbiAgXCJjbGlja1wiLFxyXG4gIFwiZGJsY2xpY2tcIixcclxuICBcIm1vdXNldXBcIixcclxuICBcIm1vdXNlZG93blwiLFxyXG4gIFwiY29udGV4dG1lbnVcIixcclxuICBcIm1vdXNld2hlZWxcIixcclxuICBcIkRPTU1vdXNlU2Nyb2xsXCIsXHJcbiAgXCJtb3VzZW92ZXJcIixcclxuICBcIm1vdXNlb3V0XCIsXHJcbiAgXCJtb3VzZW1vdmVcIixcclxuICBcInNlbGVjdHN0YXJ0XCIsXHJcbiAgXCJzZWxlY3RlbmRcIixcclxuICBcImtleWRvd25cIixcclxuICBcImtleXByZXNzXCIsXHJcbiAgXCJrZXl1cFwiLFxyXG4gIFwib3JpZW50YXRpb25jaGFuZ2VcIixcclxuICBcInRvdWNoc3RhcnRcIixcclxuICBcInRvdWNobW92ZVwiLFxyXG4gIFwidG91Y2hlbmRcIixcclxuICBcInRvdWNoY2FuY2VsXCIsXHJcbiAgXCJwb2ludGVyZG93blwiLFxyXG4gIFwicG9pbnRlcm1vdmVcIixcclxuICBcInBvaW50ZXJ1cFwiLFxyXG4gIFwicG9pbnRlcmxlYXZlXCIsXHJcbiAgXCJwb2ludGVyY2FuY2VsXCIsXHJcbiAgXCJnZXN0dXJlc3RhcnRcIixcclxuICBcImdlc3R1cmVjaGFuZ2VcIixcclxuICBcImdlc3R1cmVlbmRcIixcclxuICBcImZvY3VzXCIsXHJcbiAgXCJibHVyXCIsXHJcbiAgXCJjaGFuZ2VcIixcclxuICBcInJlc2V0XCIsXHJcbiAgXCJzZWxlY3RcIixcclxuICBcInN1Ym1pdFwiLFxyXG4gIFwiZm9jdXNpblwiLFxyXG4gIFwiZm9jdXNvdXRcIixcclxuICBcImxvYWRcIixcclxuICBcInVubG9hZFwiLFxyXG4gIFwiYmVmb3JldW5sb2FkXCIsXHJcbiAgXCJyZXNpemVcIixcclxuICBcIm1vdmVcIixcclxuICBcIkRPTUNvbnRlbnRMb2FkZWRcIixcclxuICBcInJlYWR5c3RhdGVjaGFuZ2VcIixcclxuICBcImVycm9yXCIsXHJcbiAgXCJhYm9ydFwiLFxyXG4gIFwic2Nyb2xsXCJcclxuXSk7XHJcbmZ1bmN0aW9uIFVzKGksIHQpIHtcclxuICByZXR1cm4gdCAmJiBgJHt0fTo6JHtraSsrfWAgfHwgaS51aWRFdmVudCB8fCBraSsrO1xyXG59XHJcbmZ1bmN0aW9uIEZzKGkpIHtcclxuICBjb25zdCB0ID0gVXMoaSk7XHJcbiAgcmV0dXJuIGkudWlkRXZlbnQgPSB0LCAkZVt0XSA9ICRlW3RdIHx8IHt9LCAkZVt0XTtcclxufVxyXG5mdW5jdGlvbiBpcihpLCB0KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGUocykge1xyXG4gICAgcmV0dXJuIHMuZGVsZWdhdGVUYXJnZXQgPSBpLCBlLm9uZU9mZiAmJiBkLm9mZihpLCBzLnR5cGUsIHQpLCB0LmFwcGx5KGksIFtzXSk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBzcihpLCB0LCBlKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHMobikge1xyXG4gICAgY29uc3QgciA9IGkucXVlcnlTZWxlY3RvckFsbCh0KTtcclxuICAgIGZvciAobGV0IHsgdGFyZ2V0OiBvIH0gPSBuOyBvICYmIG8gIT09IHRoaXM7IG8gPSBvLnBhcmVudE5vZGUpXHJcbiAgICAgIGZvciAobGV0IGEgPSByLmxlbmd0aDsgYS0tOyBcIlwiKVxyXG4gICAgICAgIGlmIChyW2FdID09PSBvKVxyXG4gICAgICAgICAgcmV0dXJuIG4uZGVsZWdhdGVUYXJnZXQgPSBvLCBzLm9uZU9mZiAmJiBkLm9mZihpLCBuLnR5cGUsIGUpLCBlLmFwcGx5KG8sIFtuXSk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIFlzKGksIHQsIGUgPSBudWxsKSB7XHJcbiAgY29uc3QgcyA9IE9iamVjdC5rZXlzKGkpO1xyXG4gIGZvciAobGV0IG4gPSAwLCByID0gcy5sZW5ndGg7IG4gPCByOyBuKyspIHtcclxuICAgIGNvbnN0IG8gPSBpW3Nbbl1dO1xyXG4gICAgaWYgKG8ub3JpZ2luYWxIYW5kbGVyID09PSB0ICYmIG8uZGVsZWdhdGlvblNlbGVjdG9yID09PSBlKVxyXG4gICAgICByZXR1cm4gbztcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gS3MoaSwgdCwgZSkge1xyXG4gIGNvbnN0IHMgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiLCBuID0gcyA/IGUgOiB0O1xyXG4gIGxldCByID0genMoaSk7XHJcbiAgcmV0dXJuIGpzLmhhcyhyKSB8fCAociA9IGkpLCBbcywgbiwgcl07XHJcbn1cclxuZnVuY3Rpb24gUGkoaSwgdCwgZSwgcywgbikge1xyXG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpKVxyXG4gICAgcmV0dXJuO1xyXG4gIGlmIChlIHx8IChlID0gcywgcyA9IG51bGwpLCBlci50ZXN0KHQpKSB7XHJcbiAgICBjb25zdCBnID0gKE8pID0+IGZ1bmN0aW9uKFQpIHtcclxuICAgICAgaWYgKCFULnJlbGF0ZWRUYXJnZXQgfHwgVC5yZWxhdGVkVGFyZ2V0ICE9PSBULmRlbGVnYXRlVGFyZ2V0ICYmICFULmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKFQucmVsYXRlZFRhcmdldCkpXHJcbiAgICAgICAgcmV0dXJuIE8uY2FsbCh0aGlzLCBUKTtcclxuICAgIH07XHJcbiAgICBzID8gcyA9IGcocykgOiBlID0gZyhlKTtcclxuICB9XHJcbiAgY29uc3QgW3IsIG8sIGFdID0gS3MoXHJcbiAgICB0LFxyXG4gICAgZSxcclxuICAgIHNcclxuICApLCBsID0gRnMoaSksIHUgPSBsW2FdIHx8IChsW2FdID0ge30pLCBjID0gWXMoXHJcbiAgICB1LFxyXG4gICAgbyxcclxuICAgIHIgPyBlIDogbnVsbFxyXG4gICk7XHJcbiAgaWYgKGMpIHtcclxuICAgIGMub25lT2ZmID0gYy5vbmVPZmYgJiYgbjtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgZiA9IFVzKFxyXG4gICAgbyxcclxuICAgIHQucmVwbGFjZShRbiwgXCJcIilcclxuICApLCB2ID0gciA/IHNyKGksIGUsIHMpIDogaXIoaSwgZSk7XHJcbiAgdi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSByID8gZSA6IG51bGwsIHYub3JpZ2luYWxIYW5kbGVyID0gbywgdi5vbmVPZmYgPSBuLCB2LnVpZEV2ZW50ID0gZiwgdVtmXSA9IHYsIGkuYWRkRXZlbnRMaXN0ZW5lcihhLCB2LCByKTtcclxufVxyXG5mdW5jdGlvbiB0aShpLCB0LCBlLCBzLCBuKSB7XHJcbiAgY29uc3QgciA9IFlzKHRbZV0sIHMsIG4pO1xyXG4gIHIgJiYgKGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCByLCAhIW4pLCBkZWxldGUgdFtlXVtyLnVpZEV2ZW50XSk7XHJcbn1cclxuZnVuY3Rpb24gbnIoaSwgdCwgZSwgcykge1xyXG4gIGNvbnN0IG4gPSB0W2VdIHx8IHt9O1xyXG4gIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKHIpID0+IHtcclxuICAgIGlmIChyLmluY2x1ZGVzKHMpKSB7XHJcbiAgICAgIGNvbnN0IG8gPSBuW3JdO1xyXG4gICAgICB0aShcclxuICAgICAgICBpLFxyXG4gICAgICAgIHQsXHJcbiAgICAgICAgZSxcclxuICAgICAgICBvLm9yaWdpbmFsSGFuZGxlcixcclxuICAgICAgICBvLmRlbGVnYXRpb25TZWxlY3RvclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHpzKGkpIHtcclxuICByZXR1cm4gaSA9IGkucmVwbGFjZShabiwgXCJcIiksIHRyW2ldIHx8IGk7XHJcbn1cclxuY29uc3QgZCA9IHtcclxuICBvbihpLCB0LCBlLCBzKSB7XHJcbiAgICBQaShpLCB0LCBlLCBzLCAhMSk7XHJcbiAgfSxcclxuICBvbmUoaSwgdCwgZSwgcykge1xyXG4gICAgUGkoaSwgdCwgZSwgcywgITApO1xyXG4gIH0sXHJcbiAgb2ZmKGksIHQsIGUsIHMpIHtcclxuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBbbiwgciwgb10gPSBLcyhcclxuICAgICAgdCxcclxuICAgICAgZSxcclxuICAgICAgc1xyXG4gICAgKSwgYSA9IG8gIT09IHQsIGwgPSBGcyhpKSwgdSA9IHQuc3RhcnRzV2l0aChcIi5cIik7XHJcbiAgICBpZiAodHlwZW9mIHIgPCBcInVcIikge1xyXG4gICAgICBpZiAoIWwgfHwgIWxbb10pXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB0aShcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgbyxcclxuICAgICAgICByLFxyXG4gICAgICAgIG4gPyBlIDogbnVsbFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB1ICYmIE9iamVjdC5rZXlzKGwpLmZvckVhY2goKGYpID0+IHtcclxuICAgICAgbnIoXHJcbiAgICAgICAgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGYsXHJcbiAgICAgICAgdC5zbGljZSgxKVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjID0gbFtvXSB8fCB7fTtcclxuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goKGYpID0+IHtcclxuICAgICAgY29uc3QgdiA9IGYucmVwbGFjZShKbiwgXCJcIik7XHJcbiAgICAgIGlmICghYSB8fCB0LmluY2x1ZGVzKHYpKSB7XHJcbiAgICAgICAgY29uc3QgZyA9IGNbZl07XHJcbiAgICAgICAgdGkoXHJcbiAgICAgICAgICBpLFxyXG4gICAgICAgICAgbCxcclxuICAgICAgICAgIG8sXHJcbiAgICAgICAgICBnLm9yaWdpbmFsSGFuZGxlcixcclxuICAgICAgICAgIGcuZGVsZWdhdGlvblNlbGVjdG9yXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuICB0cmlnZ2VyKGksIHQsIGUpIHtcclxuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpKVxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIGNvbnN0IHMgPSBIcygpLCBuID0genModCksIHIgPSB0ICE9PSBuLCBvID0ganMuaGFzKG4pO1xyXG4gICAgbGV0IGEsIGwgPSAhMCwgdSA9ICEwLCBjID0gITEsIGYgPSBudWxsO1xyXG4gICAgcmV0dXJuIHIgJiYgcyAmJiAoYSA9IHMuRXZlbnQodCwgZSksIHMoaSkudHJpZ2dlcihhKSwgbCA9ICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCksIHUgPSAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpLCBjID0gYS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSksIG8gPyAoZiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSwgZi5pbml0RXZlbnQobiwgbCwgITApKSA6IGYgPSBuZXcgQ3VzdG9tRXZlbnQodCwge1xyXG4gICAgICBidWJibGVzOiBsLFxyXG4gICAgICBjYW5jZWxhYmxlOiAhMFxyXG4gICAgfSksIHR5cGVvZiBlIDwgXCJ1XCIgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgdiwge1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgIHJldHVybiBlW3ZdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KSwgYyAmJiBmLnByZXZlbnREZWZhdWx0KCksIHUgJiYgaS5kaXNwYXRjaEV2ZW50KGYpLCBmLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGEgPCBcInVcIiAmJiBhLnByZXZlbnREZWZhdWx0KCksIGY7XHJcbiAgfVxyXG59LCByciA9IFwiNS4xLjNcIjtcclxuY2xhc3MgdHQge1xyXG4gIGNvbnN0cnVjdG9yKHQpIHtcclxuICAgIHQgPSBydCh0KSwgdCAmJiAodGhpcy5fZWxlbWVudCA9IHQsIFYuc2V0RGF0YSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSk7XHJcbiAgfVxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBWLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSksIGQub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKSwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaCgodCkgPT4ge1xyXG4gICAgICB0aGlzW3RdID0gbnVsbDtcclxuICAgIH0pO1xyXG4gIH1cclxuICBfcXVldWVDYWxsYmFjayh0LCBlLCBzID0gITApIHtcclxuICAgIFdzKHQsIGUsIHMpO1xyXG4gIH1cclxuICAvKiogU3RhdGljICovXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcclxuICAgIHJldHVybiBWLmdldERhdGEocnQodCksIHRoaXMuREFUQV9LRVkpO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcclxuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcclxuICAgIHJldHVybiBycjtcclxuICB9XHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAnWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJ1xyXG4gICAgKTtcclxuICB9XHJcbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcclxuICAgIHJldHVybiBgdHdlLiR7dGhpcy5OQU1FfWA7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xyXG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XHJcbiAgfVxyXG59XHJcbmNvbnN0IG9yID0gXCJidXR0b25cIiwgYXIgPSBcImFjdGl2ZVwiO1xyXG5jbGFzcyBxcyBleHRlbmRzIHR0IHtcclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIG9yO1xyXG4gIH1cclxuICAvLyBQdWJsaWNcclxuICB0b2dnbGUoKSB7XHJcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcclxuICAgICAgXCJhcmlhLXByZXNzZWRcIixcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGFyKVxyXG4gICAgKTtcclxuICB9XHJcbiAgLy8gU3RhdGljXHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBlID0gcXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgdCA9PT0gXCJ0b2dnbGVcIiAmJiBlW3RdKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxudmFyIGsgPSBcInRvcFwiLCBXID0gXCJib3R0b21cIiwgQiA9IFwicmlnaHRcIiwgUCA9IFwibGVmdFwiLCB2ZSA9IFwiYXV0b1wiLCBQdCA9IFtrLCBXLCBCLCBQXSwgRXQgPSBcInN0YXJ0XCIsIEx0ID0gXCJlbmRcIiwgWHMgPSBcImNsaXBwaW5nUGFyZW50c1wiLCBkaSA9IFwidmlld3BvcnRcIiwgQ3QgPSBcInBvcHBlclwiLCBHcyA9IFwicmVmZXJlbmNlXCIsIGVpID0gLyogQF9fUFVSRV9fICovIFB0LnJlZHVjZShmdW5jdGlvbihpLCB0KSB7XHJcbiAgcmV0dXJuIGkuY29uY2F0KFt0ICsgXCItXCIgKyBFdCwgdCArIFwiLVwiICsgTHRdKTtcclxufSwgW10pLCB1aSA9IC8qIEBfX1BVUkVfXyAqLyBbXS5jb25jYXQoUHQsIFt2ZV0pLnJlZHVjZShmdW5jdGlvbihpLCB0KSB7XHJcbiAgcmV0dXJuIGkuY29uY2F0KFt0LCB0ICsgXCItXCIgKyBFdCwgdCArIFwiLVwiICsgTHRdKTtcclxufSwgW10pLCBRcyA9IFwiYmVmb3JlUmVhZFwiLCBacyA9IFwicmVhZFwiLCBKcyA9IFwiYWZ0ZXJSZWFkXCIsIHRuID0gXCJiZWZvcmVNYWluXCIsIGVuID0gXCJtYWluXCIsIHNuID0gXCJhZnRlck1haW5cIiwgbm4gPSBcImJlZm9yZVdyaXRlXCIsIHJuID0gXCJ3cml0ZVwiLCBvbiA9IFwiYWZ0ZXJXcml0ZVwiLCBhbiA9IFtRcywgWnMsIEpzLCB0biwgZW4sIHNuLCBubiwgcm4sIG9uXTtcclxuZnVuY3Rpb24gUShpKSB7XHJcbiAgcmV0dXJuIGkgPyAoaS5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiBqKGkpIHtcclxuICBpZiAoaSA9PSBudWxsKVxyXG4gICAgcmV0dXJuIHdpbmRvdztcclxuICBpZiAoaS50b1N0cmluZygpICE9PSBcIltvYmplY3QgV2luZG93XVwiKSB7XHJcbiAgICB2YXIgdCA9IGkub3duZXJEb2N1bWVudDtcclxuICAgIHJldHVybiB0ICYmIHQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xyXG4gIH1cclxuICByZXR1cm4gaTtcclxufVxyXG5mdW5jdGlvbiB2dChpKSB7XHJcbiAgdmFyIHQgPSBqKGkpLkVsZW1lbnQ7XHJcbiAgcmV0dXJuIGkgaW5zdGFuY2VvZiB0IHx8IGkgaW5zdGFuY2VvZiBFbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIEYoaSkge1xyXG4gIHZhciB0ID0gaihpKS5IVE1MRWxlbWVudDtcclxuICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgfHwgaSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIGhpKGkpIHtcclxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIilcclxuICAgIHJldHVybiAhMTtcclxuICB2YXIgdCA9IGooaSkuU2hhZG93Um9vdDtcclxuICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgfHwgaSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XHJcbn1cclxuZnVuY3Rpb24gbHIoaSkge1xyXG4gIHZhciB0ID0gaS5zdGF0ZTtcclxuICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciBzID0gdC5zdHlsZXNbZV0gfHwge30sIG4gPSB0LmF0dHJpYnV0ZXNbZV0gfHwge30sIHIgPSB0LmVsZW1lbnRzW2VdO1xyXG4gICAgIUYocikgfHwgIVEocikgfHwgKE9iamVjdC5hc3NpZ24oci5zdHlsZSwgcyksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24obykge1xyXG4gICAgICB2YXIgYSA9IG5bb107XHJcbiAgICAgIGEgPT09ICExID8gci5yZW1vdmVBdHRyaWJ1dGUobykgOiByLnNldEF0dHJpYnV0ZShvLCBhID09PSAhMCA/IFwiXCIgOiBhKTtcclxuICAgIH0pKTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcihpKSB7XHJcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0ge1xyXG4gICAgcG9wcGVyOiB7XHJcbiAgICAgIHBvc2l0aW9uOiB0Lm9wdGlvbnMuc3RyYXRlZ3ksXHJcbiAgICAgIGxlZnQ6IFwiMFwiLFxyXG4gICAgICB0b3A6IFwiMFwiLFxyXG4gICAgICBtYXJnaW46IFwiMFwiXHJcbiAgICB9LFxyXG4gICAgYXJyb3c6IHtcclxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxyXG4gICAgfSxcclxuICAgIHJlZmVyZW5jZToge31cclxuICB9O1xyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBlLnBvcHBlciksIHQuc3R5bGVzID0gZSwgdC5lbGVtZW50cy5hcnJvdyAmJiBPYmplY3QuYXNzaWduKHQuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGUuYXJyb3cpLCBmdW5jdGlvbigpIHtcclxuICAgIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24ocykge1xyXG4gICAgICB2YXIgbiA9IHQuZWxlbWVudHNbc10sIHIgPSB0LmF0dHJpYnV0ZXNbc10gfHwge30sIG8gPSBPYmplY3Qua2V5cyh0LnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzKSA/IHQuc3R5bGVzW3NdIDogZVtzXSksIGEgPSBvLnJlZHVjZShmdW5jdGlvbihsLCB1KSB7XHJcbiAgICAgICAgcmV0dXJuIGxbdV0gPSBcIlwiLCBsO1xyXG4gICAgICB9LCB7fSk7XHJcbiAgICAgICFGKG4pIHx8ICFRKG4pIHx8IChPYmplY3QuYXNzaWduKG4uc3R5bGUsIGEpLCBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcclxuICAgICAgICBuLnJlbW92ZUF0dHJpYnV0ZShsKTtcclxuICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5jb25zdCBmaSA9IHtcclxuICBuYW1lOiBcImFwcGx5U3R5bGVzXCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwid3JpdGVcIixcclxuICBmbjogbHIsXHJcbiAgZWZmZWN0OiBjcixcclxuICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxyXG59O1xyXG5mdW5jdGlvbiBHKGkpIHtcclxuICByZXR1cm4gaS5zcGxpdChcIi1cIilbMF07XHJcbn1cclxudmFyIG10ID0gTWF0aC5tYXgsIEVlID0gTWF0aC5taW4sICR0ID0gTWF0aC5yb3VuZDtcclxuZnVuY3Rpb24gaWkoKSB7XHJcbiAgdmFyIGkgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcclxuICByZXR1cm4gaSAhPSBudWxsICYmIGkuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkoaS5icmFuZHMpID8gaS5icmFuZHMubWFwKGZ1bmN0aW9uKHQpIHtcclxuICAgIHJldHVybiB0LmJyYW5kICsgXCIvXCIgKyB0LnZlcnNpb247XHJcbiAgfSkuam9pbihcIiBcIikgOiBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG59XHJcbmZ1bmN0aW9uIGxuKCkge1xyXG4gIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChpaSgpKTtcclxufVxyXG5mdW5jdGlvbiBJdChpLCB0LCBlKSB7XHJcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpLCBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XHJcbiAgdmFyIHMgPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gMSwgciA9IDE7XHJcbiAgdCAmJiBGKGkpICYmIChuID0gaS5vZmZzZXRXaWR0aCA+IDAgJiYgJHQocy53aWR0aCkgLyBpLm9mZnNldFdpZHRoIHx8IDEsIHIgPSBpLm9mZnNldEhlaWdodCA+IDAgJiYgJHQocy5oZWlnaHQpIC8gaS5vZmZzZXRIZWlnaHQgfHwgMSk7XHJcbiAgdmFyIG8gPSB2dChpKSA/IGooaSkgOiB3aW5kb3csIGEgPSBvLnZpc3VhbFZpZXdwb3J0LCBsID0gIWxuKCkgJiYgZSwgdSA9IChzLmxlZnQgKyAobCAmJiBhID8gYS5vZmZzZXRMZWZ0IDogMCkpIC8gbiwgYyA9IChzLnRvcCArIChsICYmIGEgPyBhLm9mZnNldFRvcCA6IDApKSAvIHIsIGYgPSBzLndpZHRoIC8gbiwgdiA9IHMuaGVpZ2h0IC8gcjtcclxuICByZXR1cm4ge1xyXG4gICAgd2lkdGg6IGYsXHJcbiAgICBoZWlnaHQ6IHYsXHJcbiAgICB0b3A6IGMsXHJcbiAgICByaWdodDogdSArIGYsXHJcbiAgICBib3R0b206IGMgKyB2LFxyXG4gICAgbGVmdDogdSxcclxuICAgIHg6IHUsXHJcbiAgICB5OiBjXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBwaShpKSB7XHJcbiAgdmFyIHQgPSBJdChpKSwgZSA9IGkub2Zmc2V0V2lkdGgsIHMgPSBpLm9mZnNldEhlaWdodDtcclxuICByZXR1cm4gTWF0aC5hYnModC53aWR0aCAtIGUpIDw9IDEgJiYgKGUgPSB0LndpZHRoKSwgTWF0aC5hYnModC5oZWlnaHQgLSBzKSA8PSAxICYmIChzID0gdC5oZWlnaHQpLCB7XHJcbiAgICB4OiBpLm9mZnNldExlZnQsXHJcbiAgICB5OiBpLm9mZnNldFRvcCxcclxuICAgIHdpZHRoOiBlLFxyXG4gICAgaGVpZ2h0OiBzXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjbihpLCB0KSB7XHJcbiAgdmFyIGUgPSB0LmdldFJvb3ROb2RlICYmIHQuZ2V0Um9vdE5vZGUoKTtcclxuICBpZiAoaS5jb250YWlucyh0KSlcclxuICAgIHJldHVybiAhMDtcclxuICBpZiAoZSAmJiBoaShlKSkge1xyXG4gICAgdmFyIHMgPSB0O1xyXG4gICAgZG8ge1xyXG4gICAgICBpZiAocyAmJiBpLmlzU2FtZU5vZGUocykpXHJcbiAgICAgICAgcmV0dXJuICEwO1xyXG4gICAgICBzID0gcy5wYXJlbnROb2RlIHx8IHMuaG9zdDtcclxuICAgIH0gd2hpbGUgKHMpO1xyXG4gIH1cclxuICByZXR1cm4gITE7XHJcbn1cclxuZnVuY3Rpb24gSihpKSB7XHJcbiAgcmV0dXJuIGooaSkuZ2V0Q29tcHV0ZWRTdHlsZShpKTtcclxufVxyXG5mdW5jdGlvbiBkcihpKSB7XHJcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmRleE9mKFEoaSkpID49IDA7XHJcbn1cclxuZnVuY3Rpb24gb3QoaSkge1xyXG4gIHJldHVybiAoKHZ0KGkpID8gaS5vd25lckRvY3VtZW50IDogKFxyXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICBpLmRvY3VtZW50XHJcbiAgKSkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuZnVuY3Rpb24gYmUoaSkge1xyXG4gIHJldHVybiBRKGkpID09PSBcImh0bWxcIiA/IGkgOiAoXHJcbiAgICAvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxyXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxyXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICBpLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxyXG4gICAgaS5wYXJlbnROb2RlIHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkXHJcbiAgICAoaGkoaSkgPyBpLmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXHJcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXHJcbiAgICBvdChpKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gTWkoaSkge1xyXG4gIHJldHVybiAhRihpKSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xyXG4gIEooaSkucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IG51bGwgOiBpLm9mZnNldFBhcmVudDtcclxufVxyXG5mdW5jdGlvbiB1cihpKSB7XHJcbiAgdmFyIHQgPSAvZmlyZWZveC9pLnRlc3QoaWkoKSksIGUgPSAvVHJpZGVudC9pLnRlc3QoaWkoKSk7XHJcbiAgaWYgKGUgJiYgRihpKSkge1xyXG4gICAgdmFyIHMgPSBKKGkpO1xyXG4gICAgaWYgKHMucG9zaXRpb24gPT09IFwiZml4ZWRcIilcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBuID0gYmUoaSk7XHJcbiAgZm9yIChoaShuKSAmJiAobiA9IG4uaG9zdCk7IEYobikgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihRKG4pKSA8IDA7ICkge1xyXG4gICAgdmFyIHIgPSBKKG4pO1xyXG4gICAgaWYgKHIudHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCByLnBlcnNwZWN0aXZlICE9PSBcIm5vbmVcIiB8fCByLmNvbnRhaW4gPT09IFwicGFpbnRcIiB8fCBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKHIud2lsbENoYW5nZSkgIT09IC0xIHx8IHQgJiYgci53aWxsQ2hhbmdlID09PSBcImZpbHRlclwiIHx8IHQgJiYgci5maWx0ZXIgJiYgci5maWx0ZXIgIT09IFwibm9uZVwiKVxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIG4gPSBuLnBhcmVudE5vZGU7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIEd0KGkpIHtcclxuICBmb3IgKHZhciB0ID0gaihpKSwgZSA9IE1pKGkpOyBlICYmIGRyKGUpICYmIEooZSkucG9zaXRpb24gPT09IFwic3RhdGljXCI7IClcclxuICAgIGUgPSBNaShlKTtcclxuICByZXR1cm4gZSAmJiAoUShlKSA9PT0gXCJodG1sXCIgfHwgUShlKSA9PT0gXCJib2R5XCIgJiYgSihlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikgPyB0IDogZSB8fCB1cihpKSB8fCB0O1xyXG59XHJcbmZ1bmN0aW9uIF9pKGkpIHtcclxuICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluZGV4T2YoaSkgPj0gMCA/IFwieFwiIDogXCJ5XCI7XHJcbn1cclxuZnVuY3Rpb24genQoaSwgdCwgZSkge1xyXG4gIHJldHVybiBtdChpLCBFZSh0LCBlKSk7XHJcbn1cclxuZnVuY3Rpb24gaHIoaSwgdCwgZSkge1xyXG4gIHZhciBzID0genQoaSwgdCwgZSk7XHJcbiAgcmV0dXJuIHMgPiBlID8gZSA6IHM7XHJcbn1cclxuZnVuY3Rpb24gZG4oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvcDogMCxcclxuICAgIHJpZ2h0OiAwLFxyXG4gICAgYm90dG9tOiAwLFxyXG4gICAgbGVmdDogMFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gdW4oaSkge1xyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkbigpLCBpKTtcclxufVxyXG5mdW5jdGlvbiBobihpLCB0KSB7XHJcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGUsIHMpIHtcclxuICAgIHJldHVybiBlW3NdID0gaSwgZTtcclxuICB9LCB7fSk7XHJcbn1cclxudmFyIGZyID0gZnVuY3Rpb24odCwgZSkge1xyXG4gIHJldHVybiB0ID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdChPYmplY3QuYXNzaWduKHt9LCBlLnJlY3RzLCB7XHJcbiAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XHJcbiAgfSkpIDogdCwgdW4odHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHQgOiBobih0LCBQdCkpO1xyXG59O1xyXG5mdW5jdGlvbiBwcihpKSB7XHJcbiAgdmFyIHQsIGUgPSBpLnN0YXRlLCBzID0gaS5uYW1lLCBuID0gaS5vcHRpb25zLCByID0gZS5lbGVtZW50cy5hcnJvdywgbyA9IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCBhID0gRyhlLnBsYWNlbWVudCksIGwgPSBfaShhKSwgdSA9IFtQLCBCXS5pbmRleE9mKGEpID49IDAsIGMgPSB1ID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcclxuICBpZiAoISghciB8fCAhbykpIHtcclxuICAgIHZhciBmID0gZnIobi5wYWRkaW5nLCBlKSwgdiA9IHBpKHIpLCBnID0gbCA9PT0gXCJ5XCIgPyBrIDogUCwgTyA9IGwgPT09IFwieVwiID8gVyA6IEIsIFQgPSBlLnJlY3RzLnJlZmVyZW5jZVtjXSArIGUucmVjdHMucmVmZXJlbmNlW2xdIC0gb1tsXSAtIGUucmVjdHMucG9wcGVyW2NdLCBBID0gb1tsXSAtIGUucmVjdHMucmVmZXJlbmNlW2xdLCBEID0gR3QociksIEwgPSBEID8gbCA9PT0gXCJ5XCIgPyBELmNsaWVudEhlaWdodCB8fCAwIDogRC5jbGllbnRXaWR0aCB8fCAwIDogMCwgbSA9IFQgLyAyIC0gQSAvIDIsIHAgPSBmW2ddLCBfID0gTCAtIHZbY10gLSBmW09dLCBiID0gTCAvIDIgLSB2W2NdIC8gMiArIG0sIHcgPSB6dChwLCBiLCBfKSwgQyA9IGw7XHJcbiAgICBlLm1vZGlmaWVyc0RhdGFbc10gPSAodCA9IHt9LCB0W0NdID0gdywgdC5jZW50ZXJPZmZzZXQgPSB3IC0gYiwgdCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIF9yKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm9wdGlvbnMsIHMgPSBlLmVsZW1lbnQsIG4gPSBzID09PSB2b2lkIDAgPyBcIltkYXRhLXBvcHBlci1hcnJvd11cIiA6IHM7XHJcbiAgbiAhPSBudWxsICYmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gdC5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihuKSwgIW4pIHx8IGNuKHQuZWxlbWVudHMucG9wcGVyLCBuKSAmJiAodC5lbGVtZW50cy5hcnJvdyA9IG4pKTtcclxufVxyXG5jb25zdCBmbiA9IHtcclxuICBuYW1lOiBcImFycm93XCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwibWFpblwiLFxyXG4gIGZuOiBwcixcclxuICBlZmZlY3Q6IF9yLFxyXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxyXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXVxyXG59O1xyXG5mdW5jdGlvbiBSdChpKSB7XHJcbiAgcmV0dXJuIGkuc3BsaXQoXCItXCIpWzFdO1xyXG59XHJcbnZhciBnciA9IHtcclxuICB0b3A6IFwiYXV0b1wiLFxyXG4gIHJpZ2h0OiBcImF1dG9cIixcclxuICBib3R0b206IFwiYXV0b1wiLFxyXG4gIGxlZnQ6IFwiYXV0b1wiXHJcbn07XHJcbmZ1bmN0aW9uIG1yKGksIHQpIHtcclxuICB2YXIgZSA9IGkueCwgcyA9IGkueSwgbiA9IHQuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiAkdChlICogbikgLyBuIHx8IDAsXHJcbiAgICB5OiAkdChzICogbikgLyBuIHx8IDBcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIEhpKGkpIHtcclxuICB2YXIgdCwgZSA9IGkucG9wcGVyLCBzID0gaS5wb3BwZXJSZWN0LCBuID0gaS5wbGFjZW1lbnQsIHIgPSBpLnZhcmlhdGlvbiwgbyA9IGkub2Zmc2V0cywgYSA9IGkucG9zaXRpb24sIGwgPSBpLmdwdUFjY2VsZXJhdGlvbiwgdSA9IGkuYWRhcHRpdmUsIGMgPSBpLnJvdW5kT2Zmc2V0cywgZiA9IGkuaXNGaXhlZCwgdiA9IG8ueCwgZyA9IHYgPT09IHZvaWQgMCA/IDAgOiB2LCBPID0gby55LCBUID0gTyA9PT0gdm9pZCAwID8gMCA6IE8sIEEgPSB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgPyBjKHtcclxuICAgIHg6IGcsXHJcbiAgICB5OiBUXHJcbiAgfSkgOiB7XHJcbiAgICB4OiBnLFxyXG4gICAgeTogVFxyXG4gIH07XHJcbiAgZyA9IEEueCwgVCA9IEEueTtcclxuICB2YXIgRCA9IG8uaGFzT3duUHJvcGVydHkoXCJ4XCIpLCBMID0gby5oYXNPd25Qcm9wZXJ0eShcInlcIiksIG0gPSBQLCBwID0gaywgXyA9IHdpbmRvdztcclxuICBpZiAodSkge1xyXG4gICAgdmFyIGIgPSBHdChlKSwgdyA9IFwiY2xpZW50SGVpZ2h0XCIsIEMgPSBcImNsaWVudFdpZHRoXCI7XHJcbiAgICBpZiAoYiA9PT0gaihlKSAmJiAoYiA9IG90KGUpLCBKKGIpLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiICYmIGEgPT09IFwiYWJzb2x1dGVcIiAmJiAodyA9IFwic2Nyb2xsSGVpZ2h0XCIsIEMgPSBcInNjcm9sbFdpZHRoXCIpKSwgYiA9IGIsIG4gPT09IGsgfHwgKG4gPT09IFAgfHwgbiA9PT0gQikgJiYgciA9PT0gTHQpIHtcclxuICAgICAgcCA9IFc7XHJcbiAgICAgIHZhciB5ID0gZiAmJiBiID09PSBfICYmIF8udmlzdWFsVmlld3BvcnQgPyBfLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IChcclxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgICAgICBiW3ddXHJcbiAgICAgICk7XHJcbiAgICAgIFQgLT0geSAtIHMuaGVpZ2h0LCBUICo9IGwgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgICBpZiAobiA9PT0gUCB8fCAobiA9PT0gayB8fCBuID09PSBXKSAmJiByID09PSBMdCkge1xyXG4gICAgICBtID0gQjtcclxuICAgICAgdmFyIE4gPSBmICYmIGIgPT09IF8gJiYgXy52aXN1YWxWaWV3cG9ydCA/IF8udmlzdWFsVmlld3BvcnQud2lkdGggOiAoXHJcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgICAgYltDXVxyXG4gICAgICApO1xyXG4gICAgICBnIC09IE4gLSBzLndpZHRoLCBnICo9IGwgPyAxIDogLTE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBTID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICBwb3NpdGlvbjogYVxyXG4gIH0sIHUgJiYgZ3IpLCB4ID0gYyA9PT0gITAgPyBtcih7XHJcbiAgICB4OiBnLFxyXG4gICAgeTogVFxyXG4gIH0sIGooZSkpIDoge1xyXG4gICAgeDogZyxcclxuICAgIHk6IFRcclxuICB9O1xyXG4gIGlmIChnID0geC54LCBUID0geC55LCBsKSB7XHJcbiAgICB2YXIgSTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTLCAoSSA9IHt9LCBJW3BdID0gTCA/IFwiMFwiIDogXCJcIiwgSVttXSA9IEQgPyBcIjBcIiA6IFwiXCIsIEkudHJhbnNmb3JtID0gKF8uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyBnICsgXCJweCwgXCIgKyBUICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyBnICsgXCJweCwgXCIgKyBUICsgXCJweCwgMClcIiwgSSkpO1xyXG4gIH1cclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgUywgKHQgPSB7fSwgdFtwXSA9IEwgPyBUICsgXCJweFwiIDogXCJcIiwgdFttXSA9IEQgPyBnICsgXCJweFwiIDogXCJcIiwgdC50cmFuc2Zvcm0gPSBcIlwiLCB0KSk7XHJcbn1cclxuZnVuY3Rpb24gRXIoaSkge1xyXG4gIHZhciB0ID0gaS5zdGF0ZSwgZSA9IGkub3B0aW9ucywgcyA9IGUuZ3B1QWNjZWxlcmF0aW9uLCBuID0gcyA9PT0gdm9pZCAwID8gITAgOiBzLCByID0gZS5hZGFwdGl2ZSwgbyA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgYSA9IGUucm91bmRPZmZzZXRzLCBsID0gYSA9PT0gdm9pZCAwID8gITAgOiBhLCB1ID0ge1xyXG4gICAgcGxhY2VtZW50OiBHKHQucGxhY2VtZW50KSxcclxuICAgIHZhcmlhdGlvbjogUnQodC5wbGFjZW1lbnQpLFxyXG4gICAgcG9wcGVyOiB0LmVsZW1lbnRzLnBvcHBlcixcclxuICAgIHBvcHBlclJlY3Q6IHQucmVjdHMucG9wcGVyLFxyXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBuLFxyXG4gICAgaXNGaXhlZDogdC5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCJcclxuICB9O1xyXG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLnBvcHBlciwgSGkoT2JqZWN0LmFzc2lnbih7fSwgdSwge1xyXG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXHJcbiAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxyXG4gICAgYWRhcHRpdmU6IG8sXHJcbiAgICByb3VuZE9mZnNldHM6IGxcclxuICB9KSkpKSwgdC5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwgJiYgKHQuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMuYXJyb3csIEhpKE9iamVjdC5hc3NpZ24oe30sIHUsIHtcclxuICAgIG9mZnNldHM6IHQubW9kaWZpZXJzRGF0YS5hcnJvdyxcclxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXHJcbiAgICBhZGFwdGl2ZTogITEsXHJcbiAgICByb3VuZE9mZnNldHM6IGxcclxuICB9KSkpKSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcclxuICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IHQucGxhY2VtZW50XHJcbiAgfSk7XHJcbn1cclxuY29uc3QgZ2kgPSB7XHJcbiAgbmFtZTogXCJjb21wdXRlU3R5bGVzXCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcclxuICBmbjogRXIsXHJcbiAgZGF0YToge31cclxufTtcclxudmFyIHNlID0ge1xyXG4gIHBhc3NpdmU6ICEwXHJcbn07XHJcbmZ1bmN0aW9uIHZyKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLmluc3RhbmNlLCBzID0gaS5vcHRpb25zLCBuID0gcy5zY3JvbGwsIHIgPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIG8gPSBzLnJlc2l6ZSwgYSA9IG8gPT09IHZvaWQgMCA/ICEwIDogbywgbCA9IGoodC5lbGVtZW50cy5wb3BwZXIpLCB1ID0gW10uY29uY2F0KHQuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHQuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xyXG4gIHJldHVybiByICYmIHUuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICBjLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIHNlKTtcclxuICB9KSwgYSAmJiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZS51cGRhdGUsIHNlKSwgZnVuY3Rpb24oKSB7XHJcbiAgICByICYmIHUuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcbiAgICAgIGMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgc2UpO1xyXG4gICAgfSksIGEgJiYgbC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCBzZSk7XHJcbiAgfTtcclxufVxyXG5jb25zdCBtaSA9IHtcclxuICBuYW1lOiBcImV2ZW50TGlzdGVuZXJzXCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwid3JpdGVcIixcclxuICBmbjogZnVuY3Rpb24oKSB7XHJcbiAgfSxcclxuICBlZmZlY3Q6IHZyLFxyXG4gIGRhdGE6IHt9XHJcbn07XHJcbnZhciBiciA9IHtcclxuICBsZWZ0OiBcInJpZ2h0XCIsXHJcbiAgcmlnaHQ6IFwibGVmdFwiLFxyXG4gIGJvdHRvbTogXCJ0b3BcIixcclxuICB0b3A6IFwiYm90dG9tXCJcclxufTtcclxuZnVuY3Rpb24gdWUoaSkge1xyXG4gIHJldHVybiBpLnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4gYnJbdF07XHJcbiAgfSk7XHJcbn1cclxudmFyIHdyID0ge1xyXG4gIHN0YXJ0OiBcImVuZFwiLFxyXG4gIGVuZDogXCJzdGFydFwiXHJcbn07XHJcbmZ1bmN0aW9uIFZpKGkpIHtcclxuICByZXR1cm4gaS5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIHdyW3RdO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEVpKGkpIHtcclxuICB2YXIgdCA9IGooaSksIGUgPSB0LnBhZ2VYT2Zmc2V0LCBzID0gdC5wYWdlWU9mZnNldDtcclxuICByZXR1cm4ge1xyXG4gICAgc2Nyb2xsTGVmdDogZSxcclxuICAgIHNjcm9sbFRvcDogc1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gdmkoaSkge1xyXG4gIHJldHVybiBJdChvdChpKSkubGVmdCArIEVpKGkpLnNjcm9sbExlZnQ7XHJcbn1cclxuZnVuY3Rpb24gVHIoaSwgdCkge1xyXG4gIHZhciBlID0gaihpKSwgcyA9IG90KGkpLCBuID0gZS52aXN1YWxWaWV3cG9ydCwgciA9IHMuY2xpZW50V2lkdGgsIG8gPSBzLmNsaWVudEhlaWdodCwgYSA9IDAsIGwgPSAwO1xyXG4gIGlmIChuKSB7XHJcbiAgICByID0gbi53aWR0aCwgbyA9IG4uaGVpZ2h0O1xyXG4gICAgdmFyIHUgPSBsbigpO1xyXG4gICAgKHUgfHwgIXUgJiYgdCA9PT0gXCJmaXhlZFwiKSAmJiAoYSA9IG4ub2Zmc2V0TGVmdCwgbCA9IG4ub2Zmc2V0VG9wKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoOiByLFxyXG4gICAgaGVpZ2h0OiBvLFxyXG4gICAgeDogYSArIHZpKGkpLFxyXG4gICAgeTogbFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24geXIoaSkge1xyXG4gIHZhciB0LCBlID0gb3QoaSksIHMgPSBFaShpKSwgbiA9ICh0ID0gaS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5ib2R5LCByID0gbXQoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgbiA/IG4uc2Nyb2xsV2lkdGggOiAwLCBuID8gbi5jbGllbnRXaWR0aCA6IDApLCBvID0gbXQoZS5zY3JvbGxIZWlnaHQsIGUuY2xpZW50SGVpZ2h0LCBuID8gbi5zY3JvbGxIZWlnaHQgOiAwLCBuID8gbi5jbGllbnRIZWlnaHQgOiAwKSwgYSA9IC1zLnNjcm9sbExlZnQgKyB2aShpKSwgbCA9IC1zLnNjcm9sbFRvcDtcclxuICByZXR1cm4gSihuIHx8IGUpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiAmJiAoYSArPSBtdChlLmNsaWVudFdpZHRoLCBuID8gbi5jbGllbnRXaWR0aCA6IDApIC0gciksIHtcclxuICAgIHdpZHRoOiByLFxyXG4gICAgaGVpZ2h0OiBvLFxyXG4gICAgeDogYSxcclxuICAgIHk6IGxcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGJpKGkpIHtcclxuICB2YXIgdCA9IEooaSksIGUgPSB0Lm92ZXJmbG93LCBzID0gdC5vdmVyZmxvd1gsIG4gPSB0Lm92ZXJmbG93WTtcclxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KGUgKyBuICsgcyk7XHJcbn1cclxuZnVuY3Rpb24gcG4oaSkge1xyXG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKFEoaSkpID49IDAgPyBpLm93bmVyRG9jdW1lbnQuYm9keSA6IEYoaSkgJiYgYmkoaSkgPyBpIDogcG4oYmUoaSkpO1xyXG59XHJcbmZ1bmN0aW9uIHF0KGksIHQpIHtcclxuICB2YXIgZTtcclxuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBbXSk7XHJcbiAgdmFyIHMgPSBwbihpKSwgbiA9IHMgPT09ICgoZSA9IGkub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYm9keSksIHIgPSBqKHMpLCBvID0gbiA/IFtyXS5jb25jYXQoci52aXN1YWxWaWV3cG9ydCB8fCBbXSwgYmkocykgPyBzIDogW10pIDogcywgYSA9IHQuY29uY2F0KG8pO1xyXG4gIHJldHVybiBuID8gYSA6IChcclxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxyXG4gICAgYS5jb25jYXQocXQoYmUobykpKVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gc2koaSkge1xyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpLCB7XHJcbiAgICBsZWZ0OiBpLngsXHJcbiAgICB0b3A6IGkueSxcclxuICAgIHJpZ2h0OiBpLnggKyBpLndpZHRoLFxyXG4gICAgYm90dG9tOiBpLnkgKyBpLmhlaWdodFxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEFyKGksIHQpIHtcclxuICB2YXIgZSA9IEl0KGksICExLCB0ID09PSBcImZpeGVkXCIpO1xyXG4gIHJldHVybiBlLnRvcCA9IGUudG9wICsgaS5jbGllbnRUb3AsIGUubGVmdCA9IGUubGVmdCArIGkuY2xpZW50TGVmdCwgZS5ib3R0b20gPSBlLnRvcCArIGkuY2xpZW50SGVpZ2h0LCBlLnJpZ2h0ID0gZS5sZWZ0ICsgaS5jbGllbnRXaWR0aCwgZS53aWR0aCA9IGkuY2xpZW50V2lkdGgsIGUuaGVpZ2h0ID0gaS5jbGllbnRIZWlnaHQsIGUueCA9IGUubGVmdCwgZS55ID0gZS50b3AsIGU7XHJcbn1cclxuZnVuY3Rpb24gV2koaSwgdCwgZSkge1xyXG4gIHJldHVybiB0ID09PSBkaSA/IHNpKFRyKGksIGUpKSA6IHZ0KHQpID8gQXIodCwgZSkgOiBzaSh5cihvdChpKSkpO1xyXG59XHJcbmZ1bmN0aW9uIENyKGkpIHtcclxuICB2YXIgdCA9IHF0KGJlKGkpKSwgZSA9IFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5kZXhPZihKKGkpLnBvc2l0aW9uKSA+PSAwLCBzID0gZSAmJiBGKGkpID8gR3QoaSkgOiBpO1xyXG4gIHJldHVybiB2dChzKSA/IHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcclxuICAgIHJldHVybiB2dChuKSAmJiBjbihuLCBzKSAmJiBRKG4pICE9PSBcImJvZHlcIjtcclxuICB9KSA6IFtdO1xyXG59XHJcbmZ1bmN0aW9uIE9yKGksIHQsIGUsIHMpIHtcclxuICB2YXIgbiA9IHQgPT09IFwiY2xpcHBpbmdQYXJlbnRzXCIgPyBDcihpKSA6IFtdLmNvbmNhdCh0KSwgciA9IFtdLmNvbmNhdChuLCBbZV0pLCBvID0gclswXSwgYSA9IHIucmVkdWNlKGZ1bmN0aW9uKGwsIHUpIHtcclxuICAgIHZhciBjID0gV2koaSwgdSwgcyk7XHJcbiAgICByZXR1cm4gbC50b3AgPSBtdChjLnRvcCwgbC50b3ApLCBsLnJpZ2h0ID0gRWUoYy5yaWdodCwgbC5yaWdodCksIGwuYm90dG9tID0gRWUoYy5ib3R0b20sIGwuYm90dG9tKSwgbC5sZWZ0ID0gbXQoYy5sZWZ0LCBsLmxlZnQpLCBsO1xyXG4gIH0sIFdpKGksIG8sIHMpKTtcclxuICByZXR1cm4gYS53aWR0aCA9IGEucmlnaHQgLSBhLmxlZnQsIGEuaGVpZ2h0ID0gYS5ib3R0b20gLSBhLnRvcCwgYS54ID0gYS5sZWZ0LCBhLnkgPSBhLnRvcCwgYTtcclxufVxyXG5mdW5jdGlvbiBfbihpKSB7XHJcbiAgdmFyIHQgPSBpLnJlZmVyZW5jZSwgZSA9IGkuZWxlbWVudCwgcyA9IGkucGxhY2VtZW50LCBuID0gcyA/IEcocykgOiBudWxsLCByID0gcyA/IFJ0KHMpIDogbnVsbCwgbyA9IHQueCArIHQud2lkdGggLyAyIC0gZS53aWR0aCAvIDIsIGEgPSB0LnkgKyB0LmhlaWdodCAvIDIgLSBlLmhlaWdodCAvIDIsIGw7XHJcbiAgc3dpdGNoIChuKSB7XHJcbiAgICBjYXNlIGs6XHJcbiAgICAgIGwgPSB7XHJcbiAgICAgICAgeDogbyxcclxuICAgICAgICB5OiB0LnkgLSBlLmhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgVzpcclxuICAgICAgbCA9IHtcclxuICAgICAgICB4OiBvLFxyXG4gICAgICAgIHk6IHQueSArIHQuaGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBCOlxyXG4gICAgICBsID0ge1xyXG4gICAgICAgIHg6IHQueCArIHQud2lkdGgsXHJcbiAgICAgICAgeTogYVxyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgUDpcclxuICAgICAgbCA9IHtcclxuICAgICAgICB4OiB0LnggLSBlLndpZHRoLFxyXG4gICAgICAgIHk6IGFcclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBsID0ge1xyXG4gICAgICAgIHg6IHQueCxcclxuICAgICAgICB5OiB0LnlcclxuICAgICAgfTtcclxuICB9XHJcbiAgdmFyIHUgPSBuID8gX2kobikgOiBudWxsO1xyXG4gIGlmICh1ICE9IG51bGwpIHtcclxuICAgIHZhciBjID0gdSA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xyXG4gICAgc3dpdGNoIChyKSB7XHJcbiAgICAgIGNhc2UgRXQ6XHJcbiAgICAgICAgbFt1XSA9IGxbdV0gLSAodFtjXSAvIDIgLSBlW2NdIC8gMik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgTHQ6XHJcbiAgICAgICAgbFt1XSA9IGxbdV0gKyAodFtjXSAvIDIgLSBlW2NdIC8gMik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsO1xyXG59XHJcbmZ1bmN0aW9uIHh0KGksIHQpIHtcclxuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XHJcbiAgdmFyIGUgPSB0LCBzID0gZS5wbGFjZW1lbnQsIG4gPSBzID09PSB2b2lkIDAgPyBpLnBsYWNlbWVudCA6IHMsIHIgPSBlLnN0cmF0ZWd5LCBvID0gciA9PT0gdm9pZCAwID8gaS5zdHJhdGVneSA6IHIsIGEgPSBlLmJvdW5kYXJ5LCBsID0gYSA9PT0gdm9pZCAwID8gWHMgOiBhLCB1ID0gZS5yb290Qm91bmRhcnksIGMgPSB1ID09PSB2b2lkIDAgPyBkaSA6IHUsIGYgPSBlLmVsZW1lbnRDb250ZXh0LCB2ID0gZiA9PT0gdm9pZCAwID8gQ3QgOiBmLCBnID0gZS5hbHRCb3VuZGFyeSwgTyA9IGcgPT09IHZvaWQgMCA/ICExIDogZywgVCA9IGUucGFkZGluZywgQSA9IFQgPT09IHZvaWQgMCA/IDAgOiBULCBEID0gdW4odHlwZW9mIEEgIT0gXCJudW1iZXJcIiA/IEEgOiBobihBLCBQdCkpLCBMID0gdiA9PT0gQ3QgPyBHcyA6IEN0LCBtID0gaS5yZWN0cy5wb3BwZXIsIHAgPSBpLmVsZW1lbnRzW08gPyBMIDogdl0sIF8gPSBPcih2dChwKSA/IHAgOiBwLmNvbnRleHRFbGVtZW50IHx8IG90KGkuZWxlbWVudHMucG9wcGVyKSwgbCwgYywgbyksIGIgPSBJdChpLmVsZW1lbnRzLnJlZmVyZW5jZSksIHcgPSBfbih7XHJcbiAgICByZWZlcmVuY2U6IGIsXHJcbiAgICBlbGVtZW50OiBtLFxyXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcclxuICAgIHBsYWNlbWVudDogblxyXG4gIH0pLCBDID0gc2koT2JqZWN0LmFzc2lnbih7fSwgbSwgdykpLCB5ID0gdiA9PT0gQ3QgPyBDIDogYiwgTiA9IHtcclxuICAgIHRvcDogXy50b3AgLSB5LnRvcCArIEQudG9wLFxyXG4gICAgYm90dG9tOiB5LmJvdHRvbSAtIF8uYm90dG9tICsgRC5ib3R0b20sXHJcbiAgICBsZWZ0OiBfLmxlZnQgLSB5LmxlZnQgKyBELmxlZnQsXHJcbiAgICByaWdodDogeS5yaWdodCAtIF8ucmlnaHQgKyBELnJpZ2h0XHJcbiAgfSwgUyA9IGkubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XHJcbiAgaWYgKHYgPT09IEN0ICYmIFMpIHtcclxuICAgIHZhciB4ID0gU1tuXTtcclxuICAgIE9iamVjdC5rZXlzKE4pLmZvckVhY2goZnVuY3Rpb24oSSkge1xyXG4gICAgICB2YXIgYXQgPSBbQiwgV10uaW5kZXhPZihJKSA+PSAwID8gMSA6IC0xLCBsdCA9IFtrLCBXXS5pbmRleE9mKEkpID49IDAgPyBcInlcIiA6IFwieFwiO1xyXG4gICAgICBOW0ldICs9IHhbbHRdICogYXQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIE47XHJcbn1cclxuZnVuY3Rpb24gRHIoaSwgdCkge1xyXG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcclxuICB2YXIgZSA9IHQsIHMgPSBlLnBsYWNlbWVudCwgbiA9IGUuYm91bmRhcnksIHIgPSBlLnJvb3RCb3VuZGFyeSwgbyA9IGUucGFkZGluZywgYSA9IGUuZmxpcFZhcmlhdGlvbnMsIGwgPSBlLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgdSA9IGwgPT09IHZvaWQgMCA/IHVpIDogbCwgYyA9IFJ0KHMpLCBmID0gYyA/IGEgPyBlaSA6IGVpLmZpbHRlcihmdW5jdGlvbihPKSB7XHJcbiAgICByZXR1cm4gUnQoTykgPT09IGM7XHJcbiAgfSkgOiBQdCwgdiA9IGYuZmlsdGVyKGZ1bmN0aW9uKE8pIHtcclxuICAgIHJldHVybiB1LmluZGV4T2YoTykgPj0gMDtcclxuICB9KTtcclxuICB2Lmxlbmd0aCA9PT0gMCAmJiAodiA9IGYpO1xyXG4gIHZhciBnID0gdi5yZWR1Y2UoZnVuY3Rpb24oTywgVCkge1xyXG4gICAgcmV0dXJuIE9bVF0gPSB4dChpLCB7XHJcbiAgICAgIHBsYWNlbWVudDogVCxcclxuICAgICAgYm91bmRhcnk6IG4sXHJcbiAgICAgIHJvb3RCb3VuZGFyeTogcixcclxuICAgICAgcGFkZGluZzogb1xyXG4gICAgfSlbRyhUKV0sIE87XHJcbiAgfSwge30pO1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhnKS5zb3J0KGZ1bmN0aW9uKE8sIFQpIHtcclxuICAgIHJldHVybiBnW09dIC0gZ1tUXTtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBOcihpKSB7XHJcbiAgaWYgKEcoaSkgPT09IHZlKVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIHZhciB0ID0gdWUoaSk7XHJcbiAgcmV0dXJuIFtWaShpKSwgdCwgVmkodCldO1xyXG59XHJcbmZ1bmN0aW9uIFNyKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm9wdGlvbnMsIHMgPSBpLm5hbWU7XHJcbiAgaWYgKCF0Lm1vZGlmaWVyc0RhdGFbc10uX3NraXApIHtcclxuICAgIGZvciAodmFyIG4gPSBlLm1haW5BeGlzLCByID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCBvID0gZS5hbHRBeGlzLCBhID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBsID0gZS5mYWxsYmFja1BsYWNlbWVudHMsIHUgPSBlLnBhZGRpbmcsIGMgPSBlLmJvdW5kYXJ5LCBmID0gZS5yb290Qm91bmRhcnksIHYgPSBlLmFsdEJvdW5kYXJ5LCBnID0gZS5mbGlwVmFyaWF0aW9ucywgTyA9IGcgPT09IHZvaWQgMCA/ICEwIDogZywgVCA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCBBID0gdC5vcHRpb25zLnBsYWNlbWVudCwgRCA9IEcoQSksIEwgPSBEID09PSBBLCBtID0gbCB8fCAoTCB8fCAhTyA/IFt1ZShBKV0gOiBOcihBKSksIHAgPSBbQV0uY29uY2F0KG0pLnJlZHVjZShmdW5jdGlvbih3dCwgZXQpIHtcclxuICAgICAgcmV0dXJuIHd0LmNvbmNhdChHKGV0KSA9PT0gdmUgPyBEcih0LCB7XHJcbiAgICAgICAgcGxhY2VtZW50OiBldCxcclxuICAgICAgICBib3VuZGFyeTogYyxcclxuICAgICAgICByb290Qm91bmRhcnk6IGYsXHJcbiAgICAgICAgcGFkZGluZzogdSxcclxuICAgICAgICBmbGlwVmFyaWF0aW9uczogTyxcclxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IFRcclxuICAgICAgfSkgOiBldCk7XHJcbiAgICB9LCBbXSksIF8gPSB0LnJlY3RzLnJlZmVyZW5jZSwgYiA9IHQucmVjdHMucG9wcGVyLCB3ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgQyA9ICEwLCB5ID0gcFswXSwgTiA9IDA7IE4gPCBwLmxlbmd0aDsgTisrKSB7XHJcbiAgICAgIHZhciBTID0gcFtOXSwgeCA9IEcoUyksIEkgPSBSdChTKSA9PT0gRXQsIGF0ID0gW2ssIFddLmluZGV4T2YoeCkgPj0gMCwgbHQgPSBhdCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsIEggPSB4dCh0LCB7XHJcbiAgICAgICAgcGxhY2VtZW50OiBTLFxyXG4gICAgICAgIGJvdW5kYXJ5OiBjLFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeTogZixcclxuICAgICAgICBhbHRCb3VuZGFyeTogdixcclxuICAgICAgICBwYWRkaW5nOiB1XHJcbiAgICAgIH0pLCBZID0gYXQgPyBJID8gQiA6IFAgOiBJID8gVyA6IGs7XHJcbiAgICAgIF9bbHRdID4gYltsdF0gJiYgKFkgPSB1ZShZKSk7XHJcbiAgICAgIHZhciBadCA9IHVlKFkpLCBjdCA9IFtdO1xyXG4gICAgICBpZiAociAmJiBjdC5wdXNoKEhbeF0gPD0gMCksIGEgJiYgY3QucHVzaChIW1ldIDw9IDAsIEhbWnRdIDw9IDApLCBjdC5ldmVyeShmdW5jdGlvbih3dCkge1xyXG4gICAgICAgIHJldHVybiB3dDtcclxuICAgICAgfSkpIHtcclxuICAgICAgICB5ID0gUywgQyA9ICExO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHcuc2V0KFMsIGN0KTtcclxuICAgIH1cclxuICAgIGlmIChDKVxyXG4gICAgICBmb3IgKHZhciBKdCA9IE8gPyAzIDogMSwgQWUgPSBmdW5jdGlvbihldCkge1xyXG4gICAgICAgIHZhciBWdCA9IHAuZmluZChmdW5jdGlvbihlZSkge1xyXG4gICAgICAgICAgdmFyIGR0ID0gdy5nZXQoZWUpO1xyXG4gICAgICAgICAgaWYgKGR0KVxyXG4gICAgICAgICAgICByZXR1cm4gZHQuc2xpY2UoMCwgZXQpLmV2ZXJ5KGZ1bmN0aW9uKENlKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIENlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoVnQpXHJcbiAgICAgICAgICByZXR1cm4geSA9IFZ0LCBcImJyZWFrXCI7XHJcbiAgICAgIH0sIEh0ID0gSnQ7IEh0ID4gMDsgSHQtLSkge1xyXG4gICAgICAgIHZhciB0ZSA9IEFlKEh0KTtcclxuICAgICAgICBpZiAodGUgPT09IFwiYnJlYWtcIilcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB0LnBsYWNlbWVudCAhPT0geSAmJiAodC5tb2RpZmllcnNEYXRhW3NdLl9za2lwID0gITAsIHQucGxhY2VtZW50ID0geSwgdC5yZXNldCA9ICEwKTtcclxuICB9XHJcbn1cclxuY29uc3QgZ24gPSB7XHJcbiAgbmFtZTogXCJmbGlwXCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwibWFpblwiLFxyXG4gIGZuOiBTcixcclxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl0sXHJcbiAgZGF0YToge1xyXG4gICAgX3NraXA6ICExXHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBCaShpLCB0LCBlKSB7XHJcbiAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHtcclxuICAgIHg6IDAsXHJcbiAgICB5OiAwXHJcbiAgfSksIHtcclxuICAgIHRvcDogaS50b3AgLSB0LmhlaWdodCAtIGUueSxcclxuICAgIHJpZ2h0OiBpLnJpZ2h0IC0gdC53aWR0aCArIGUueCxcclxuICAgIGJvdHRvbTogaS5ib3R0b20gLSB0LmhlaWdodCArIGUueSxcclxuICAgIGxlZnQ6IGkubGVmdCAtIHQud2lkdGggLSBlLnhcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGppKGkpIHtcclxuICByZXR1cm4gW2ssIEIsIFcsIFBdLnNvbWUoZnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIGlbdF0gPj0gMDtcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBMcihpKSB7XHJcbiAgdmFyIHQgPSBpLnN0YXRlLCBlID0gaS5uYW1lLCBzID0gdC5yZWN0cy5yZWZlcmVuY2UsIG4gPSB0LnJlY3RzLnBvcHBlciwgciA9IHQubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csIG8gPSB4dCh0LCB7XHJcbiAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxyXG4gIH0pLCBhID0geHQodCwge1xyXG4gICAgYWx0Qm91bmRhcnk6ICEwXHJcbiAgfSksIGwgPSBCaShvLCBzKSwgdSA9IEJpKGEsIG4sIHIpLCBjID0gamkobCksIGYgPSBqaSh1KTtcclxuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSB7XHJcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IGwsXHJcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiB1LFxyXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGMsXHJcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBmXHJcbiAgfSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcclxuICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiBjLFxyXG4gICAgXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6IGZcclxuICB9KTtcclxufVxyXG5jb25zdCBtbiA9IHtcclxuICBuYW1lOiBcImhpZGVcIixcclxuICBlbmFibGVkOiAhMCxcclxuICBwaGFzZTogXCJtYWluXCIsXHJcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdLFxyXG4gIGZuOiBMclxyXG59O1xyXG5mdW5jdGlvbiAkcihpLCB0LCBlKSB7XHJcbiAgdmFyIHMgPSBHKGkpLCBuID0gW1AsIGtdLmluZGV4T2YocykgPj0gMCA/IC0xIDogMSwgciA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUoT2JqZWN0LmFzc2lnbih7fSwgdCwge1xyXG4gICAgcGxhY2VtZW50OiBpXHJcbiAgfSkpIDogZSwgbyA9IHJbMF0sIGEgPSByWzFdO1xyXG4gIHJldHVybiBvID0gbyB8fCAwLCBhID0gKGEgfHwgMCkgKiBuLCBbUCwgQl0uaW5kZXhPZihzKSA+PSAwID8ge1xyXG4gICAgeDogYSxcclxuICAgIHk6IG9cclxuICB9IDoge1xyXG4gICAgeDogbyxcclxuICAgIHk6IGFcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIElyKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm9wdGlvbnMsIHMgPSBpLm5hbWUsIG4gPSBlLm9mZnNldCwgciA9IG4gPT09IHZvaWQgMCA/IFswLCAwXSA6IG4sIG8gPSB1aS5yZWR1Y2UoZnVuY3Rpb24oYywgZikge1xyXG4gICAgcmV0dXJuIGNbZl0gPSAkcihmLCB0LnJlY3RzLCByKSwgYztcclxuICB9LCB7fSksIGEgPSBvW3QucGxhY2VtZW50XSwgbCA9IGEueCwgdSA9IGEueTtcclxuICB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsICYmICh0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IGwsIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0gdSksIHQubW9kaWZpZXJzRGF0YVtzXSA9IG87XHJcbn1cclxuY29uc3QgRW4gPSB7XHJcbiAgbmFtZTogXCJvZmZzZXRcIixcclxuICBlbmFibGVkOiAhMCxcclxuICBwaGFzZTogXCJtYWluXCIsXHJcbiAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXHJcbiAgZm46IElyXHJcbn07XHJcbmZ1bmN0aW9uIFJyKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm5hbWU7XHJcbiAgdC5tb2RpZmllcnNEYXRhW2VdID0gX24oe1xyXG4gICAgcmVmZXJlbmNlOiB0LnJlY3RzLnJlZmVyZW5jZSxcclxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxyXG4gICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcclxuICAgIHBsYWNlbWVudDogdC5wbGFjZW1lbnRcclxuICB9KTtcclxufVxyXG5jb25zdCB3aSA9IHtcclxuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcclxuICBlbmFibGVkOiAhMCxcclxuICBwaGFzZTogXCJyZWFkXCIsXHJcbiAgZm46IFJyLFxyXG4gIGRhdGE6IHt9XHJcbn07XHJcbmZ1bmN0aW9uIHhyKGkpIHtcclxuICByZXR1cm4gaSA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xyXG59XHJcbmZ1bmN0aW9uIGtyKGkpIHtcclxuICB2YXIgdCA9IGkuc3RhdGUsIGUgPSBpLm9wdGlvbnMsIHMgPSBpLm5hbWUsIG4gPSBlLm1haW5BeGlzLCByID0gbiA9PT0gdm9pZCAwID8gITAgOiBuLCBvID0gZS5hbHRBeGlzLCBhID0gbyA9PT0gdm9pZCAwID8gITEgOiBvLCBsID0gZS5ib3VuZGFyeSwgdSA9IGUucm9vdEJvdW5kYXJ5LCBjID0gZS5hbHRCb3VuZGFyeSwgZiA9IGUucGFkZGluZywgdiA9IGUudGV0aGVyLCBnID0gdiA9PT0gdm9pZCAwID8gITAgOiB2LCBPID0gZS50ZXRoZXJPZmZzZXQsIFQgPSBPID09PSB2b2lkIDAgPyAwIDogTywgQSA9IHh0KHQsIHtcclxuICAgIGJvdW5kYXJ5OiBsLFxyXG4gICAgcm9vdEJvdW5kYXJ5OiB1LFxyXG4gICAgcGFkZGluZzogZixcclxuICAgIGFsdEJvdW5kYXJ5OiBjXHJcbiAgfSksIEQgPSBHKHQucGxhY2VtZW50KSwgTCA9IFJ0KHQucGxhY2VtZW50KSwgbSA9ICFMLCBwID0gX2koRCksIF8gPSB4cihwKSwgYiA9IHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLCB3ID0gdC5yZWN0cy5yZWZlcmVuY2UsIEMgPSB0LnJlY3RzLnBvcHBlciwgeSA9IHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIiA/IFQoT2JqZWN0LmFzc2lnbih7fSwgdC5yZWN0cywge1xyXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxyXG4gIH0pKSA6IFQsIE4gPSB0eXBlb2YgeSA9PSBcIm51bWJlclwiID8ge1xyXG4gICAgbWFpbkF4aXM6IHksXHJcbiAgICBhbHRBeGlzOiB5XHJcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgbWFpbkF4aXM6IDAsXHJcbiAgICBhbHRBeGlzOiAwXHJcbiAgfSwgeSksIFMgPSB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gdC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF0gOiBudWxsLCB4ID0ge1xyXG4gICAgeDogMCxcclxuICAgIHk6IDBcclxuICB9O1xyXG4gIGlmIChiKSB7XHJcbiAgICBpZiAocikge1xyXG4gICAgICB2YXIgSSwgYXQgPSBwID09PSBcInlcIiA/IGsgOiBQLCBsdCA9IHAgPT09IFwieVwiID8gVyA6IEIsIEggPSBwID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsIFkgPSBiW3BdLCBadCA9IFkgKyBBW2F0XSwgY3QgPSBZIC0gQVtsdF0sIEp0ID0gZyA/IC1DW0hdIC8gMiA6IDAsIEFlID0gTCA9PT0gRXQgPyB3W0hdIDogQ1tIXSwgSHQgPSBMID09PSBFdCA/IC1DW0hdIDogLXdbSF0sIHRlID0gdC5lbGVtZW50cy5hcnJvdywgd3QgPSBnICYmIHRlID8gcGkodGUpIDoge1xyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIGhlaWdodDogMFxyXG4gICAgICB9LCBldCA9IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0gPyB0Lm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmcgOiBkbigpLCBWdCA9IGV0W2F0XSwgZWUgPSBldFtsdF0sIGR0ID0genQoMCwgd1tIXSwgd3RbSF0pLCBDZSA9IG0gPyB3W0hdIC8gMiAtIEp0IC0gZHQgLSBWdCAtIE4ubWFpbkF4aXMgOiBBZSAtIGR0IC0gVnQgLSBOLm1haW5BeGlzLCBWbiA9IG0gPyAtd1tIXSAvIDIgKyBKdCArIGR0ICsgZWUgKyBOLm1haW5BeGlzIDogSHQgKyBkdCArIGVlICsgTi5tYWluQXhpcywgT2UgPSB0LmVsZW1lbnRzLmFycm93ICYmIEd0KHQuZWxlbWVudHMuYXJyb3cpLCBXbiA9IE9lID8gcCA9PT0gXCJ5XCIgPyBPZS5jbGllbnRUb3AgfHwgMCA6IE9lLmNsaWVudExlZnQgfHwgMCA6IDAsIE9pID0gKEkgPSBTID09IG51bGwgPyB2b2lkIDAgOiBTW3BdKSAhPSBudWxsID8gSSA6IDAsIEJuID0gWSArIENlIC0gT2kgLSBXbiwgam4gPSBZICsgVm4gLSBPaSwgRGkgPSB6dChnID8gRWUoWnQsIEJuKSA6IFp0LCBZLCBnID8gbXQoY3QsIGpuKSA6IGN0KTtcclxuICAgICAgYltwXSA9IERpLCB4W3BdID0gRGkgLSBZO1xyXG4gICAgfVxyXG4gICAgaWYgKGEpIHtcclxuICAgICAgdmFyIE5pLCBVbiA9IHAgPT09IFwieFwiID8gayA6IFAsIEZuID0gcCA9PT0gXCJ4XCIgPyBXIDogQiwgdXQgPSBiW19dLCBpZSA9IF8gPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgU2kgPSB1dCArIEFbVW5dLCBMaSA9IHV0IC0gQVtGbl0sIERlID0gW2ssIFBdLmluZGV4T2YoRCkgIT09IC0xLCAkaSA9IChOaSA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbX10pICE9IG51bGwgPyBOaSA6IDAsIElpID0gRGUgPyBTaSA6IHV0IC0gd1tpZV0gLSBDW2llXSAtICRpICsgTi5hbHRBeGlzLCBSaSA9IERlID8gdXQgKyB3W2llXSArIENbaWVdIC0gJGkgLSBOLmFsdEF4aXMgOiBMaSwgeGkgPSBnICYmIERlID8gaHIoSWksIHV0LCBSaSkgOiB6dChnID8gSWkgOiBTaSwgdXQsIGcgPyBSaSA6IExpKTtcclxuICAgICAgYltfXSA9IHhpLCB4W19dID0geGkgLSB1dDtcclxuICAgIH1cclxuICAgIHQubW9kaWZpZXJzRGF0YVtzXSA9IHg7XHJcbiAgfVxyXG59XHJcbmNvbnN0IHZuID0ge1xyXG4gIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXHJcbiAgZW5hYmxlZDogITAsXHJcbiAgcGhhc2U6IFwibWFpblwiLFxyXG4gIGZuOiBrcixcclxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJvZmZzZXRcIl1cclxufTtcclxuZnVuY3Rpb24gUHIoaSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzY3JvbGxMZWZ0OiBpLnNjcm9sbExlZnQsXHJcbiAgICBzY3JvbGxUb3A6IGkuc2Nyb2xsVG9wXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBNcihpKSB7XHJcbiAgcmV0dXJuIGkgPT09IGooaSkgfHwgIUYoaSkgPyBFaShpKSA6IFByKGkpO1xyXG59XHJcbmZ1bmN0aW9uIEhyKGkpIHtcclxuICB2YXIgdCA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGUgPSAkdCh0LndpZHRoKSAvIGkub2Zmc2V0V2lkdGggfHwgMSwgcyA9ICR0KHQuaGVpZ2h0KSAvIGkub2Zmc2V0SGVpZ2h0IHx8IDE7XHJcbiAgcmV0dXJuIGUgIT09IDEgfHwgcyAhPT0gMTtcclxufVxyXG5mdW5jdGlvbiBWcihpLCB0LCBlKSB7XHJcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gITEpO1xyXG4gIHZhciBzID0gRih0KSwgbiA9IEYodCkgJiYgSHIodCksIHIgPSBvdCh0KSwgbyA9IEl0KGksIG4sIGUpLCBhID0ge1xyXG4gICAgc2Nyb2xsTGVmdDogMCxcclxuICAgIHNjcm9sbFRvcDogMFxyXG4gIH0sIGwgPSB7XHJcbiAgICB4OiAwLFxyXG4gICAgeTogMFxyXG4gIH07XHJcbiAgcmV0dXJuIChzIHx8ICFzICYmICFlKSAmJiAoKFEodCkgIT09IFwiYm9keVwiIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxyXG4gIGJpKHIpKSAmJiAoYSA9IE1yKHQpKSwgRih0KSA/IChsID0gSXQodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogciAmJiAobC54ID0gdmkocikpKSwge1xyXG4gICAgeDogby5sZWZ0ICsgYS5zY3JvbGxMZWZ0IC0gbC54LFxyXG4gICAgeTogby50b3AgKyBhLnNjcm9sbFRvcCAtIGwueSxcclxuICAgIHdpZHRoOiBvLndpZHRoLFxyXG4gICAgaGVpZ2h0OiBvLmhlaWdodFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gV3IoaSkge1xyXG4gIHZhciB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHMgPSBbXTtcclxuICBpLmZvckVhY2goZnVuY3Rpb24ocikge1xyXG4gICAgdC5zZXQoci5uYW1lLCByKTtcclxuICB9KTtcclxuICBmdW5jdGlvbiBuKHIpIHtcclxuICAgIGUuYWRkKHIubmFtZSk7XHJcbiAgICB2YXIgbyA9IFtdLmNvbmNhdChyLnJlcXVpcmVzIHx8IFtdLCByLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xyXG4gICAgby5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgaWYgKCFlLmhhcyhhKSkge1xyXG4gICAgICAgIHZhciBsID0gdC5nZXQoYSk7XHJcbiAgICAgICAgbCAmJiBuKGwpO1xyXG4gICAgICB9XHJcbiAgICB9KSwgcy5wdXNoKHIpO1xyXG4gIH1cclxuICByZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcclxuICAgIGUuaGFzKHIubmFtZSkgfHwgbihyKTtcclxuICB9KSwgcztcclxufVxyXG5mdW5jdGlvbiBCcihpKSB7XHJcbiAgdmFyIHQgPSBXcihpKTtcclxuICByZXR1cm4gYW4ucmVkdWNlKGZ1bmN0aW9uKGUsIHMpIHtcclxuICAgIHJldHVybiBlLmNvbmNhdCh0LmZpbHRlcihmdW5jdGlvbihuKSB7XHJcbiAgICAgIHJldHVybiBuLnBoYXNlID09PSBzO1xyXG4gICAgfSkpO1xyXG4gIH0sIFtdKTtcclxufVxyXG5mdW5jdGlvbiBqcihpKSB7XHJcbiAgdmFyIHQ7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHQgfHwgKHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihlKSB7XHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdCA9IHZvaWQgMCwgZShpKCkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pKSwgdDtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIFVyKGkpIHtcclxuICB2YXIgdCA9IGkucmVkdWNlKGZ1bmN0aW9uKGUsIHMpIHtcclxuICAgIHZhciBuID0gZVtzLm5hbWVdO1xyXG4gICAgcmV0dXJuIGVbcy5uYW1lXSA9IG4gPyBPYmplY3QuYXNzaWduKHt9LCBuLCBzLCB7XHJcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG4ub3B0aW9ucywgcy5vcHRpb25zKSxcclxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbi5kYXRhLCBzLmRhdGEpXHJcbiAgICB9KSA6IHMsIGU7XHJcbiAgfSwge30pO1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyh0KS5tYXAoZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIHRbZV07XHJcbiAgfSk7XHJcbn1cclxudmFyIFVpID0ge1xyXG4gIHBsYWNlbWVudDogXCJib3R0b21cIixcclxuICBtb2RpZmllcnM6IFtdLFxyXG4gIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcclxufTtcclxuZnVuY3Rpb24gRmkoKSB7XHJcbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoaSksIGUgPSAwOyBlIDwgaTsgZSsrKVxyXG4gICAgdFtlXSA9IGFyZ3VtZW50c1tlXTtcclxuICByZXR1cm4gIXQuc29tZShmdW5jdGlvbihzKSB7XHJcbiAgICByZXR1cm4gIShzICYmIHR5cGVvZiBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PSBcImZ1bmN0aW9uXCIpO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHdlKGkpIHtcclxuICBpID09PSB2b2lkIDAgJiYgKGkgPSB7fSk7XHJcbiAgdmFyIHQgPSBpLCBlID0gdC5kZWZhdWx0TW9kaWZpZXJzLCBzID0gZSA9PT0gdm9pZCAwID8gW10gOiBlLCBuID0gdC5kZWZhdWx0T3B0aW9ucywgciA9IG4gPT09IHZvaWQgMCA/IFVpIDogbjtcclxuICByZXR1cm4gZnVuY3Rpb24oYSwgbCwgdSkge1xyXG4gICAgdSA9PT0gdm9pZCAwICYmICh1ID0gcik7XHJcbiAgICB2YXIgYyA9IHtcclxuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxyXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcclxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgVWksIHIpLFxyXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcclxuICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICByZWZlcmVuY2U6IGEsXHJcbiAgICAgICAgcG9wcGVyOiBsXHJcbiAgICAgIH0sXHJcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9LCBmID0gW10sIHYgPSAhMSwgZyA9IHtcclxuICAgICAgc3RhdGU6IGMsXHJcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKEQpIHtcclxuICAgICAgICB2YXIgTCA9IHR5cGVvZiBEID09IFwiZnVuY3Rpb25cIiA/IEQoYy5vcHRpb25zKSA6IEQ7XHJcbiAgICAgICAgVCgpLCBjLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCByLCBjLm9wdGlvbnMsIEwpLCBjLnNjcm9sbFBhcmVudHMgPSB7XHJcbiAgICAgICAgICByZWZlcmVuY2U6IHZ0KGEpID8gcXQoYSkgOiBhLmNvbnRleHRFbGVtZW50ID8gcXQoYS5jb250ZXh0RWxlbWVudCkgOiBbXSxcclxuICAgICAgICAgIHBvcHBlcjogcXQobClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtID0gQnIoVXIoW10uY29uY2F0KHMsIGMub3B0aW9ucy5tb2RpZmllcnMpKSk7XHJcbiAgICAgICAgcmV0dXJuIGMub3JkZXJlZE1vZGlmaWVycyA9IG0uZmlsdGVyKGZ1bmN0aW9uKHApIHtcclxuICAgICAgICAgIHJldHVybiBwLmVuYWJsZWQ7XHJcbiAgICAgICAgfSksIE8oKSwgZy51cGRhdGUoKTtcclxuICAgICAgfSxcclxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcclxuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxyXG4gICAgICAvLyBsb2dpYy5cclxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xyXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXHJcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgIHZhciBEID0gYy5lbGVtZW50cywgTCA9IEQucmVmZXJlbmNlLCBtID0gRC5wb3BwZXI7XHJcbiAgICAgICAgICBpZiAoRmkoTCwgbSkpIHtcclxuICAgICAgICAgICAgYy5yZWN0cyA9IHtcclxuICAgICAgICAgICAgICByZWZlcmVuY2U6IFZyKEwsIEd0KG0pLCBjLm9wdGlvbnMuc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksXHJcbiAgICAgICAgICAgICAgcG9wcGVyOiBwaShtKVxyXG4gICAgICAgICAgICB9LCBjLnJlc2V0ID0gITEsIGMucGxhY2VtZW50ID0gYy5vcHRpb25zLnBsYWNlbWVudCwgYy5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oTikge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjLm1vZGlmaWVyc0RhdGFbTi5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIE4uZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IGMub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgIGlmIChjLnJlc2V0ID09PSAhMCkge1xyXG4gICAgICAgICAgICAgICAgYy5yZXNldCA9ICExLCBwID0gLTE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdmFyIF8gPSBjLm9yZGVyZWRNb2RpZmllcnNbcF0sIGIgPSBfLmZuLCB3ID0gXy5vcHRpb25zLCBDID0gdyA9PT0gdm9pZCAwID8ge30gOiB3LCB5ID0gXy5uYW1lO1xyXG4gICAgICAgICAgICAgIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiAmJiAoYyA9IGIoe1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6IGMsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBDLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogeSxcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBnXHJcbiAgICAgICAgICAgICAgfSkgfHwgYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxyXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcclxuICAgICAgdXBkYXRlOiBqcihmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oQSkge1xyXG4gICAgICAgICAgZy5mb3JjZVVwZGF0ZSgpLCBBKGMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSxcclxuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgVCgpLCB2ID0gITA7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoIUZpKGEsIGwpKVxyXG4gICAgICByZXR1cm4gZztcclxuICAgIGcuc2V0T3B0aW9ucyh1KS50aGVuKGZ1bmN0aW9uKEEpIHtcclxuICAgICAgIXYgJiYgdS5vbkZpcnN0VXBkYXRlICYmIHUub25GaXJzdFVwZGF0ZShBKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gTygpIHtcclxuICAgICAgYy5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oQSkge1xyXG4gICAgICAgIHZhciBEID0gQS5uYW1lLCBMID0gQS5vcHRpb25zLCBtID0gTCA9PT0gdm9pZCAwID8ge30gOiBMLCBwID0gQS5lZmZlY3Q7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgdmFyIF8gPSBwKHtcclxuICAgICAgICAgICAgc3RhdGU6IGMsXHJcbiAgICAgICAgICAgIG5hbWU6IEQsXHJcbiAgICAgICAgICAgIGluc3RhbmNlOiBnLFxyXG4gICAgICAgICAgICBvcHRpb25zOiBtXHJcbiAgICAgICAgICB9KSwgYiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGYucHVzaChfIHx8IGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBUKCkge1xyXG4gICAgICBmLmZvckVhY2goZnVuY3Rpb24oQSkge1xyXG4gICAgICAgIHJldHVybiBBKCk7XHJcbiAgICAgIH0pLCBmID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZztcclxuICB9O1xyXG59XHJcbnZhciBGciA9IC8qIEBfX1BVUkVfXyAqLyB3ZSgpLCBZciA9IFttaSwgd2ksIGdpLCBmaV0sIEtyID0gLyogQF9fUFVSRV9fICovIHdlKHtcclxuICBkZWZhdWx0TW9kaWZpZXJzOiBZclxyXG59KSwgenIgPSBbbWksIHdpLCBnaSwgZmksIEVuLCBnbiwgdm4sIGZuLCBtbl0sIFRpID0gLyogQF9fUFVSRV9fICovIHdlKHtcclxuICBkZWZhdWx0TW9kaWZpZXJzOiB6clxyXG59KTtcclxuY29uc3QgYm4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcclxuICBfX3Byb3RvX186IG51bGwsXHJcbiAgYWZ0ZXJNYWluOiBzbixcclxuICBhZnRlclJlYWQ6IEpzLFxyXG4gIGFmdGVyV3JpdGU6IG9uLFxyXG4gIGFwcGx5U3R5bGVzOiBmaSxcclxuICBhcnJvdzogZm4sXHJcbiAgYXV0bzogdmUsXHJcbiAgYmFzZVBsYWNlbWVudHM6IFB0LFxyXG4gIGJlZm9yZU1haW46IHRuLFxyXG4gIGJlZm9yZVJlYWQ6IFFzLFxyXG4gIGJlZm9yZVdyaXRlOiBubixcclxuICBib3R0b206IFcsXHJcbiAgY2xpcHBpbmdQYXJlbnRzOiBYcyxcclxuICBjb21wdXRlU3R5bGVzOiBnaSxcclxuICBjcmVhdGVQb3BwZXI6IFRpLFxyXG4gIGNyZWF0ZVBvcHBlckJhc2U6IEZyLFxyXG4gIGNyZWF0ZVBvcHBlckxpdGU6IEtyLFxyXG4gIGRldGVjdE92ZXJmbG93OiB4dCxcclxuICBlbmQ6IEx0LFxyXG4gIGV2ZW50TGlzdGVuZXJzOiBtaSxcclxuICBmbGlwOiBnbixcclxuICBoaWRlOiBtbixcclxuICBsZWZ0OiBQLFxyXG4gIG1haW46IGVuLFxyXG4gIG1vZGlmaWVyUGhhc2VzOiBhbixcclxuICBvZmZzZXQ6IEVuLFxyXG4gIHBsYWNlbWVudHM6IHVpLFxyXG4gIHBvcHBlcjogQ3QsXHJcbiAgcG9wcGVyR2VuZXJhdG9yOiB3ZSxcclxuICBwb3BwZXJPZmZzZXRzOiB3aSxcclxuICBwcmV2ZW50T3ZlcmZsb3c6IHZuLFxyXG4gIHJlYWQ6IFpzLFxyXG4gIHJlZmVyZW5jZTogR3MsXHJcbiAgcmlnaHQ6IEIsXHJcbiAgc3RhcnQ6IEV0LFxyXG4gIHRvcDogayxcclxuICB2YXJpYXRpb25QbGFjZW1lbnRzOiBlaSxcclxuICB2aWV3cG9ydDogZGksXHJcbiAgd3JpdGU6IHJuXHJcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XHJcbmZ1bmN0aW9uIEllKGkpIHtcclxuICByZXR1cm4gaSA9PT0gXCJ0cnVlXCIgPyAhMCA6IGkgPT09IFwiZmFsc2VcIiA/ICExIDogaSA9PT0gTnVtYmVyKGkpLnRvU3RyaW5nKCkgPyBOdW1iZXIoaSkgOiBpID09PSBcIlwiIHx8IGkgPT09IFwibnVsbFwiID8gbnVsbCA6IGk7XHJcbn1cclxuZnVuY3Rpb24gUmUoaSkge1xyXG4gIHJldHVybiBpLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xyXG59XHJcbmNvbnN0IEUgPSB7XHJcbiAgc2V0RGF0YUF0dHJpYnV0ZShpLCB0LCBlKSB7XHJcbiAgICBpLnNldEF0dHJpYnV0ZShgZGF0YS10d2UtJHtSZSh0KX1gLCBlKTtcclxuICB9LFxyXG4gIHJlbW92ZURhdGFBdHRyaWJ1dGUoaSwgdCkge1xyXG4gICAgaS5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdHdlLSR7UmUodCl9YCk7XHJcbiAgfSxcclxuICBnZXREYXRhQXR0cmlidXRlcyhpKSB7XHJcbiAgICBpZiAoIWkpXHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIGNvbnN0IHQgPSB7fTtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhpLmRhdGFzZXQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidHdlXCIpKS5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgIGlmIChlLnN0YXJ0c1dpdGgoXCJ0d2VDbGFzc1wiKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGxldCBzID0gZS5yZXBsYWNlKC9edHdlLywgXCJcIik7XHJcbiAgICAgIHMgPSBzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcy5zbGljZSgxLCBzLmxlbmd0aCksIHRbc10gPSBJZShpLmRhdGFzZXRbZV0pO1xyXG4gICAgfSksIHQ7XHJcbiAgfSxcclxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKGkpIHtcclxuICAgIGlmICghaSlcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgY29uc3QgdCA9IHtcclxuICAgICAgLi4uaS5kYXRhc2V0XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidHdlQ2xhc3NcIikpLmZvckVhY2goKGUpID0+IHtcclxuICAgICAgbGV0IHMgPSBlLnJlcGxhY2UoL150d2VDbGFzcy8sIFwiXCIpO1xyXG4gICAgICBzID0gcy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHMuc2xpY2UoMSwgcy5sZW5ndGgpLCB0W3NdID0gSWUodFtlXSk7XHJcbiAgICB9KSwgdDtcclxuICB9LFxyXG4gIGdldERhdGFBdHRyaWJ1dGUoaSwgdCkge1xyXG4gICAgcmV0dXJuIEllKFxyXG4gICAgICBpLmdldEF0dHJpYnV0ZShgZGF0YS10d2UtJHtSZSh0KX1gKVxyXG4gICAgKTtcclxuICB9LFxyXG4gIG9mZnNldChpKSB7XHJcbiAgICBjb25zdCB0ID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcclxuICAgICAgbGVmdDogdC5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgcG9zaXRpb24oaSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiBpLm9mZnNldFRvcCxcclxuICAgICAgbGVmdDogaS5vZmZzZXRMZWZ0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgc3R5bGUoaSwgdCkge1xyXG4gICAgT2JqZWN0LmFzc2lnbihpLnN0eWxlLCB0KTtcclxuICB9LFxyXG4gIHRvZ2dsZUNsYXNzKGksIHQpIHtcclxuICAgIGkgJiYgeGUodCkuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICBpLmNsYXNzTGlzdC5jb250YWlucyhlKSA/IGkuY2xhc3NMaXN0LnJlbW92ZShlKSA6IGkuY2xhc3NMaXN0LmFkZChlKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYWRkQ2xhc3MoaSwgdCkge1xyXG4gICAgeGUodCkuZm9yRWFjaChcclxuICAgICAgKGUpID0+ICFpLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBpLmNsYXNzTGlzdC5hZGQoZSlcclxuICAgICk7XHJcbiAgfSxcclxuICBhZGRTdHlsZShpLCB0KSB7XHJcbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgIGkuc3R5bGVbZV0gPSB0W2VdO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICByZW1vdmVDbGFzcyhpLCB0KSB7XHJcbiAgICB4ZSh0KS5mb3JFYWNoKFxyXG4gICAgICAoZSkgPT4gaS5jbGFzc0xpc3QuY29udGFpbnMoZSkgJiYgaS5jbGFzc0xpc3QucmVtb3ZlKGUpXHJcbiAgICApO1xyXG4gIH0sXHJcbiAgaGFzQ2xhc3MoaSwgdCkge1xyXG4gICAgcmV0dXJuIGkuY2xhc3NMaXN0LmNvbnRhaW5zKHQpO1xyXG4gIH0sXHJcbiAgbWF4T2Zmc2V0KGkpIHtcclxuICAgIGNvbnN0IHQgPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiB0LnRvcCArIE1hdGgubWF4KFxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXHJcbiAgICAgICAgd2luZG93LnNjcm9sbFlcclxuICAgICAgKSxcclxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxyXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxyXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXHJcbiAgICAgIClcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiB4ZShpKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBpLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkoaSkgPyBpIDogITE7XHJcbn1cclxuY29uc3QgcXIgPSAzLCBoID0ge1xyXG4gIGNsb3Nlc3QoaSwgdCkge1xyXG4gICAgcmV0dXJuIGkuY2xvc2VzdCh0KTtcclxuICB9LFxyXG4gIG1hdGNoZXMoaSwgdCkge1xyXG4gICAgcmV0dXJuIGkubWF0Y2hlcyh0KTtcclxuICB9LFxyXG4gIGZpbmQoaSwgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgcmV0dXJuIFtdLmNvbmNhdChcclxuICAgICAgLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKHQsIGkpXHJcbiAgICApO1xyXG4gIH0sXHJcbiAgZmluZE9uZShpLCB0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIGkpO1xyXG4gIH0sXHJcbiAgY2hpbGRyZW4oaSwgdCkge1xyXG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5pLmNoaWxkcmVuKS5maWx0ZXIoKHMpID0+IHMubWF0Y2hlcyh0KSk7XHJcbiAgfSxcclxuICBwYXJlbnRzKGksIHQpIHtcclxuICAgIGNvbnN0IGUgPSBbXTtcclxuICAgIGxldCBzID0gaS5wYXJlbnROb2RlO1xyXG4gICAgZm9yICg7IHMgJiYgcy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgcy5ub2RlVHlwZSAhPT0gcXI7IClcclxuICAgICAgdGhpcy5tYXRjaGVzKHMsIHQpICYmIGUucHVzaChzKSwgcyA9IHMucGFyZW50Tm9kZTtcclxuICAgIHJldHVybiBlO1xyXG4gIH0sXHJcbiAgcHJldihpLCB0KSB7XHJcbiAgICBsZXQgZSA9IGkucHJldmlvdXNFbGVtZW50U2libGluZztcclxuICAgIGZvciAoOyBlOyApIHtcclxuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcclxuICAgICAgICByZXR1cm4gW2VdO1xyXG4gICAgICBlID0gZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH0sXHJcbiAgbmV4dChpLCB0KSB7XHJcbiAgICBsZXQgZSA9IGkubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgZm9yICg7IGU7ICkge1xyXG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxyXG4gICAgICAgIHJldHVybiBbZV07XHJcbiAgICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9LFxyXG4gIGZvY3VzYWJsZUNoaWxkcmVuKGkpIHtcclxuICAgIGNvbnN0IHQgPSBbXHJcbiAgICAgIFwiYVwiLFxyXG4gICAgICBcImJ1dHRvblwiLFxyXG4gICAgICBcImlucHV0XCIsXHJcbiAgICAgIFwidGV4dGFyZWFcIixcclxuICAgICAgXCJzZWxlY3RcIixcclxuICAgICAgXCJkZXRhaWxzXCIsXHJcbiAgICAgIFwiW3RhYmluZGV4XVwiLFxyXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXHJcbiAgICBdLm1hcCgoZSkgPT4gYCR7ZX06bm90KFt0YWJpbmRleF49XCItXCJdKWApLmpvaW4oXCIsIFwiKTtcclxuICAgIHJldHVybiB0aGlzLmZpbmQodCwgaSkuZmlsdGVyKFxyXG4gICAgICAoZSkgPT4gIWd0KGUpICYmIGt0KGUpXHJcbiAgICApO1xyXG4gIH1cclxufSwga2UgPSBcImRyb3Bkb3duXCIsIFhyID0gXCJ0d2UuZHJvcGRvd25cIiwgYnQgPSBgLiR7WHJ9YCwgeWkgPSBcIi5kYXRhLWFwaVwiLCBoZSA9IFwiRXNjYXBlXCIsIFlpID0gXCJTcGFjZVwiLCBLaSA9IFwiVGFiXCIsIG5pID0gXCJBcnJvd1VwXCIsIGZlID0gXCJBcnJvd0Rvd25cIiwgR3IgPSAyLCBRciA9IG5ldyBSZWdFeHAoXHJcbiAgYCR7bml9fCR7ZmV9fCR7aGV9YFxyXG4pLCBaciA9IGBoaWRlJHtidH1gLCBKciA9IGBoaWRkZW4ke2J0fWAsIHRvID0gYHNob3cke2J0fWAsIGVvID0gYHNob3duJHtidH1gLCBpbyA9IGBjbGljayR7YnR9JHt5aX1gLCB6aSA9IGBrZXlkb3duJHtidH0ke3lpfWAsIHNvID0gYGtleXVwJHtidH0ke3lpfWAsIGl0ID0gXCJzaG93XCIsIG5vID0gXCJkcm9wdXBcIiwgcm8gPSBcImRyb3BlbmRcIiwgb28gPSBcImRyb3BzdGFydFwiLCBhbyA9IFwiW2RhdGEtdHdlLW5hdmJhci1yZWZdXCIsIG5lID0gXCJbZGF0YS10d2UtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgUGUgPSBcIltkYXRhLXR3ZS1kcm9wZG93bi1tZW51LXJlZl1cIiwgbG8gPSBcIltkYXRhLXR3ZS1uYXZiYXItbmF2LXJlZl1cIiwgY28gPSBcIltkYXRhLXR3ZS1kcm9wZG93bi1tZW51LXJlZl0gW2RhdGEtdHdlLWRyb3Bkb3duLWl0ZW0tcmVmXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKVwiLCB1byA9IE0oKSA/IFwidG9wLWVuZFwiIDogXCJ0b3Atc3RhcnRcIiwgaG8gPSBNKCkgPyBcInRvcC1zdGFydFwiIDogXCJ0b3AtZW5kXCIsIGZvID0gTSgpID8gXCJib3R0b20tZW5kXCIgOiBcImJvdHRvbS1zdGFydFwiLCBwbyA9IE0oKSA/IFwiYm90dG9tLXN0YXJ0XCIgOiBcImJvdHRvbS1lbmRcIiwgX28gPSBNKCkgPyBcImxlZnQtc3RhcnRcIiA6IFwicmlnaHQtc3RhcnRcIiwgZ28gPSBNKCkgPyBcInJpZ2h0LXN0YXJ0XCIgOiBcImxlZnQtc3RhcnRcIiwgbW8gPSBbeyBvcGFjaXR5OiBcIjBcIiB9LCB7IG9wYWNpdHk6IFwiMVwiIH1dLCBFbyA9IFt7IG9wYWNpdHk6IFwiMVwiIH0sIHsgb3BhY2l0eTogXCIwXCIgfV0sIHFpID0ge1xyXG4gIGl0ZXJhdGlvbnM6IDEsXHJcbiAgZWFzaW5nOiBcImVhc2VcIixcclxuICBmaWxsOiBcImJvdGhcIlxyXG59LCB2byA9IHtcclxuICBvZmZzZXQ6IFswLCAyXSxcclxuICBib3VuZGFyeTogXCJjbGlwcGluZ1BhcmVudHNcIixcclxuICByZWZlcmVuY2U6IFwidG9nZ2xlXCIsXHJcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXHJcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxyXG4gIGF1dG9DbG9zZTogITAsXHJcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIixcclxuICBhbmltYXRpb25EdXJhdGlvbjogNTUwXHJcbn0sIGJvID0ge1xyXG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxyXG4gIGJvdW5kYXJ5OiBcIihzdHJpbmd8ZWxlbWVudClcIixcclxuICByZWZlcmVuY2U6IFwiKHN0cmluZ3xlbGVtZW50fG9iamVjdClcIixcclxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxyXG4gIHBvcHBlckNvbmZpZzogXCIobnVsbHxvYmplY3R8ZnVuY3Rpb24pXCIsXHJcbiAgYXV0b0Nsb3NlOiBcIihib29sZWFufHN0cmluZylcIixcclxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIixcclxuICBhbmltYXRpb25EdXJhdGlvbjogXCJudW1iZXJcIlxyXG59O1xyXG5jbGFzcyBYIGV4dGVuZHMgdHQge1xyXG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcclxuICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpLCB0aGlzLl9mYWRlT3V0QW5pbWF0ZSA9IG51bGw7XHJcbiAgICBjb25zdCBzID0gd2luZG93Lm1hdGNoTWVkaWEoXHJcbiAgICAgIFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIlxyXG4gICAgKS5tYXRjaGVzO1xyXG4gICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA9IHRoaXMuX2NvbmZpZy5kcm9wZG93bkFuaW1hdGlvbiA9PT0gXCJvblwiICYmICFzLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcclxuICB9XHJcbiAgLy8gR2V0dGVyc1xyXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgIHJldHVybiB2bztcclxuICB9XHJcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgIHJldHVybiBibztcclxuICB9XHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIGtlO1xyXG4gIH1cclxuICAvLyBQdWJsaWNcclxuICB0b2dnbGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcclxuICB9XHJcbiAgc2hvdygpIHtcclxuICAgIGlmIChndCh0aGlzLl9lbGVtZW50KSB8fCB0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCB0ID0ge1xyXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XHJcbiAgICB9O1xyXG4gICAgaWYgKGQudHJpZ2dlcihcclxuICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgdG8sXHJcbiAgICAgIHRcclxuICAgICkuZGVmYXVsdFByZXZlbnRlZClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgcyA9IFguZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XHJcbiAgICB0aGlzLl9pbk5hdmJhciA/IEUuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcIm5vbmVcIikgOiB0aGlzLl9jcmVhdGVQb3BwZXIocyksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFzLmNsb3Nlc3QobG8pICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChuKSA9PiBkLm9uKG4sIFwibW91c2VvdmVyXCIsIG1lKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5zZXRBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCwgXCJcIiksIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgJiYgdGhpcy5fbWVudS5hbmltYXRlKG1vLCB7XHJcbiAgICAgIC4uLnFpLFxyXG4gICAgICBkdXJhdGlvbjogdGhpcy5fY29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uXHJcbiAgICB9KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCwgXCJcIiksIHNldFRpbWVvdXQoXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZW8sIHQpO1xyXG4gICAgICB9LFxyXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gdGhpcy5fY29uZmlnLmFuaW1hdGlvbkR1cmF0aW9uIDogMFxyXG4gICAgKTtcclxuICB9XHJcbiAgaGlkZSgpIHtcclxuICAgIGlmIChndCh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IHtcclxuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxyXG4gICAgfTtcclxuICAgIHRoaXMuX2NvbXBsZXRlSGlkZSh0KTtcclxuICB9XHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XHJcbiAgfVxyXG4gIC8vIFByaXZhdGVcclxuICBfaW5pdCgpIHtcclxuICAgIHRoaXMuX2RpZEluaXQgfHwgKGQub24oXHJcbiAgICAgIGRvY3VtZW50LFxyXG4gICAgICB6aSxcclxuICAgICAgbmUsXHJcbiAgICAgIFguZGF0YUFwaUtleWRvd25IYW5kbGVyXHJcbiAgICApLCBkLm9uKFxyXG4gICAgICBkb2N1bWVudCxcclxuICAgICAgemksXHJcbiAgICAgIFBlLFxyXG4gICAgICBYLmRhdGFBcGlLZXlkb3duSGFuZGxlclxyXG4gICAgKSwgZC5vbihkb2N1bWVudCwgaW8sIFguY2xlYXJNZW51cyksIGQub24oZG9jdW1lbnQsIHNvLCBYLmNsZWFyTWVudXMpLCB0aGlzLl9kaWRJbml0ID0gITApO1xyXG4gIH1cclxuICBfY29tcGxldGVIaWRlKHQpIHtcclxuICAgIHRoaXMuX2ZhZGVPdXRBbmltYXRlICYmIHRoaXMuX2ZhZGVPdXRBbmltYXRlLnBsYXlTdGF0ZSA9PT0gXCJydW5uaW5nXCIgfHwgZC50cmlnZ2VyKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBacixcclxuICAgICAgdFxyXG4gICAgKS5kZWZhdWx0UHJldmVudGVkIHx8IChcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgocykgPT4gZC5vZmYocywgXCJtb3VzZW92ZXJcIiwgbWUpKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiAodGhpcy5fZmFkZU91dEFuaW1hdGUgPSB0aGlzLl9tZW51LmFuaW1hdGUoRW8sIHtcclxuICAgICAgLi4ucWksXHJcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb25cclxuICAgIH0pKSwgc2V0VGltZW91dChcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10d2UtZHJvcGRvd24tJHtpdH1gKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdHdlLWRyb3Bkb3duLSR7aXR9YCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpLCBFLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgXCJwb3BwZXJcIiksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKciwgdCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyB0aGlzLl9jb25maWcuYW5pbWF0aW9uRHVyYXRpb24gOiAwXHJcbiAgICApKTtcclxuICB9XHJcbiAgX2dldENvbmZpZyh0KSB7XHJcbiAgICBpZiAodCA9IHtcclxuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCBSKGtlLCB0LCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSwgdHlwZW9mIHQucmVmZXJlbmNlID09IFwib2JqZWN0XCIgJiYgIVN0KHQucmVmZXJlbmNlKSAmJiB0eXBlb2YgdC5yZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9IFwiZnVuY3Rpb25cIilcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICBgJHtrZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gXHJcbiAgICAgICk7XHJcbiAgICByZXR1cm4gdDtcclxuICB9XHJcbiAgX2NyZWF0ZVBvcHBlcih0KSB7XHJcbiAgICBpZiAodHlwZW9mIGJuID4gXCJ1XCIpXHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgXCJCb290c3RyYXAncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxyXG4gICAgICApO1xyXG4gICAgbGV0IGUgPSB0aGlzLl9lbGVtZW50O1xyXG4gICAgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gXCJwYXJlbnRcIiA/IGUgPSB0IDogU3QodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkgPyBlID0gcnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkgOiB0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmIChlID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCksIG4gPSBzLm1vZGlmaWVycy5maW5kKFxyXG4gICAgICAocikgPT4gci5uYW1lID09PSBcImFwcGx5U3R5bGVzXCIgJiYgci5lbmFibGVkID09PSAhMVxyXG4gICAgKTtcclxuICAgIHRoaXMuX3BvcHBlciA9IFRpKFxyXG4gICAgICBlLFxyXG4gICAgICB0aGlzLl9tZW51LFxyXG4gICAgICBzXHJcbiAgICApLCBuICYmIEUuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcclxuICB9XHJcbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcclxuICAgIHJldHVybiB0LmRhdGFzZXRbYHR3ZURyb3Bkb3duJHtpdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGl0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xyXG4gIH1cclxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gaC5uZXh0KHRoaXMuX2VsZW1lbnQsIFBlKVswXTtcclxuICB9XHJcbiAgX2dldFBsYWNlbWVudCgpIHtcclxuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICBpZiAodC5kYXRhc2V0LnR3ZURyb3Bkb3duUG9zaXRpb24gPT09IHJvKVxyXG4gICAgICByZXR1cm4gX287XHJcbiAgICBpZiAodC5kYXRhc2V0LnR3ZURyb3Bkb3duUG9zaXRpb24gPT09IG9vKVxyXG4gICAgICByZXR1cm4gZ287XHJcbiAgICBjb25zdCBlID0gdC5kYXRhc2V0LnR3ZURyb3Bkb3duQWxpZ25tZW50ID09PSBcImVuZFwiO1xyXG4gICAgcmV0dXJuIHQuZGF0YXNldC50d2VEcm9wZG93blBvc2l0aW9uID09PSBubyA/IGUgPyBobyA6IHVvIDogZSA/IHBvIDogZm87XHJcbiAgfVxyXG4gIF9kZXRlY3ROYXZiYXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KGFvKSAhPT0gbnVsbDtcclxuICB9XHJcbiAgX2dldE9mZnNldCgpIHtcclxuICAgIGNvbnN0IHsgb2Zmc2V0OiB0IH0gPSB0aGlzLl9jb25maWc7XHJcbiAgICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IHQuc3BsaXQoXCIsXCIpLm1hcCgoZSkgPT4gTnVtYmVyLnBhcnNlSW50KGUsIDEwKSkgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XHJcbiAgfVxyXG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XHJcbiAgICBjb25zdCB0ID0ge1xyXG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxyXG4gICAgICBtb2RpZmllcnM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSBcInN0YXRpY1wiICYmICh0Lm1vZGlmaWVycyA9IFtcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcclxuICAgICAgICBlbmFibGVkOiAhMVxyXG4gICAgICB9XHJcbiAgICBdKSwge1xyXG4gICAgICAuLi50LFxyXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKHQpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xyXG4gICAgfTtcclxuICB9XHJcbiAgX3NlbGVjdE1lbnVJdGVtKHsga2V5OiB0LCB0YXJnZXQ6IGUgfSkge1xyXG4gICAgY29uc3QgcyA9IGguZmluZChcclxuICAgICAgY28sXHJcbiAgICAgIHRoaXMuX21lbnVcclxuICAgICkuZmlsdGVyKGt0KTtcclxuICAgIHMubGVuZ3RoICYmIEJzKFxyXG4gICAgICBzLFxyXG4gICAgICBlLFxyXG4gICAgICB0ID09PSBmZSxcclxuICAgICAgIXMuaW5jbHVkZXMoZSlcclxuICAgICkuZm9jdXMoKTtcclxuICB9XHJcbiAgLy8gU3RhdGljXHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBlID0gWC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RhdGljIGNsZWFyTWVudXModCkge1xyXG4gICAgaWYgKHQgJiYgKHQuYnV0dG9uID09PSBHciB8fCB0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSAhPT0gS2kpKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBlID0gaC5maW5kKG5lKTtcclxuICAgIGZvciAobGV0IHMgPSAwLCBuID0gZS5sZW5ndGg7IHMgPCBuOyBzKyspIHtcclxuICAgICAgY29uc3QgciA9IFguZ2V0SW5zdGFuY2UoZVtzXSk7XHJcbiAgICAgIGlmICghciB8fCByLl9jb25maWcuYXV0b0Nsb3NlID09PSAhMSB8fCAhci5faXNTaG93bigpKVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICBjb25zdCBvID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHIuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgaWYgKHQpIHtcclxuICAgICAgICBjb25zdCBhID0gdC5jb21wb3NlZFBhdGgoKSwgbCA9IGEuaW5jbHVkZXMoci5fbWVudSk7XHJcbiAgICAgICAgaWYgKGEuaW5jbHVkZXMoci5fZWxlbWVudCkgfHwgci5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJpbnNpZGVcIiAmJiAhbCB8fCByLl9jb25maWcuYXV0b0Nsb3NlID09PSBcIm91dHNpZGVcIiAmJiBsIHx8IHIuX21lbnUuY29udGFpbnModC50YXJnZXQpICYmICh0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSA9PT0gS2kgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpKVxyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdC50eXBlID09PSBcImNsaWNrXCIgJiYgKG8uY2xpY2tFdmVudCA9IHQpO1xyXG4gICAgICB9XHJcbiAgICAgIHIuX2NvbXBsZXRlSGlkZShvKTtcclxuICAgIH1cclxuICB9XHJcbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KHQpIHtcclxuICAgIHJldHVybiBudCh0KSB8fCB0LnBhcmVudE5vZGU7XHJcbiAgfVxyXG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xyXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gWWkgfHwgdC5rZXkgIT09IGhlICYmICh0LmtleSAhPT0gZmUgJiYgdC5rZXkgIT09IG5pIHx8IHQudGFyZ2V0LmNsb3Nlc3QoUGUpKSA6ICFRci50ZXN0KHQua2V5KSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YXNldFtgdHdlRHJvcGRvd24ke2l0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaXQuc2xpY2UoMSl9YF0gPT09IFwiXCI7XHJcbiAgICBpZiAoIWUgJiYgdC5rZXkgPT09IGhlIHx8ICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIGd0KHRoaXMpKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgcyA9IHRoaXMubWF0Y2hlcyhuZSkgPyB0aGlzIDogaC5wcmV2KHRoaXMsIG5lKVswXSwgbiA9IFguZ2V0T3JDcmVhdGVJbnN0YW5jZShzKTtcclxuICAgIGlmICh0LmtleSA9PT0gaGUpIHtcclxuICAgICAgbi5oaWRlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0LmtleSA9PT0gbmkgfHwgdC5rZXkgPT09IGZlKSB7XHJcbiAgICAgIGUgfHwgbi5zaG93KCksIG4uX3NlbGVjdE1lbnVJdGVtKHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAoIWUgfHwgdC5rZXkgPT09IFlpKSAmJiBYLmNsZWFyTWVudXMoKTtcclxuICB9XHJcbn1cclxuY29uc3QgTWUgPSBcImNvbGxhcHNlXCIsIHduID0gXCJ0d2UuY29sbGFwc2VcIiwgVGUgPSBgLiR7d259YCwgWGkgPSB7XHJcbiAgdG9nZ2xlOiAhMCxcclxuICBwYXJlbnQ6IG51bGxcclxufSwgd28gPSB7XHJcbiAgdG9nZ2xlOiBcImJvb2xlYW5cIixcclxuICBwYXJlbnQ6IFwiKG51bGx8ZWxlbWVudClcIlxyXG59LCBUbyA9IGBzaG93JHtUZX1gLCB5byA9IGBzaG93biR7VGV9YCwgQW8gPSBgaGlkZSR7VGV9YCwgQ28gPSBgaGlkZGVuJHtUZX1gLCBIZSA9IFwiZGF0YS10d2UtY29sbGFwc2Utc2hvd1wiLCBHaSA9IFwiZGF0YS10d2UtY29sbGFwc2UtY29sbGFwc2VkXCIsIHJlID0gXCJkYXRhLXR3ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXCIsIE9vID0gXCJkYXRhLXR3ZS1jb2xsYXBzZS1ob3Jpem9udGFsXCIsIE50ID0gXCJkYXRhLXR3ZS1jb2xsYXBzZS1pdGVtXCIsIFFpID0gYDpzY29wZSBbJHtOdH1dIFske050fV1gLCBEbyA9IFwid2lkdGhcIiwgTm8gPSBcImhlaWdodFwiLCBTbyA9IFwiW2RhdGEtdHdlLWNvbGxhcHNlLWl0ZW1dW2RhdGEtdHdlLWNvbGxhcHNlLXNob3ddLCBbZGF0YS10d2UtY29sbGFwc2UtaXRlbV1bZGF0YS10d2UtY29sbGFwc2UtY29sbGFwc2luZ11cIiwgWmkgPSBcIltkYXRhLXR3ZS1jb2xsYXBzZS1pbml0XVwiLCBMbyA9IHtcclxuICB2aXNpYmxlOiBcIiF2aXNpYmxlXCIsXHJcbiAgaGlkZGVuOiBcImhpZGRlblwiLFxyXG4gIGJhc2VUcmFuc2l0aW9uOiBcIm92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXHJcbiAgY29sbGFwc2luZzogXCJoLTAgdHJhbnNpdGlvbi1baGVpZ2h0XSBvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxyXG4gIGNvbGxhcHNpbmdIb3Jpem9udGFsOiBcInctMCBoLWF1dG8gdHJhbnNpdGlvbi1bd2lkdGhdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCJcclxufSwgJG8gPSB7XHJcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcclxuICBoaWRkZW46IFwic3RyaW5nXCIsXHJcbiAgYmFzZVRyYW5zaXRpb246IFwic3RyaW5nXCIsXHJcbiAgY29sbGFwc2luZzogXCJzdHJpbmdcIixcclxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJzdHJpbmdcIlxyXG59O1xyXG5jbGFzcyBwZSBleHRlbmRzIHR0IHtcclxuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XHJcbiAgICBzdXBlcih0KSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMocyksIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xyXG4gICAgY29uc3QgbiA9IGguZmluZChaaSk7XHJcbiAgICBmb3IgKGxldCByID0gMCwgbyA9IG4ubGVuZ3RoOyByIDwgbzsgcisrKSB7XHJcbiAgICAgIGNvbnN0IGEgPSBuW3JdLCBsID0gY2koYSksIHUgPSBoLmZpbmQobCkuZmlsdGVyKFxyXG4gICAgICAgIChjKSA9PiBjID09PSB0aGlzLl9lbGVtZW50XHJcbiAgICAgICk7XHJcbiAgICAgIGwgIT09IG51bGwgJiYgdS5sZW5ndGggJiYgKHRoaXMuX3NlbGVjdG9yID0gbCwgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goYSkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCksIHRoaXMuX2NvbmZpZy5wYXJlbnQgfHwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKSwgdGhpcy5fY29uZmlnLnRvZ2dsZSAmJiB0aGlzLnRvZ2dsZSgpO1xyXG4gIH1cclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgcmV0dXJuIFhpO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICByZXR1cm4gTWU7XHJcbiAgfVxyXG4gIC8vIFB1YmxpY1xyXG4gIHRvZ2dsZSgpIHtcclxuICAgIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XHJcbiAgfVxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgbGV0IHQgPSBbXSwgZTtcclxuICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XHJcbiAgICAgIGNvbnN0IGMgPSBoLmZpbmQoXHJcbiAgICAgICAgUWksXHJcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxyXG4gICAgICApO1xyXG4gICAgICB0ID0gaC5maW5kKFxyXG4gICAgICAgIFNvLFxyXG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcclxuICAgICAgKS5maWx0ZXIoKGYpID0+ICFjLmluY2x1ZGVzKGYpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHMgPSBoLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpO1xyXG4gICAgaWYgKHQubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGMgPSB0LmZpbmQoKGYpID0+IHMgIT09IGYpO1xyXG4gICAgICBpZiAoZSA9IGMgPyBwZS5nZXRJbnN0YW5jZShjKSA6IG51bGwsIGUgJiYgZS5faXNUcmFuc2l0aW9uaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVG8pLmRlZmF1bHRQcmV2ZW50ZWQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIHQuZm9yRWFjaCgoYykgPT4ge1xyXG4gICAgICBzICE9PSBjICYmIHBlLmdldE9yQ3JlYXRlSW5zdGFuY2UoYywgeyB0b2dnbGU6ICExIH0pLmhpZGUoKSwgZSB8fCBWLnNldERhdGEoYywgd24sIG51bGwpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCByID0gdGhpcy5fZ2V0RGltZW5zaW9uKCksIG8gPSByID09PSBcImhlaWdodFwiID8gdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nIDogdGhpcy5fY2xhc3Nlcy5jb2xsYXBzaW5nSG9yaXpvbnRhbDtcclxuICAgIEUucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgbyksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE50KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUocmUsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW3JdID0gMCwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgITApLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcclxuICAgIGNvbnN0IGEgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBFLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBvKSwgRS5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShyZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKE50LCBcIlwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoSGUsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW3JdID0gXCJcIiwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHlvKTtcclxuICAgIH0sIHUgPSBgc2Nyb2xsJHtyWzBdLnRvVXBwZXJDYXNlKCkgKyByLnNsaWNlKDEpfWA7XHJcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGEsIHRoaXMuX2VsZW1lbnQsICEwKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtyXSA9IGAke3RoaXMuX2VsZW1lbnRbdV19cHhgO1xyXG4gIH1cclxuICBoaWRlKCkge1xyXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5faXNTaG93bigpIHx8IGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBbykuZGVmYXVsdFByZXZlbnRlZClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERpbWVuc2lvbigpLCBzID0gZSA9PT0gXCJoZWlnaHRcIiA/IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZyA6IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZ0hvcml6b250YWw7XHJcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2VdID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtlXX1weGAsIFh0KHRoaXMuX2VsZW1lbnQpLCBFLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHMpLCBFLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIEUucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShyZSwgXCJcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE50KSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoSGUpO1xyXG4gICAgY29uc3QgbiA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG47IG8rKykge1xyXG4gICAgICBjb25zdCBhID0gdGhpcy5fdHJpZ2dlckFycmF5W29dLCBsID0gbnQoYSk7XHJcbiAgICAgIGwgJiYgIXRoaXMuX2lzU2hvd24obCkgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFthXSwgITEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITA7XHJcbiAgICBjb25zdCByID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgRS5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBzKSwgRS5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBFLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocmUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShOdCwgXCJcIiksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDbyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IFwiXCIsIHRoaXMuX3F1ZXVlQ2FsbGJhY2sociwgdGhpcy5fZWxlbWVudCwgITApO1xyXG4gIH1cclxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHQuaGFzQXR0cmlidXRlKEhlKTtcclxuICB9XHJcbiAgLy8gUHJpdmF0ZVxyXG4gIF9nZXRDb25maWcodCkge1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLlhpLFxyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCB0LnRvZ2dsZSA9ICEhdC50b2dnbGUsIHQucGFyZW50ID0gcnQodC5wYXJlbnQpLCBSKE1lLCB0LCB3byksIHQ7XHJcbiAgfVxyXG4gIF9nZXRDbGFzc2VzKHQpIHtcclxuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XHJcbiAgICByZXR1cm4gdCA9IHtcclxuICAgICAgLi4uTG8sXHJcbiAgICAgIC4uLmUsXHJcbiAgICAgIC4uLnRcclxuICAgIH0sIFIoTWUsIHQsICRvKSwgdDtcclxuICB9XHJcbiAgX2dldERpbWVuc2lvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShPbykgPyBEbyA6IE5vO1xyXG4gIH1cclxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xyXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCB0ID0gaC5maW5kKFxyXG4gICAgICBRaSxcclxuICAgICAgdGhpcy5fY29uZmlnLnBhcmVudFxyXG4gICAgKTtcclxuICAgIGguZmluZChaaSwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKChlKSA9PiAhdC5pbmNsdWRlcyhlKSkuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICBjb25zdCBzID0gbnQoZSk7XHJcbiAgICAgIHMgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlXSwgdGhpcy5faXNTaG93bihzKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0LCBlKSB7XHJcbiAgICB0Lmxlbmd0aCAmJiB0LmZvckVhY2goKHMpID0+IHtcclxuICAgICAgZSA/IHMucmVtb3ZlQXR0cmlidXRlKEdpKSA6IHMuc2V0QXR0cmlidXRlKGAke0dpfWAsIFwiXCIpLCBzLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLy8gU3RhdGljXHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBlID0ge307XHJcbiAgICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XHJcbiAgICAgIGNvbnN0IHMgPSBwZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGUpO1xyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc1t0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgc1t0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuY29uc3QgSmkgPSBcIi5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3BcIiwgdHMgPSBcIi5zdGlja3ktdG9wXCI7XHJcbmNsYXNzIHJpIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xyXG4gIH1cclxuICBnZXRXaWR0aCgpIHtcclxuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSB0KTtcclxuICB9XHJcbiAgaGlkZSgpIHtcclxuICAgIGNvbnN0IHQgPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXHJcbiAgICAgIChlKSA9PiBlICsgdFxyXG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXHJcbiAgICAgIEppLFxyXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxyXG4gICAgICAoZSkgPT4gZSArIHRcclxuICAgICksIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFxyXG4gICAgICB0cyxcclxuICAgICAgXCJtYXJnaW5SaWdodFwiLFxyXG4gICAgICAoZSkgPT4gZSAtIHRcclxuICAgICk7XHJcbiAgfVxyXG4gIF9kaXNhYmxlT3ZlckZsb3coKSB7XHJcbiAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBcIm92ZXJmbG93XCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICB9XHJcbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHQsIGUsIHMpIHtcclxuICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCksIHIgPSAobykgPT4ge1xyXG4gICAgICBpZiAobyAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IG8uY2xpZW50V2lkdGggKyBuKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUobywgZSk7XHJcbiAgICAgIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvKVtlXTtcclxuICAgICAgby5zdHlsZVtlXSA9IGAke3MoXHJcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYSlcclxuICAgICAgKX1weGA7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCByKTtcclxuICB9XHJcbiAgcmVzZXQoKSB7XHJcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoSmksIFwicGFkZGluZ1JpZ2h0XCIpLCB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRzLCBcIm1hcmdpblJpZ2h0XCIpO1xyXG4gIH1cclxuICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUodCwgZSkge1xyXG4gICAgY29uc3QgcyA9IHQuc3R5bGVbZV07XHJcbiAgICBzICYmIEUuc2V0RGF0YUF0dHJpYnV0ZSh0LCBlLCBzKTtcclxuICB9XHJcbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xyXG4gICAgY29uc3QgcyA9IChuKSA9PiB7XHJcbiAgICAgIGNvbnN0IHIgPSBFLmdldERhdGFBdHRyaWJ1dGUobiwgZSk7XHJcbiAgICAgIHR5cGVvZiByID4gXCJ1XCIgPyBuLnN0eWxlLnJlbW92ZVByb3BlcnR5KGUpIDogKEUucmVtb3ZlRGF0YUF0dHJpYnV0ZShuLCBlKSwgbi5zdHlsZVtlXSA9IHIpO1xyXG4gICAgfTtcclxuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2sodCwgcyk7XHJcbiAgfVxyXG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGUpIHtcclxuICAgIFN0KHQpID8gZSh0KSA6IGguZmluZCh0LCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKGUpO1xyXG4gIH1cclxuICBpc092ZXJmbG93aW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSA+IDA7XHJcbiAgfVxyXG59XHJcbmNvbnN0IElvID0ge1xyXG4gIGlzVmlzaWJsZTogITAsXHJcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cclxuICBpc0FuaW1hdGVkOiAhMSxcclxuICByb290RWxlbWVudDogXCJib2R5XCIsXHJcbiAgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xyXG4gIGNsaWNrQ2FsbGJhY2s6IG51bGwsXHJcbiAgYmFja2Ryb3BDbGFzc2VzOiBudWxsXHJcbn0sIFJvID0ge1xyXG4gIGlzVmlzaWJsZTogXCJib29sZWFuXCIsXHJcbiAgaXNBbmltYXRlZDogXCJib29sZWFuXCIsXHJcbiAgcm9vdEVsZW1lbnQ6IFwiKGVsZW1lbnR8c3RyaW5nKVwiLFxyXG4gIGNsaWNrQ2FsbGJhY2s6IFwiKGZ1bmN0aW9ufG51bGwpXCIsXHJcbiAgYmFja2Ryb3BDbGFzc2VzOiBcIihhcnJheXxzdHJpbmd8bnVsbClcIlxyXG59LCBUbiA9IFwiYmFja2Ryb3BcIiwgZXMgPSBgbW91c2Vkb3duLnR3ZS4ke1RufWA7XHJcbmNsYXNzIHluIHtcclxuICBjb25zdHJ1Y3Rvcih0KSB7XHJcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcodCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XHJcbiAgfVxyXG4gIHNob3codCkge1xyXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XHJcbiAgICAgIF90KHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9hcHBlbmQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQgJiYgWHQodGhpcy5fZ2V0RWxlbWVudCgpKTtcclxuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25maWcuYmFja2Ryb3BDbGFzc2VzIHx8IFtcclxuICAgICAgXCJvcGFjaXR5LTUwXCIsXHJcbiAgICAgIFwidHJhbnNpdGlvbi1hbGxcIixcclxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcclxuICAgICAgXCJlYXNlLWluLW91dFwiLFxyXG4gICAgICBcImZpeGVkXCIsXHJcbiAgICAgIFwidG9wLTBcIixcclxuICAgICAgXCJsZWZ0LTBcIixcclxuICAgICAgXCJ6LVsxMDQwXVwiLFxyXG4gICAgICBcImJnLWJsYWNrXCIsXHJcbiAgICAgIFwidy1zY3JlZW5cIixcclxuICAgICAgXCJoLXNjcmVlblwiXHJcbiAgICBdO1xyXG4gICAgRS5yZW1vdmVDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIFwib3BhY2l0eS0wXCIpLCBFLmFkZENsYXNzKHRoaXMuX2dldEVsZW1lbnQoKSwgZSksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10d2UtYmFja2Ryb3Atc2hvd1wiLCBcIlwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XHJcbiAgICAgIF90KHQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGhpZGUodCkge1xyXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XHJcbiAgICAgIF90KHQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdHdlLWJhY2tkcm9wLXNob3dcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0wXCIpLCB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktNTBcIiksIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xyXG4gICAgICB0aGlzLmRpc3Bvc2UoKSwgX3QodCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgdXBkYXRlKHQgPSB7fSkge1xyXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fY29uZmlnLCAuLi50IH0pO1xyXG4gIH1cclxuICAvLyBQcml2YXRlXHJcbiAgX2dldEVsZW1lbnQoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcclxuICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XHJcbiAgfVxyXG4gIF9nZXRDb25maWcodCkge1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLklvLFxyXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XHJcbiAgICB9LCB0LnJvb3RFbGVtZW50ID0gcnQodC5yb290RWxlbWVudCksIFIoVG4sIHQsIFJvKSwgdDtcclxuICB9XHJcbiAgX2FwcGVuZCgpIHtcclxuICAgIHRoaXMuX2lzQXBwZW5kZWQgfHwgKHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5fZ2V0RWxlbWVudCgpKSwgZC5vbih0aGlzLl9nZXRFbGVtZW50KCksIGVzLCAoKSA9PiB7XHJcbiAgICAgIF90KHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcclxuICAgIH0pLCB0aGlzLl9pc0FwcGVuZGVkID0gITApO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5faXNBcHBlbmRlZCAmJiAoZC5vZmYodGhpcy5fZWxlbWVudCwgZXMpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEpO1xyXG4gIH1cclxuICBfZW11bGF0ZUFuaW1hdGlvbih0KSB7XHJcbiAgICBXcyhcclxuICAgICAgdCxcclxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLFxyXG4gICAgICB0aGlzLl9jb25maWcuaXNBbmltYXRlZFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuY2xhc3MgQW4ge1xyXG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgcykge1xyXG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX3RvZ2dsZXIgPSBzLCB0aGlzLl9ldmVudCA9IGUuZXZlbnQgfHwgXCJibHVyXCIsIHRoaXMuX2NvbmRpdGlvbiA9IGUuY29uZGl0aW9uIHx8ICgoKSA9PiAhMCksIHRoaXMuX3NlbGVjdG9yID0gZS5zZWxlY3RvciB8fCAnYnV0dG9uLCBhLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJywgdGhpcy5fb25seVZpc2libGUgPSBlLm9ubHlWaXNpYmxlIHx8ICExLCB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IFtdLCB0aGlzLl9maXJzdEVsZW1lbnQgPSBudWxsLCB0aGlzLl9sYXN0RWxlbWVudCA9IG51bGwsIHRoaXMuaGFuZGxlciA9IChuKSA9PiB7XHJcbiAgICAgIHRoaXMuX2NvbmRpdGlvbihuKSAmJiAhbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fbGFzdEVsZW1lbnQgPyAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSkgOiB0aGlzLl9jb25kaXRpb24obikgJiYgbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fZmlyc3RFbGVtZW50ICYmIChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2xhc3RFbGVtZW50LmZvY3VzKCkpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgdHJhcCgpIHtcclxuICAgIHRoaXMuX3NldEVsZW1lbnRzKCksIHRoaXMuX2luaXQoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XHJcbiAgfVxyXG4gIGRpc2FibGUoKSB7XHJcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0KSA9PiB7XHJcbiAgICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcclxuICAgIH0pLCB0aGlzLl90b2dnbGVyICYmIHRoaXMuX3RvZ2dsZXIuZm9jdXMoKTtcclxuICB9XHJcbiAgdXBkYXRlKCkge1xyXG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XHJcbiAgfVxyXG4gIF9pbml0KCkge1xyXG4gICAgY29uc3QgdCA9IChlKSA9PiB7XHJcbiAgICAgICF0aGlzLl9maXJzdEVsZW1lbnQgfHwgZS5rZXkgIT09IFwiVGFiXCIgfHwgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuaW5jbHVkZXMoZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZpcnN0RWxlbWVudC5mb2N1cygpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdCkpO1xyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KTtcclxuICB9XHJcbiAgX2ZpbHRlclZpc2libGUodCkge1xyXG4gICAgcmV0dXJuIHQuZmlsdGVyKChlKSA9PiB7XHJcbiAgICAgIGlmICgha3QoZSkpXHJcbiAgICAgICAgcmV0dXJuICExO1xyXG4gICAgICBjb25zdCBzID0gaC5wYXJlbnRzKGUsIFwiKlwiKTtcclxuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgY29uc3QgciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNbbl0pO1xyXG4gICAgICAgIGlmIChyICYmIChyLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IHIudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikpXHJcbiAgICAgICAgICByZXR1cm4gITE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICEwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9zZXRFbGVtZW50cygpIHtcclxuICAgIGNvbnN0IHQgPSBoLmZpbmQodGhpcy5fc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMgPSB0LmZpbHRlcigoZSkgPT4ge1xyXG4gICAgICBjb25zdCBzID0gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1kaXNhYmxlZFwiKSA9PT0gXCJ0cnVlXCIgfHwgZS5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgcmV0dXJuIGUuZGlzYWJsZWQgfHwgcyA/IG51bGwgOiBlO1xyXG4gICAgfSksIHRoaXMuX29ubHlWaXNpYmxlICYmICh0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IHRoaXMuX2ZpbHRlclZpc2libGUodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMpKSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbMF0sIHRoaXMuX2xhc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XHJcbiAgfVxyXG4gIF9zZXRGb2N1c1RyYXAoKSB7XHJcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0LCBlKSA9PiB7XHJcbiAgICAgIGUgPT09IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDEgfHwgZSA9PT0gMCA/IHQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKSA6IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9ldmVudCwgdGhpcy5oYW5kbGVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5sZXQgaXMgPSBbXTtcclxuY29uc3QgQ24gPSAoaSwgdCA9IFwiaGlkZVwiKSA9PiB7XHJcbiAgY29uc3QgZSA9IGBjbGljay5kaXNtaXNzJHtpLkVWRU5UX0tFWX1gLCBzID0gaS5OQU1FO1xyXG4gIGlzLmluY2x1ZGVzKHMpIHx8IChpcy5wdXNoKHMpLCBkLm9uKFxyXG4gICAgZG9jdW1lbnQsXHJcbiAgICBlLFxyXG4gICAgYFtkYXRhLXR3ZS0ke3N9LWRpc21pc3NdYCxcclxuICAgIGZ1bmN0aW9uKG4pIHtcclxuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgbi5wcmV2ZW50RGVmYXVsdCgpLCBndCh0aGlzKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNvbnN0IHIgPSBudCh0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke3N9YCkgfHwgdGhpcy5jbG9zZXN0KGBbZGF0YS10d2UtJHtzfS1pbml0XWApO1xyXG4gICAgICBpZiAoIXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpLmdldE9yQ3JlYXRlSW5zdGFuY2UocilbdF0oKTtcclxuICAgIH1cclxuICApKTtcclxufSwgeG8gPSA5LCBzcyA9IFwib2ZmY2FudmFzXCIsIGtvID0gXCJ0d2Uub2ZmY2FudmFzXCIsIE10ID0gYC4ke2tvfWAsIFBvID0gXCIuZGF0YS1hcGlcIiwgTW8gPSBgbG9hZCR7TXR9JHtQb31gLCBIbyA9IFwiRXNjYXBlXCIsIG5zID0ge1xyXG4gIGJhY2tkcm9wOiAhMCxcclxuICBrZXlib2FyZDogITAsXHJcbiAgc2Nyb2xsOiAhMVxyXG59LCBWbyA9IHtcclxuICBiYWNrZHJvcDogXCJib29sZWFuXCIsXHJcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxyXG4gIHNjcm9sbDogXCJib29sZWFuXCJcclxufSwgcnMgPSBcInNob3dcIiwgV28gPSBcIltkYXRhLXR3ZS1vZmZjYW52YXMtaW5pdF1bZGF0YS10d2Utb2ZmY2FudmFzLXNob3ddXCIsIEJvID0gYHNob3cke010fWAsIGpvID0gYHNob3duJHtNdH1gLCBVbyA9IGBoaWRlJHtNdH1gLCBGbyA9IGBoaWRkZW4ke010fWAsIFlvID0gYGtleWRvd24uZGlzbWlzcyR7TXR9YDtcclxuY2xhc3MgX2UgZXh0ZW5kcyB0dCB7XHJcbiAgY29uc3RydWN0b3IodCwgZSkge1xyXG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xyXG4gIH1cclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIHNzO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICByZXR1cm4gbnM7XHJcbiAgfVxyXG4gIC8vIFB1YmxpY1xyXG4gIHRvZ2dsZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xyXG4gIH1cclxuICBzaG93KHQpIHtcclxuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBCbywge1xyXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XHJcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHJpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLXR3ZS1vZmZjYW52YXMtJHtyc31gLCBcIlwiKTtcclxuICAgIGNvbnN0IHMgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fZm9jdXN0cmFwLnRyYXAoKSwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGpvLCB7IHJlbGF0ZWRUYXJnZXQ6IHQgfSk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhzLCB0aGlzLl9lbGVtZW50LCAhMCk7XHJcbiAgfVxyXG4gIGhpZGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFVvKS5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10d2Utb2ZmY2FudmFzLSR7cnN9YCksIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcclxuICAgIGNvbnN0IGUgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIiwgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCBuZXcgcmkoKS5yZXNldCgpLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRm8pO1xyXG4gICAgfTtcclxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgITApO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XHJcbiAgfVxyXG4gIC8vIFByaXZhdGVcclxuICBfaW5pdCgpIHtcclxuICAgIHRoaXMuX2RpZEluaXQgfHwgKGQub24oXHJcbiAgICAgIHdpbmRvdyxcclxuICAgICAgTW8sXHJcbiAgICAgICgpID0+IGguZmluZChXbykuZm9yRWFjaChcclxuICAgICAgICAodCkgPT4gX2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0KS5zaG93KClcclxuICAgICAgKVxyXG4gICAgKSwgdGhpcy5fZGlkSW5pdCA9ICEwLCBDbihfZSkpO1xyXG4gIH1cclxuICBfZ2V0Q29uZmlnKHQpIHtcclxuICAgIHJldHVybiB0ID0ge1xyXG4gICAgICAuLi5ucyxcclxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcclxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxyXG4gICAgfSwgUihzcywgdCwgVm8pLCB0O1xyXG4gIH1cclxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xyXG4gICAgcmV0dXJuIG5ldyB5bih7XHJcbiAgICAgIGlzVmlzaWJsZTogdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxyXG4gICAgICBpc0FuaW1hdGVkOiAhMCxcclxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcclxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcclxuICAgIH0pO1xyXG4gIH1cclxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcclxuICAgIHJldHVybiBuZXcgQW4odGhpcy5fZWxlbWVudCwge1xyXG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXHJcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5Q29kZSA9PT0geG8sXHJcbiAgICAgIG9ubHlWaXNpYmxlOiAhMFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgIGQub24odGhpcy5fZWxlbWVudCwgWW8sICh0KSA9PiB7XHJcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gSG8gJiYgdGhpcy5oaWRlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgLy8gU3RhdGljXHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBlID0gX2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcclxuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSh0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IFZlID0gXCJjYXJvdXNlbFwiLCBLbyA9IFwidHdlLmNhcm91c2VsXCIsIFUgPSBgLiR7S299YCwgT24gPSBcIi5kYXRhLWFwaVwiLCB6byA9IFwiQXJyb3dMZWZ0XCIsIHFvID0gXCJBcnJvd1JpZ2h0XCIsIFhvID0gNTAwLCBHbyA9IDQwLCBvcyA9IHtcclxuICBpbnRlcnZhbDogNWUzLFxyXG4gIGtleWJvYXJkOiAhMCxcclxuICByaWRlOiAhMSxcclxuICBwYXVzZTogXCJob3ZlclwiLFxyXG4gIHdyYXA6ICEwLFxyXG4gIHRvdWNoOiAhMFxyXG59LCBRbyA9IHtcclxuICBpbnRlcnZhbDogXCIobnVtYmVyfGJvb2xlYW4pXCIsXHJcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxyXG4gIHJpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxyXG4gIHBhdXNlOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcclxuICB3cmFwOiBcImJvb2xlYW5cIixcclxuICB0b3VjaDogXCJib29sZWFuXCJcclxufSwgWm8gPSB7XHJcbiAgcG9pbnRlcjogXCJ0b3VjaC1wYW4teVwiLFxyXG4gIGJsb2NrOiBcIiFibG9ja1wiLFxyXG4gIHZpc2libGU6IFwiZGF0YS1bdHdlLWNhcm91c2VsLWZhZGVdOm9wYWNpdHktMTAwIGRhdGEtW3R3ZS1jYXJvdXNlbC1mYWRlXTp6LVsxXVwiLFxyXG4gIGludmlzaWJsZTogXCJkYXRhLVt0d2UtY2Fyb3VzZWwtZmFkZV06ei0wIGRhdGEtW3R3ZS1jYXJvdXNlbC1mYWRlXTpvcGFjaXR5LTAgZGF0YS1bdHdlLWNhcm91c2VsLWZhZGVdOmR1cmF0aW9uLVs2MDBtc10gZGF0YS1bdHdlLWNhcm91c2VsLWZhZGVdOmRlbGF5LTYwMFwiLFxyXG4gIHNsaWRlUmlnaHQ6IFwidHJhbnNsYXRlLXgtZnVsbFwiLFxyXG4gIHNsaWRlTGVmdDogXCItdHJhbnNsYXRlLXgtZnVsbFwiXHJcbn0sIEpvID0ge1xyXG4gIHBvaW50ZXI6IFwic3RyaW5nXCIsXHJcbiAgYmxvY2s6IFwic3RyaW5nXCIsXHJcbiAgdmlzaWJsZTogXCJzdHJpbmdcIixcclxuICBpbnZpc2libGU6IFwic3RyaW5nXCIsXHJcbiAgc2xpZGVSaWdodDogXCJzdHJpbmdcIixcclxuICBzbGlkZUxlZnQ6IFwic3RyaW5nXCJcclxufSwgaHQgPSBcIm5leHRcIiwgZnQgPSBcInByZXZcIiwgcHQgPSBcImxlZnRcIiwgWXQgPSBcInJpZ2h0XCIsIHRhID0ge1xyXG4gIFt6b106IFl0LFxyXG4gIFtxb106IHB0XHJcbn0sIGVhID0gYHNsaWRlJHtVfWAsIFdlID0gYHNsaWQke1V9YCwgaWEgPSBga2V5ZG93biR7VX1gLCBzYSA9IGBtb3VzZWVudGVyJHtVfWAsIG5hID0gYG1vdXNlbGVhdmUke1V9YCwgcmEgPSBgdG91Y2hzdGFydCR7VX1gLCBvYSA9IGB0b3VjaG1vdmUke1V9YCwgYWEgPSBgdG91Y2hlbmQke1V9YCwgbGEgPSBgcG9pbnRlcmRvd24ke1V9YCwgY2EgPSBgcG9pbnRlcnVwJHtVfWAsIGRhID0gYGRyYWdzdGFydCR7VX1gLCBhcyA9IGBsb2FkJHtVfSR7T259YCwgbHMgPSBgY2xpY2ske1V9JHtPbn1gLCBXdCA9IFwiZGF0YS10d2UtY2Fyb3VzZWwtYWN0aXZlXCIsIHVhID0gXCJkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLWVuZFwiLCBCZSA9IFwiZGF0YS10d2UtY2Fyb3VzZWwtaXRlbS1zdGFydFwiLCBoYSA9IFwiZGF0YS10d2UtY2Fyb3VzZWwtaXRlbS1uZXh0XCIsIGZhID0gXCJkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLXByZXZcIiwgcGEgPSBcImRhdGEtdHdlLWNhcm91c2VsLXBvaW50ZXItZXZlbnRcIiwgX2EgPSBcIltkYXRhLXR3ZS1jYXJvdXNlbC1pbml0XVwiLCBEbiA9IFwiW2RhdGEtdHdlLWNhcm91c2VsLWFjdGl2ZV1cIiwgQWkgPSBcIltkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtXVwiLCBUdCA9IGAke0RufSR7QWl9YCwgZ2EgPSBgJHtBaX0gaW1nYCwgbWEgPSBcIltkYXRhLXR3ZS1jYXJvdXNlbC1pdGVtLW5leHRdLCBbZGF0YS10d2UtY2Fyb3VzZWwtaXRlbS1wcmV2XVwiLCBFYSA9IFwiW2RhdGEtdHdlLWNhcm91c2VsLWluZGljYXRvcnNdXCIsIHZhID0gXCJbZGF0YS10d2UtdGFyZ2V0XVwiLCBjcyA9IFwiW2RhdGEtdHdlLXNsaWRlXSwgW2RhdGEtdHdlLXNsaWRlLXRvXVwiLCBiYSA9IFwidG91Y2hcIiwgd2EgPSBcInBlblwiO1xyXG5jbGFzcyBaIGV4dGVuZHMgdHQge1xyXG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcclxuICAgIHN1cGVyKHQpLCB0aGlzLl9pdGVtcyA9IG51bGwsIHRoaXMuX2ludGVydmFsID0gbnVsbCwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGwsIHRoaXMuX2lzUGF1c2VkID0gITEsIHRoaXMuX2lzU2xpZGluZyA9ICExLCB0aGlzLnRvdWNoVGltZW91dCA9IG51bGwsIHRoaXMudG91Y2hTdGFydFggPSAwLCB0aGlzLnRvdWNoRGVsdGFYID0gMCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhzKSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBoLmZpbmRPbmUoXHJcbiAgICAgIEVhLFxyXG4gICAgICB0aGlzLl9lbGVtZW50XHJcbiAgICApLCB0aGlzLl90b3VjaFN1cHBvcnRlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAsIHRoaXMuX3BvaW50ZXJFdmVudCA9ICEhd2luZG93LlBvaW50ZXJFdmVudCwgdGhpcy5fc2V0QWN0aXZlRWxlbWVudENsYXNzKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpLCB0aGlzLl9jb25maWcucmlkZSA9PT0gXCJjYXJvdXNlbFwiICYmIHRoaXMuY3ljbGUoKTtcclxuICB9XHJcbiAgLy8gR2V0dGVyc1xyXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgIHJldHVybiBvcztcclxuICB9XHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIFZlO1xyXG4gIH1cclxuICAvLyBQdWJsaWNcclxuICBuZXh0KCkge1xyXG4gICAgdGhpcy5fc2xpZGUoaHQpO1xyXG4gIH1cclxuICBuZXh0V2hlblZpc2libGUoKSB7XHJcbiAgICAhZG9jdW1lbnQuaGlkZGVuICYmIGt0KHRoaXMuX2VsZW1lbnQpICYmIHRoaXMubmV4dCgpO1xyXG4gIH1cclxuICBwcmV2KCkge1xyXG4gICAgdGhpcy5fc2xpZGUoZnQpO1xyXG4gIH1cclxuICBwYXVzZSh0KSB7XHJcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICEwKSwgaC5maW5kT25lKG1hLCB0aGlzLl9lbGVtZW50KSAmJiAoUHModGhpcy5fZWxlbWVudCksIHRoaXMuY3ljbGUoITApKSwgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCksIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICB9XHJcbiAgY3ljbGUodCkge1xyXG4gICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoXHJcbiAgICAgIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZChcclxuICAgICAgICB0aGlzXHJcbiAgICAgICksXHJcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxyXG4gICAgKSk7XHJcbiAgfVxyXG4gIHRvKHQpIHtcclxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBoLmZpbmRPbmUoXHJcbiAgICAgIFR0LFxyXG4gICAgICB0aGlzLl9lbGVtZW50XHJcbiAgICApO1xyXG4gICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcclxuICAgIGlmICh0ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCB0IDwgMClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xyXG4gICAgICBkLm9uZSh0aGlzLl9lbGVtZW50LCBXZSwgKCkgPT4gdGhpcy50byh0KSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChlID09PSB0KSB7XHJcbiAgICAgIHRoaXMucGF1c2UoKSwgdGhpcy5jeWNsZSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzID0gdCA+IGUgPyBodCA6IGZ0O1xyXG4gICAgdGhpcy5fc2xpZGUocywgdGhpcy5faXRlbXNbdF0pO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgZC5vZmYoXHJcbiAgICAgIGRvY3VtZW50LFxyXG4gICAgICBscyxcclxuICAgICAgY3MsXHJcbiAgICAgIFouZGF0YUFwaUNsaWNrSGFuZGxlclxyXG4gICAgKSwgZC5vZmYod2luZG93LCBhcyksIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbiAgLy8gUHJpdmF0ZVxyXG4gIF9pbml0KCkge1xyXG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoZC5vbihcclxuICAgICAgZG9jdW1lbnQsXHJcbiAgICAgIGxzLFxyXG4gICAgICBjcyxcclxuICAgICAgWi5kYXRhQXBpQ2xpY2tIYW5kbGVyXHJcbiAgICApLCBkLm9uKHdpbmRvdywgYXMsICgpID0+IHtcclxuICAgICAgY29uc3QgdCA9IGguZmluZChfYSk7XHJcbiAgICAgIGZvciAobGV0IGUgPSAwLCBzID0gdC5sZW5ndGg7IGUgPCBzOyBlKyspXHJcbiAgICAgICAgWi5jYXJvdXNlbEludGVyZmFjZShcclxuICAgICAgICAgIHRbZV0sXHJcbiAgICAgICAgICBaLmdldEluc3RhbmNlKHRbZV0pXHJcbiAgICAgICAgKTtcclxuICAgIH0pLCB0aGlzLl9kaWRJbml0ID0gITApO1xyXG4gIH1cclxuICBfZ2V0Q29uZmlnKHQpIHtcclxuICAgIHJldHVybiB0ID0ge1xyXG4gICAgICAuLi5vcyxcclxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcclxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxyXG4gICAgfSwgUihWZSwgdCwgUW8pLCB0O1xyXG4gIH1cclxuICBfZ2V0Q2xhc3Nlcyh0KSB7XHJcbiAgICBjb25zdCBlID0gRS5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLlpvLFxyXG4gICAgICAuLi5lLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCBSKFZlLCB0LCBKbyksIHQ7XHJcbiAgfVxyXG4gIF9lbmFibGVDeWNsZSgpIHtcclxuICAgIGlmICh0aGlzLl9jb25maWcucmlkZSkge1xyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgZC5vbmUodGhpcy5fZWxlbWVudCwgV2UsICgpID0+IHRoaXMuY3ljbGUoKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3ljbGUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2FwcGx5SW5pdGlhbENsYXNzZXMoKSB7XHJcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKFxyXG4gICAgICBUdCxcclxuICAgICAgdGhpcy5fZWxlbWVudFxyXG4gICAgKTtcclxuICAgIHQuY2xhc3NMaXN0LmFkZChcclxuICAgICAgdGhpcy5fY2xhc3Nlcy5ibG9jayxcclxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKVxyXG4gICAgKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KTtcclxuICB9XHJcbiAgX2hhbmRsZVN3aXBlKCkge1xyXG4gICAgY29uc3QgdCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO1xyXG4gICAgaWYgKHQgPD0gR28pXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IGUgPSB0IC8gdGhpcy50b3VjaERlbHRhWDtcclxuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwLCBlICYmIHRoaXMuX3NsaWRlKGUgPiAwID8gWXQgOiBwdCk7XHJcbiAgfVxyXG4gIF9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSB7XHJcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gaC5maW5kT25lKFxyXG4gICAgICBUdCxcclxuICAgICAgdGhpcy5fZWxlbWVudFxyXG4gICAgKSwgRS5hZGRDbGFzcyh0aGlzLl9hY3RpdmVFbGVtZW50LCBcImhpZGRlblwiKTtcclxuICB9XHJcbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGQub24oXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIGlhLFxyXG4gICAgICAodCkgPT4gdGhpcy5fa2V5ZG93bih0KVxyXG4gICAgKSwgdGhpcy5fY29uZmlnLnBhdXNlID09PSBcImhvdmVyXCIgJiYgKGQub24oXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIHNhLFxyXG4gICAgICAodCkgPT4gdGhpcy5wYXVzZSh0KVxyXG4gICAgKSwgZC5vbihcclxuICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgbmEsXHJcbiAgICAgICh0KSA9PiB0aGlzLl9lbmFibGVDeWNsZSh0KVxyXG4gICAgKSksIHRoaXMuX2NvbmZpZy50b3VjaCAmJiB0aGlzLl90b3VjaFN1cHBvcnRlZCAmJiB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoKTtcclxuICB9XHJcbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICBjb25zdCB0ID0gKHIpID0+IHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoci5wb2ludGVyVHlwZSA9PT0gd2EgfHwgci5wb2ludGVyVHlwZSA9PT0gYmEpLCBlID0gKHIpID0+IHtcclxuICAgICAgdChyKSA/IHRoaXMudG91Y2hTdGFydFggPSByLmNsaWVudFggOiB0aGlzLl9wb2ludGVyRXZlbnQgfHwgKHRoaXMudG91Y2hTdGFydFggPSByLnRvdWNoZXNbMF0uY2xpZW50WCk7XHJcbiAgICB9LCBzID0gKHIpID0+IHtcclxuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IHIudG91Y2hlcyAmJiByLnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiByLnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFg7XHJcbiAgICB9LCBuID0gKHIpID0+IHtcclxuICAgICAgdChyKSAmJiAodGhpcy50b3VjaERlbHRhWCA9IHIuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFgpLCB0aGlzLl9oYW5kbGVTd2lwZSgpLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAodGhpcy5wYXVzZSgpLCB0aGlzLnRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpLCB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoXHJcbiAgICAgICAgKG8pID0+IHRoaXMuX2VuYWJsZUN5Y2xlKG8pLFxyXG4gICAgICAgIFhvICsgdGhpcy5fY29uZmlnLmludGVydmFsXHJcbiAgICAgICkpO1xyXG4gICAgfTtcclxuICAgIGguZmluZChnYSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcclxuICAgICAgKHIpID0+IHtcclxuICAgICAgICBkLm9uKFxyXG4gICAgICAgICAgcixcclxuICAgICAgICAgIGRhLFxyXG4gICAgICAgICAgKG8pID0+IG8ucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICksIHRoaXMuX3BvaW50ZXJFdmVudCA/IChkLm9uKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBsYSxcclxuICAgICAgKHIpID0+IGUocilcclxuICAgICksIGQub24odGhpcy5fZWxlbWVudCwgY2EsIChyKSA9PiBuKHIpKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMucG9pbnRlciksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGAke3BhfWAsIFwiXCIpKSA6IChkLm9uKHRoaXMuX2VsZW1lbnQsIHJhLCAocikgPT4gZShyKSksIGQub24odGhpcy5fZWxlbWVudCwgb2EsIChyKSA9PiBzKHIpKSwgZC5vbih0aGlzLl9lbGVtZW50LCBhYSwgKHIpID0+IG4ocikpKTtcclxuICB9XHJcbiAgX2tleWRvd24odCkge1xyXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IGUgPSB0YVt0LmtleV07XHJcbiAgICBlICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3NsaWRlKGUpKTtcclxuICB9XHJcbiAgX2dldEl0ZW1JbmRleCh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXRlbXMgPSB0ICYmIHQucGFyZW50Tm9kZSA/IGguZmluZChBaSwgdC5wYXJlbnROb2RlKSA6IFtdLCB0aGlzLl9pdGVtcy5pbmRleE9mKHQpO1xyXG4gIH1cclxuICBfZ2V0SXRlbUJ5T3JkZXIodCwgZSkge1xyXG4gICAgY29uc3QgcyA9IHQgPT09IGh0O1xyXG4gICAgcmV0dXJuIEJzKFxyXG4gICAgICB0aGlzLl9pdGVtcyxcclxuICAgICAgZSxcclxuICAgICAgcyxcclxuICAgICAgdGhpcy5fY29uZmlnLndyYXBcclxuICAgICk7XHJcbiAgfVxyXG4gIF90cmlnZ2VyU2xpZGVFdmVudCh0LCBlKSB7XHJcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpLCBuID0gdGhpcy5fZ2V0SXRlbUluZGV4KFxyXG4gICAgICBoLmZpbmRPbmUoVHQsIHRoaXMuX2VsZW1lbnQpXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBlYSwge1xyXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0LFxyXG4gICAgICBkaXJlY3Rpb246IGUsXHJcbiAgICAgIGZyb206IG4sXHJcbiAgICAgIHRvOiBzXHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCkge1xyXG4gICAgaWYgKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IGUgPSBoLmZpbmRPbmUoXHJcbiAgICAgICAgRG4sXHJcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnRcclxuICAgICAgKTtcclxuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUoV3QpLCBlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiKSwgZS5jbGFzc0xpc3QucmVtb3ZlKFwiIW9wYWNpdHktMTAwXCIpO1xyXG4gICAgICBjb25zdCBzID0gaC5maW5kKFxyXG4gICAgICAgIHZhLFxyXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XHJcbiAgICAgICk7XHJcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKylcclxuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KFxyXG4gICAgICAgICAgc1tuXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1zbGlkZS10b1wiKSxcclxuICAgICAgICAgIDEwXHJcbiAgICAgICAgKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpKSB7XHJcbiAgICAgICAgICBzW25dLnNldEF0dHJpYnV0ZShgJHtXdH1gLCBcIlwiKSwgc1tuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpLCBzW25dLmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0xMDBcIik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcclxuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IGguZmluZE9uZShUdCwgdGhpcy5fZWxlbWVudCk7XHJcbiAgICBpZiAoIXQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IGUgPSBOdW1iZXIucGFyc2VJbnQoXHJcbiAgICAgIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS10d2UtaW50ZXJ2YWxcIiksXHJcbiAgICAgIDEwXHJcbiAgICApO1xyXG4gICAgZSA/ICh0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWwsIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGUpIDogdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XHJcbiAgfVxyXG4gIF9zbGlkZSh0LCBlKSB7XHJcbiAgICBjb25zdCBzID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcih0KSwgbiA9IGguZmluZE9uZShcclxuICAgICAgVHQsXHJcbiAgICAgIHRoaXMuX2VsZW1lbnRcclxuICAgICksIHIgPSB0aGlzLl9nZXRJdGVtSW5kZXgobiksIG8gPSBlIHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKHMsIG4pLCBhID0gdGhpcy5fZ2V0SXRlbUluZGV4KG8pLCBsID0gISF0aGlzLl9pbnRlcnZhbCwgdSA9IHMgPT09IGh0LCBjID0gdSA/IEJlIDogdWEsIGYgPSB1ID8gaGEgOiBmYSwgdiA9IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24ocyksIGcgPSBjID09PSBCZSA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LCBPID0gYyAhPT0gQmUgPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodDtcclxuICAgIGlmIChvICYmIG8uaGFzQXR0cmlidXRlKFd0KSkge1xyXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZyB8fCB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChvLCB2KS5kZWZhdWx0UHJldmVudGVkIHx8ICFuIHx8ICFvKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSAhMCwgbCAmJiB0aGlzLnBhdXNlKCksIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQobyksIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBvO1xyXG4gICAgY29uc3QgQSA9ICgpID0+IHtcclxuICAgICAgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFdlLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogbyxcclxuICAgICAgICBkaXJlY3Rpb246IHYsXHJcbiAgICAgICAgZnJvbTogcixcclxuICAgICAgICB0bzogYVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBvLnNldEF0dHJpYnV0ZShgJHtmfWAsIFwiXCIpLCBvLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5ibG9jaywgTyksIFh0KG8pLCBuLnNldEF0dHJpYnV0ZShgJHtjfWAsIFwiXCIpLCBuLmNsYXNzTGlzdC5hZGQoXHJcbiAgICAgIGcsXHJcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKVxyXG4gICAgKSwgbi5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCBvLnNldEF0dHJpYnV0ZShgJHtjfWAsIFwiXCIpLCBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy52aXNpYmxlLnNwbGl0KFwiIFwiKSksIG8uY2xhc3NMaXN0LnJlbW92ZShcclxuICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LFxyXG4gICAgICB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdFxyXG4gICAgKTtcclxuICAgIGNvbnN0IEQgPSAoKSA9PiB7XHJcbiAgICAgIG8ucmVtb3ZlQXR0cmlidXRlKGMpLCBvLnJlbW92ZUF0dHJpYnV0ZShmKSwgby5zZXRBdHRyaWJ1dGUoYCR7V3R9YCwgXCJcIiksIG4ucmVtb3ZlQXR0cmlidXRlKFd0KSwgbi5jbGFzc0xpc3QucmVtb3ZlKFxyXG4gICAgICAgIGcsXHJcbiAgICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnZpc2libGUuc3BsaXQoXCIgXCIpLFxyXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuYmxvY2tcclxuICAgICAgKSwgbi5yZW1vdmVBdHRyaWJ1dGUoZiksIG4ucmVtb3ZlQXR0cmlidXRlKGMpLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgc2V0VGltZW91dChBLCAwKTtcclxuICAgIH07XHJcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKEQsIG4sICEwKSwgKGwgfHwgdGhpcy5fY29uZmlnLnJpZGUgPT09ICEwKSAmJiB0aGlzLmN5Y2xlKCk7XHJcbiAgfVxyXG4gIF9kaXJlY3Rpb25Ub09yZGVyKHQpIHtcclxuICAgIHJldHVybiBbWXQsIHB0XS5pbmNsdWRlcyh0KSA/IE0oKSA/IHQgPT09IHB0ID8gZnQgOiBodCA6IHQgPT09IHB0ID8gaHQgOiBmdCA6IHQ7XHJcbiAgfVxyXG4gIF9vcmRlclRvRGlyZWN0aW9uKHQpIHtcclxuICAgIHJldHVybiBbaHQsIGZ0XS5pbmNsdWRlcyh0KSA/IE0oKSA/IHQgPT09IGZ0ID8gcHQgOiBZdCA6IHQgPT09IGZ0ID8gWXQgOiBwdCA6IHQ7XHJcbiAgfVxyXG4gIC8vIFN0YXRpY1xyXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZSh0LCBlKSB7XHJcbiAgICBjb25zdCBzID0gWi5nZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUpO1xyXG4gICAgbGV0IHsgX2NvbmZpZzogbiB9ID0gcztcclxuICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKG4gPSB7XHJcbiAgICAgIC4uLm4sXHJcbiAgICAgIC4uLmVcclxuICAgIH0pO1xyXG4gICAgY29uc3QgciA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5zbGlkZTtcclxuICAgIGlmICh0eXBlb2YgZSA9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHMudG8oZSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygc1tyXSA+IFwidVwiKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7cn1cImApO1xyXG4gICAgICBzW3JdKCk7XHJcbiAgICB9IGVsc2VcclxuICAgICAgbi5pbnRlcnZhbCAmJiBuLnJpZGUgPT09ICEwICYmIHMucGF1c2UoKTtcclxuICB9XHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBsZXQgZSA9IFouZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgaWYgKHR5cGVvZiB0ID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBlLnRvKHQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RhdGljIGRhdGFBcGlDbGlja0hhbmRsZXIodCkge1xyXG4gICAgY29uc3QgZSA9IG50KHRoaXMpO1xyXG4gICAgaWYgKCFlKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCBzID0ge1xyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpXHJcbiAgICB9LCBuID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1zbGlkZS10b1wiKTtcclxuICAgIG4gJiYgKHMuaW50ZXJ2YWwgPSAhMSksIFouY2Fyb3VzZWxJbnRlcmZhY2UoZSwgcyksIG4gJiYgWi5nZXRJbnN0YW5jZShlKS50byhuKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufVxyXG5jb25zdCBUYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcclxuICBcImJhY2tncm91bmRcIixcclxuICBcImNpdGVcIixcclxuICBcImhyZWZcIixcclxuICBcIml0ZW10eXBlXCIsXHJcbiAgXCJsb25nZGVzY1wiLFxyXG4gIFwicG9zdGVyXCIsXHJcbiAgXCJzcmNcIixcclxuICBcInhsaW5rOmhyZWZcIlxyXG5dKSwgeWEgPSAvXmFyaWEtW1xcdy1dKiQvaSwgQWEgPSAvXmRhdGEtdHdlLVtcXHctXSokL2ksIENhID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaSwgT2EgPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pLCBEYSA9IChpLCB0KSA9PiB7XHJcbiAgY29uc3QgZSA9IGkubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICBpZiAodC5pbmNsdWRlcyhlKSlcclxuICAgIHJldHVybiBUYS5oYXMoZSkgPyAhIShDYS50ZXN0KGkubm9kZVZhbHVlKSB8fCBPYS50ZXN0KGkubm9kZVZhbHVlKSkgOiAhMDtcclxuICBjb25zdCBzID0gdC5maWx0ZXIoXHJcbiAgICAobikgPT4gbiBpbnN0YW5jZW9mIFJlZ0V4cFxyXG4gICk7XHJcbiAgZm9yIChsZXQgbiA9IDAsIHIgPSBzLmxlbmd0aDsgbiA8IHI7IG4rKylcclxuICAgIGlmIChzW25dLnRlc3QoZSkpXHJcbiAgICAgIHJldHVybiAhMDtcclxuICByZXR1cm4gITE7XHJcbn0sIE5hID0ge1xyXG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXHJcbiAgXCIqXCI6IFtcclxuICAgIFwiY2xhc3NcIixcclxuICAgIFwiZGlyXCIsXHJcbiAgICBcImlkXCIsXHJcbiAgICBcImxhbmdcIixcclxuICAgIFwicm9sZVwiLFxyXG4gICAgeWEsXHJcbiAgICBBYVxyXG4gIF0sXHJcbiAgYTogW1widGFyZ2V0XCIsIFwiaHJlZlwiLCBcInRpdGxlXCIsIFwicmVsXCJdLFxyXG4gIGFyZWE6IFtdLFxyXG4gIGI6IFtdLFxyXG4gIGJyOiBbXSxcclxuICBjb2w6IFtdLFxyXG4gIGNvZGU6IFtdLFxyXG4gIGRpdjogW10sXHJcbiAgZW06IFtdLFxyXG4gIGhyOiBbXSxcclxuICBoMTogW10sXHJcbiAgaDI6IFtdLFxyXG4gIGgzOiBbXSxcclxuICBoNDogW10sXHJcbiAgaDU6IFtdLFxyXG4gIGg2OiBbXSxcclxuICBpOiBbXSxcclxuICBpbWc6IFtcInNyY1wiLCBcInNyY3NldFwiLCBcImFsdFwiLCBcInRpdGxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXHJcbiAgbGk6IFtdLFxyXG4gIG9sOiBbXSxcclxuICBwOiBbXSxcclxuICBwcmU6IFtdLFxyXG4gIHM6IFtdLFxyXG4gIHNtYWxsOiBbXSxcclxuICBzcGFuOiBbXSxcclxuICBzdWI6IFtdLFxyXG4gIHN1cDogW10sXHJcbiAgc3Ryb25nOiBbXSxcclxuICB1OiBbXSxcclxuICB1bDogW11cclxufTtcclxuZnVuY3Rpb24gZHMoaSwgdCwgZSkge1xyXG4gIGlmICghaS5sZW5ndGgpXHJcbiAgICByZXR1cm4gaTtcclxuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICByZXR1cm4gZShpKTtcclxuICBjb25zdCBuID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaSwgXCJ0ZXh0L2h0bWxcIiksIHIgPSBbXS5jb25jYXQoLi4ubi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKTtcclxuICBmb3IgKGxldCBvID0gMCwgYSA9IHIubGVuZ3RoOyBvIDwgYTsgbysrKSB7XHJcbiAgICBjb25zdCBsID0gcltvXSwgdSA9IGwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmICghT2JqZWN0LmtleXModCkuaW5jbHVkZXModSkpIHtcclxuICAgICAgbC5yZW1vdmUoKTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjID0gW10uY29uY2F0KC4uLmwuYXR0cmlidXRlcyksIGYgPSBbXS5jb25jYXQoXHJcbiAgICAgIHRbXCIqXCJdIHx8IFtdLFxyXG4gICAgICB0W3VdIHx8IFtdXHJcbiAgICApO1xyXG4gICAgYy5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgIERhKHYsIGYpIHx8IGwucmVtb3ZlQXR0cmlidXRlKHYubm9kZU5hbWUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBuLmJvZHkuaW5uZXJIVE1MO1xyXG59XHJcbmNvbnN0IHVzID0gXCJ0b29sdGlwXCIsIFNhID0gXCJ0d2UudG9vbHRpcFwiLCB6ID0gYC4ke1NhfWAsIExhID0gXCJ0ZS10b29sdGlwXCIsICRhID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wic2FuaXRpemVcIiwgXCJhbGxvd0xpc3RcIiwgXCJzYW5pdGl6ZUZuXCJdKSwgSWEgPSB7XHJcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcclxuICB0ZW1wbGF0ZTogXCJzdHJpbmdcIixcclxuICB0aXRsZTogXCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCIsXHJcbiAgdHJpZ2dlcjogXCJzdHJpbmdcIixcclxuICBkZWxheTogXCIobnVtYmVyfG9iamVjdClcIixcclxuICBodG1sOiBcImJvb2xlYW5cIixcclxuICBzZWxlY3RvcjogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXHJcbiAgcGxhY2VtZW50OiBcIihzdHJpbmd8ZnVuY3Rpb24pXCIsXHJcbiAgb2Zmc2V0OiBcIihhcnJheXxzdHJpbmd8ZnVuY3Rpb24pXCIsXHJcbiAgY29udGFpbmVyOiBcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLFxyXG4gIGZhbGxiYWNrUGxhY2VtZW50czogXCJhcnJheVwiLFxyXG4gIGJvdW5kYXJ5OiBcIihzdHJpbmd8ZWxlbWVudClcIixcclxuICBjdXN0b21DbGFzczogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxyXG4gIHNhbml0aXplOiBcImJvb2xlYW5cIixcclxuICBzYW5pdGl6ZUZuOiBcIihudWxsfGZ1bmN0aW9uKVwiLFxyXG4gIGFsbG93TGlzdDogXCJvYmplY3RcIixcclxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiXHJcbn0sIFJhID0ge1xyXG4gIEFVVE86IFwiYXV0b1wiLFxyXG4gIFRPUDogXCJ0b3BcIixcclxuICBSSUdIVDogTSgpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXHJcbiAgQk9UVE9NOiBcImJvdHRvbVwiLFxyXG4gIExFRlQ6IE0oKSA/IFwicmlnaHRcIiA6IFwibGVmdFwiXHJcbn0sIHhhID0ge1xyXG4gIGFuaW1hdGlvbjogITAsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxkaXYgY2xhc3M9XCJvcGFjaXR5LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBhYnNvbHV0ZSB6LVsxMDgwXSBibG9jayBtLTAgdGV4dC1zbSBub3QtaXRhbGljIGZvbnQtbm9ybWFsIHRleHQtbGVmdCBuby11bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1hdXRvIG5vcm1hbC1jYXNlIGxlYWRpbmctNiB0cmFja2luZy1ub3JtYWwgYnJlYWstbm9ybWFsIHdoaXRlc3BhY2Utbm9ybWFsXCIgcm9sZT1cInRvb2x0aXBcIj5cclxuICAgICAgPGRpdiBkYXRhLXR3ZS10b29sdGlwLWlubmVyLXJlZiBjbGFzcz1cIm1heC13LVsyMDBweF0gdGV4dC1zbSBweS0xLjUgcHgtNCB0ZXh0LXdoaXRlIHRleHQtY2VudGVyIGJnLVsjNmQ2ZDZkXSByb3VuZGVkXCI+PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIGAsXHJcbiAgdHJpZ2dlcjogXCJob3ZlciBmb2N1c1wiLFxyXG4gIHRpdGxlOiBcIlwiLFxyXG4gIGRlbGF5OiAwLFxyXG4gIGh0bWw6ICExLFxyXG4gIHNlbGVjdG9yOiAhMSxcclxuICBwbGFjZW1lbnQ6IFwidG9wXCIsXHJcbiAgb2Zmc2V0OiBbMCwgMF0sXHJcbiAgY29udGFpbmVyOiAhMSxcclxuICBmYWxsYmFja1BsYWNlbWVudHM6IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcclxuICBib3VuZGFyeTogXCJjbGlwcGluZ1BhcmVudHNcIixcclxuICBjdXN0b21DbGFzczogXCJcIixcclxuICBzYW5pdGl6ZTogITAsXHJcbiAgc2FuaXRpemVGbjogbnVsbCxcclxuICBhbGxvd0xpc3Q6IE5hLFxyXG4gIHBvcHBlckNvbmZpZzogeyBoaWRlOiAhMCB9XHJcbn0sIGthID0ge1xyXG4gIEhJREU6IGBoaWRlJHt6fWAsXHJcbiAgSElEREVOOiBgaGlkZGVuJHt6fWAsXHJcbiAgU0hPVzogYHNob3cke3p9YCxcclxuICBTSE9XTjogYHNob3duJHt6fWAsXHJcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7en1gLFxyXG4gIENMSUNLOiBgY2xpY2ske3p9YCxcclxuICBGT0NVU0lOOiBgZm9jdXNpbiR7en1gLFxyXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke3p9YCxcclxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7en1gLFxyXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHt6fWBcclxufSwgUGEgPSBcImZhZGVcIiwgTWEgPSBcIm1vZGFsXCIsIGplID0gXCJzaG93XCIsIEJ0ID0gXCJzaG93XCIsIFVlID0gXCJvdXRcIiwgaHMgPSBcIltkYXRhLXR3ZS10b29sdGlwLWlubmVyLXJlZl1cIiwgZnMgPSBgLiR7TWF9YCwgcHMgPSBcImhpZGUudHdlLm1vZGFsXCIsIGp0ID0gXCJob3ZlclwiLCBGZSA9IFwiZm9jdXNcIiwgSGEgPSBcImNsaWNrXCIsIFZhID0gXCJtYW51YWxcIjtcclxuY2xhc3MgUXQgZXh0ZW5kcyB0dCB7XHJcbiAgY29uc3RydWN0b3IodCwgZSkge1xyXG4gICAgaWYgKHR5cGVvZiBibiA+IFwidVwiKVxyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIlxyXG4gICAgICApO1xyXG4gICAgc3VwZXIodCksIHRoaXMuX2lzRW5hYmxlZCA9ICEwLCB0aGlzLl90aW1lb3V0ID0gMCwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCIsIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnRpcCA9IG51bGwsIHRoaXMuX3NldExpc3RlbmVycygpO1xyXG4gIH1cclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgcmV0dXJuIHhhO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICByZXR1cm4gdXM7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XHJcbiAgICByZXR1cm4ga2E7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICByZXR1cm4gSWE7XHJcbiAgfVxyXG4gIC8vIFB1YmxpY1xyXG4gIGVuYWJsZSgpIHtcclxuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICEwO1xyXG4gIH1cclxuICBkaXNhYmxlKCkge1xyXG4gICAgdGhpcy5faXNFbmFibGVkID0gITE7XHJcbiAgfVxyXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XHJcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xyXG4gIH1cclxuICB0b2dnbGUodCkge1xyXG4gICAgaWYgKHRoaXMuX2lzRW5hYmxlZClcclxuICAgICAgaWYgKHQpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQpO1xyXG4gICAgICAgIGUuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhZS5fYWN0aXZlVHJpZ2dlci5jbGljaywgZS5faXNXaXRoQWN0aXZlVHJpZ2dlcigpID8gZS5fZW50ZXIobnVsbCwgZSkgOiBlLl9sZWF2ZShudWxsLCBlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKGplKSkge1xyXG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIGQub2ZmKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoZnMpLFxyXG4gICAgICBwcyxcclxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxyXG4gICAgKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xyXG4gIH1cclxuICBzaG93KCkge1xyXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzXCIpO1xyXG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IGQudHJpZ2dlcihcclxuICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XXHJcbiAgICApLCBlID0gTXModGhpcy5fZWxlbWVudCksIHMgPSBlID09PSBudWxsID8gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KSA6IGUuY29udGFpbnModGhpcy5fZWxlbWVudCk7XHJcbiAgICBpZiAodC5kZWZhdWx0UHJldmVudGVkIHx8ICFzKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLk5BTUUgPT09IFwidG9vbHRpcFwiICYmIHRoaXMudGlwICYmIHRoaXMuZ2V0VGl0bGUoKSAhPT0gdGhpcy50aXAucXVlcnlTZWxlY3RvcihocykuaW5uZXJIVE1MICYmICh0aGlzLl9kaXNwb3NlUG9wcGVyKCksIHRoaXMudGlwLnJlbW92ZSgpLCB0aGlzLnRpcCA9IG51bGwpO1xyXG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCByID0gR24odGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcclxuICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgciksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCByKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdGhpcy50aXAuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCB0aGlzLnRpcC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0wXCIpO1xyXG4gICAgfSwgMTAwKTtcclxuICAgIGNvbnN0IG8gPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgbiwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50LCBhID0gdGhpcy5fZ2V0QXR0YWNobWVudChvKTtcclxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhhKTtcclxuICAgIGNvbnN0IHsgY29udGFpbmVyOiBsIH0gPSB0aGlzLl9jb25maWc7XHJcbiAgICBpZiAoVi5zZXREYXRhKG4sIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpLCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSB8fCAobC5hcHBlbmQobiksIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKSksIHRoaXMuX3BvcHBlciA/IHRoaXMuX3BvcHBlci51cGRhdGUoKSA6IHRoaXMuX3BvcHBlciA9IFRpKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBuLFxyXG4gICAgICB0aGlzLl9nZXRQb3BwZXJDb25maWcoYSlcclxuICAgICksIG4uZ2V0QXR0cmlidXRlKFwiaWRcIikuaW5jbHVkZXMoXCJ0b29sdGlwXCIpKVxyXG4gICAgICBzd2l0Y2ggKG8pIHtcclxuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XHJcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweS1bMC40cmVtXVwiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweC1bMC40cmVtXVwiKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxyXG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHgtWzAuNHJlbV1cIik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgbi5jbGFzc0xpc3QuYWRkKFwicHktWzAuNHJlbV1cIik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgY29uc3QgYyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcyk7XHJcbiAgICBjICYmIG4uY2xhc3NMaXN0LmFkZCguLi5jLnNwbGl0KFwiIFwiKSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChnKSA9PiB7XHJcbiAgICAgIGQub24oZywgXCJtb3VzZW92ZXJcIiwgbWUpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBmID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBnID0gdGhpcy5faG92ZXJTdGF0ZTtcclxuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGwsIGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKSwgZyA9PT0gVWUgJiYgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XHJcbiAgICB9LCB2ID0gdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKFwidHJhbnNpdGlvbi1vcGFjaXR5XCIpO1xyXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhmLCB0aGlzLnRpcCwgdik7XHJcbiAgfVxyXG4gIGhpZGUoKSB7XHJcbiAgICBpZiAoIXRoaXMuX3BvcHBlcilcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgfHwgKHRoaXMuX2hvdmVyU3RhdGUgIT09IEJ0ICYmIHQucmVtb3ZlKCksIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCkpO1xyXG4gICAgfTtcclxuICAgIGlmIChkLnRyaWdnZXIoXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERVxyXG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMTAwXCIpLCBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgocikgPT4gZC5vZmYociwgXCJtb3VzZW92ZXJcIiwgbWUpKSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltIYV0gPSAhMSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltGZV0gPSAhMSwgdGhpcy5fYWN0aXZlVHJpZ2dlcltqdF0gPSAhMTtcclxuICAgIGNvbnN0IG4gPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvcGFjaXR5LTBcIik7XHJcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMudGlwLCBuKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XHJcbiAgfVxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIHRoaXMuX3BvcHBlciAhPT0gbnVsbCAmJiB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XHJcbiAgfVxyXG4gIC8vIFByb3RlY3RlZFxyXG4gIGlzV2l0aENvbnRlbnQoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmdldFRpdGxlKCk7XHJcbiAgfVxyXG4gIGdldFRpcEVsZW1lbnQoKSB7XHJcbiAgICBpZiAodGhpcy50aXApXHJcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcclxuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgdC5pbm5lckhUTUwgPSB0aGlzLl9jb25maWcudGVtcGxhdGU7XHJcbiAgICBjb25zdCBlID0gdC5jaGlsZHJlblswXTtcclxuICAgIHJldHVybiB0aGlzLnNldENvbnRlbnQoZSksIGUuY2xhc3NMaXN0LnJlbW92ZShQYSwgamUpLCB0aGlzLnRpcCA9IGUsIHRoaXMudGlwO1xyXG4gIH1cclxuICBzZXRDb250ZW50KHQpIHtcclxuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIGhzKTtcclxuICB9XHJcbiAgX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCBlLCBzKSB7XHJcbiAgICBjb25zdCBuID0gaC5maW5kT25lKHMsIHQpO1xyXG4gICAgaWYgKCFlICYmIG4pIHtcclxuICAgICAgbi5yZW1vdmUoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChuLCBlKTtcclxuICB9XHJcbiAgc2V0RWxlbWVudENvbnRlbnQodCwgZSkge1xyXG4gICAgaWYgKHQgIT09IG51bGwpIHtcclxuICAgICAgaWYgKFN0KGUpKSB7XHJcbiAgICAgICAgZSA9IHJ0KGUpLCB0aGlzLl9jb25maWcuaHRtbCA/IGUucGFyZW50Tm9kZSAhPT0gdCAmJiAodC5pbm5lckhUTUwgPSBcIlwiLCB0LmFwcGVuZChlKSkgOiB0LnRleHRDb250ZW50ID0gZS50ZXh0Q29udGVudDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY29uZmlnLmh0bWwgPyAodGhpcy5fY29uZmlnLnNhbml0aXplICYmIChlID0gZHMoXHJcbiAgICAgICAgZSxcclxuICAgICAgICB0aGlzLl9jb25maWcuYWxsb3dMaXN0LFxyXG4gICAgICAgIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuXHJcbiAgICAgICkpLCB0LmlubmVySFRNTCA9IGUpIDogdC50ZXh0Q29udGVudCA9IGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFRpdGxlKCkge1xyXG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10d2Utb3JpZ2luYWwtdGl0bGVcIikgfHwgdGhpcy5fY29uZmlnLnRpdGxlO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHQpO1xyXG4gIH1cclxuICB1cGRhdGVBdHRhY2htZW50KHQpIHtcclxuICAgIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBcImVuZFwiIDogdCA9PT0gXCJsZWZ0XCIgPyBcInN0YXJ0XCIgOiB0O1xyXG4gIH1cclxuICAvLyBQcml2YXRlXHJcbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSB7XHJcbiAgICByZXR1cm4gZSB8fCB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoXHJcbiAgICAgIHQuZGVsZWdhdGVUYXJnZXQsXHJcbiAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcclxuICAgICk7XHJcbiAgfVxyXG4gIF9nZXRPZmZzZXQoKSB7XHJcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0LnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IE51bWJlci5wYXJzZUludChlLCAxMCkpIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gKGUpID0+IHQoZSwgdGhpcy5fZWxlbWVudCkgOiB0O1xyXG4gIH1cclxuICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQuY2FsbCh0aGlzLl9lbGVtZW50KSA6IHQ7XHJcbiAgfVxyXG4gIF9nZXRQb3BwZXJDb25maWcodCkge1xyXG4gICAgY29uc3QgZSA9IHtcclxuICAgICAgcGxhY2VtZW50OiB0LFxyXG4gICAgICBtb2RpZmllcnM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcclxuICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxyXG4gICAgICAgICAgZW5hYmxlZDogITAsXHJcbiAgICAgICAgICBwaGFzZTogXCJhZnRlcldyaXRlXCIsXHJcbiAgICAgICAgICBmbjogKHMpID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShzKVxyXG4gICAgICAgIH1cclxuICAgICAgXSxcclxuICAgICAgb25GaXJzdFVwZGF0ZTogKHMpID0+IHtcclxuICAgICAgICBzLm9wdGlvbnMucGxhY2VtZW50ICE9PSBzLnBsYWNlbWVudCAmJiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2Uocyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5lLFxyXG4gICAgICAuLi50eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xyXG4gICAgfTtcclxuICB9XHJcbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XHJcbiAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKFxyXG4gICAgICBgJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KHQpfWBcclxuICAgICk7XHJcbiAgfVxyXG4gIF9nZXRBdHRhY2htZW50KHQpIHtcclxuICAgIHJldHVybiBSYVt0LnRvVXBwZXJDYXNlKCldO1xyXG4gIH1cclxuICBfc2V0TGlzdGVuZXJzKCkge1xyXG4gICAgdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUpID0+IHtcclxuICAgICAgaWYgKGUgPT09IFwiY2xpY2tcIilcclxuICAgICAgICBkLm9uKFxyXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssXHJcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXHJcbiAgICAgICAgICAocykgPT4gdGhpcy50b2dnbGUocylcclxuICAgICAgICApO1xyXG4gICAgICBlbHNlIGlmIChlICE9PSBWYSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBlID09PSBqdCA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTiwgbiA9IGUgPT09IGp0ID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcclxuICAgICAgICBkLm9uKFxyXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgICAgIHMsXHJcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXHJcbiAgICAgICAgICAocikgPT4gdGhpcy5fZW50ZXIocilcclxuICAgICAgICApLCBkLm9uKFxyXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgICAgIG4sXHJcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXHJcbiAgICAgICAgICAocikgPT4gdGhpcy5fbGVhdmUocilcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgdGhpcy5fZWxlbWVudCAmJiB0aGlzLmhpZGUoKTtcclxuICAgIH0sIGQub24oXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChmcyksXHJcbiAgICAgIHBzLFxyXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyXHJcbiAgICApLCB0aGlzLl9jb25maWcuc2VsZWN0b3IgPyB0aGlzLl9jb25maWcgPSB7XHJcbiAgICAgIC4uLnRoaXMuX2NvbmZpZyxcclxuICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcclxuICAgICAgc2VsZWN0b3I6IFwiXCJcclxuICAgIH0gOiB0aGlzLl9maXhUaXRsZSgpO1xyXG4gIH1cclxuICBfZml4VGl0bGUoKSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSwgZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcclxuICAgICAgXCJkYXRhLXR3ZS1vcmlnaW5hbC10aXRsZVwiXHJcbiAgICApO1xyXG4gICAgKHQgfHwgZSAhPT0gXCJzdHJpbmdcIikgJiYgKHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS10d2Utb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgdCAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50ICYmIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0KSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKSk7XHJcbiAgfVxyXG4gIF9lbnRlcih0LCBlKSB7XHJcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNpblwiID8gRmUgOiBqdF0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhqZSkgfHwgZS5faG92ZXJTdGF0ZSA9PT0gQnQpIHtcclxuICAgICAgZS5faG92ZXJTdGF0ZSA9IEJ0O1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gQnQsICFlLl9jb25maWcuZGVsYXkgfHwgIWUuX2NvbmZpZy5kZWxheS5zaG93KSB7XHJcbiAgICAgIGUuc2hvdygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGUuX2hvdmVyU3RhdGUgPT09IEJ0ICYmIGUuc2hvdygpO1xyXG4gICAgfSwgZS5fY29uZmlnLmRlbGF5LnNob3cpO1xyXG4gIH1cclxuICBfbGVhdmUodCwgZSkge1xyXG4gICAgaWYgKGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbdC50eXBlID09PSBcImZvY3Vzb3V0XCIgPyBGZSA6IGp0XSA9IGUuX2VsZW1lbnQuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSksICFlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcclxuICAgICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IFVlLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuaGlkZSkge1xyXG4gICAgICAgIGUuaGlkZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgZS5faG92ZXJTdGF0ZSA9PT0gVWUgJiYgZS5oaWRlKCk7XHJcbiAgICAgIH0sIGUuX2NvbmZpZy5kZWxheS5oaWRlKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XHJcbiAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcilcclxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdF0pXHJcbiAgICAgICAgcmV0dXJuICEwO1xyXG4gICAgcmV0dXJuICExO1xyXG4gIH1cclxuICBfZ2V0Q29uZmlnKHQpIHtcclxuICAgIGNvbnN0IGUgPSBFLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKHMpID0+IHtcclxuICAgICAgJGEuaGFzKHMpICYmIGRlbGV0ZSBlW3NdO1xyXG4gICAgfSksIHQgPSB7XHJcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcclxuICAgICAgLi4uZSxcclxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XHJcbiAgICB9LCB0LmNvbnRhaW5lciA9IHQuY29udGFpbmVyID09PSAhMSA/IGRvY3VtZW50LmJvZHkgOiBydCh0LmNvbnRhaW5lciksIHR5cGVvZiB0LmRlbGF5ID09IFwibnVtYmVyXCIgJiYgKHQuZGVsYXkgPSB7XHJcbiAgICAgIHNob3c6IHQuZGVsYXksXHJcbiAgICAgIGhpZGU6IHQuZGVsYXlcclxuICAgIH0pLCB0eXBlb2YgdC50aXRsZSA9PSBcIm51bWJlclwiICYmICh0LnRpdGxlID0gdC50aXRsZS50b1N0cmluZygpKSwgdHlwZW9mIHQuY29udGVudCA9PSBcIm51bWJlclwiICYmICh0LmNvbnRlbnQgPSB0LmNvbnRlbnQudG9TdHJpbmcoKSksIFIodXMsIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0LnNhbml0aXplICYmICh0LnRlbXBsYXRlID0gZHMoXHJcbiAgICAgIHQudGVtcGxhdGUsXHJcbiAgICAgIHQuYWxsb3dMaXN0LFxyXG4gICAgICB0LnNhbml0aXplRm5cclxuICAgICkpLCB0O1xyXG4gIH1cclxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XHJcbiAgICBjb25zdCB0ID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5fY29uZmlnKVxyXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZV0gIT09IHRoaXMuX2NvbmZpZ1tlXSAmJiAodFtlXSA9IHRoaXMuX2NvbmZpZ1tlXSk7XHJcbiAgICByZXR1cm4gdDtcclxuICB9XHJcbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSBuZXcgUmVnRXhwKFxyXG4gICAgICBgKF58XFxcXHMpJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9XFxcXFMrYCxcclxuICAgICAgXCJnXCJcclxuICAgICksIHMgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLm1hdGNoKGUpO1xyXG4gICAgcyAhPT0gbnVsbCAmJiBzLmxlbmd0aCA+IDAgJiYgcy5tYXAoKG4pID0+IG4udHJpbSgpKS5mb3JFYWNoKChuKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpO1xyXG4gIH1cclxuICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcclxuICAgIHJldHVybiBMYTtcclxuICB9XHJcbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KSB7XHJcbiAgICBjb25zdCB7IHN0YXRlOiBlIH0gPSB0O1xyXG4gICAgZSAmJiAodGhpcy50aXAgPSBlLmVsZW1lbnRzLnBvcHBlciwgdGhpcy5fY2xlYW5UaXBDbGFzcygpLCB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudChlLnBsYWNlbWVudCkpKTtcclxuICB9XHJcbiAgX2Rpc3Bvc2VQb3BwZXIoKSB7XHJcbiAgICB0aGlzLl9wb3BwZXIgJiYgKHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHRoaXMuX3BvcHBlciA9IG51bGwpO1xyXG4gIH1cclxuICAvLyBTdGF0aWNcclxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBRdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuY29uc3QgV2EgPSBcInBvcG92ZXJcIiwgQmEgPSBcInR3ZS5wb3BvdmVyXCIsIHEgPSBgLiR7QmF9YCwgamEgPSBcInRlLXBvcG92ZXJcIiwgVWEgPSB7XHJcbiAgLi4uUXQuRGVmYXVsdCxcclxuICBwbGFjZW1lbnQ6IFwicmlnaHRcIixcclxuICBvZmZzZXQ6IFswLCA4XSxcclxuICB0cmlnZ2VyOiBcImNsaWNrXCIsXHJcbiAgY29udGVudDogXCJcIixcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPGRpdiBjbGFzcz1cIm9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGFic29sdXRlIHRvcC0wIGxlZnQtMCB6LVsxMDcwXSBibG9jayBtYXgtdy1bMjY3cHhdIGJyZWFrLXdvcmRzIGJnLXdoaXRlIGJnLWNsaXAtcGFkZGluZyBib3JkZXIgYm9yZGVyLW5ldXRyYWwtMTAwIHJvdW5kZWQtbGcgc2hhZG93LTIgdGV4dC1zbSBub3QtaXRhbGljIGZvbnQtbm9ybWFsIHRleHQtbGVmdCBuby11bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1hdXRvIG5vcm1hbC1jYXNlIGxlYWRpbmctNiB0cmFja2luZy1ub3JtYWwgYnJlYWstbm9ybWFsIHdoaXRlc3BhY2Utbm9ybWFsIGRhcms6Ym9yZGVyLXdoaXRlLzEwIGRhcms6Ymctc3VyZmFjZS1kYXJrIGRhcms6dGV4dC13aGl0ZSBkYXRhLVtwb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06aGlkZGVuXCIgcm9sZT1cInRvb2x0aXBcIj5cclxuICAgICAgPGgzIGRhdGEtdHdlLXBvcG92ZXItaGVhZGVyLXJlZiBjbGFzcz1cInB5LTIgcHgtNCBtYi0wIGJvcmRlci1iLTIgYm9yZGVyLW5ldXRyYWwtMTAwIHJvdW5kZWQtdC1sZyBmb250LW1lZGl1bSBlbXB0eTpoaWRkZW4gZGFyazpib3JkZXItd2hpdGUvMTBcIj48L2gzPlxyXG4gICAgICA8ZGl2IGRhdGEtdHdlLXBvcG92ZXItYm9keS1yZWYgY2xhc3M9XCJwLTQgdGV4dC1zdXJmYWNlIGRhcms6dGV4dC13aGl0ZVwiPjwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICBgXHJcbn0sIEZhID0ge1xyXG4gIC4uLlF0LkRlZmF1bHRUeXBlLFxyXG4gIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXHJcbn0sIFlhID0ge1xyXG4gIEhJREU6IGBoaWRlJHtxfWAsXHJcbiAgSElEREVOOiBgaGlkZGVuJHtxfWAsXHJcbiAgU0hPVzogYHNob3cke3F9YCxcclxuICBTSE9XTjogYHNob3duJHtxfWAsXHJcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7cX1gLFxyXG4gIENMSUNLOiBgY2xpY2ske3F9YCxcclxuICBGT0NVU0lOOiBgZm9jdXNpbiR7cX1gLFxyXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke3F9YCxcclxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7cX1gLFxyXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtxfWBcclxufSwgS2EgPSBcIltkYXRhLXR3ZS1wb3BvdmVyLWhlYWRlci1yZWZdXCIsIHphID0gXCJbZGF0YS10d2UtcG9wb3Zlci1ib2R5LXJlZl1cIjtcclxuY2xhc3MgTm4gZXh0ZW5kcyBRdCB7XHJcbiAgLy8gR2V0dGVyc1xyXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgIHJldHVybiBVYTtcclxuICB9XHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIFdhO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xyXG4gICAgcmV0dXJuIFlhO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgcmV0dXJuIEZhO1xyXG4gIH1cclxuICAvLyBPdmVycmlkZXNcclxuICBpc1dpdGhDb250ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XHJcbiAgfVxyXG4gIHNldENvbnRlbnQodCkge1xyXG4gICAgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuZ2V0VGl0bGUoKSwgS2EpLCB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5fZ2V0Q29udGVudCgpLCB6YSk7XHJcbiAgfVxyXG4gIC8vIFByaXZhdGVcclxuICBfZ2V0Q29udGVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XHJcbiAgfVxyXG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xyXG4gICAgcmV0dXJuIGphO1xyXG4gIH1cclxuICAvLyBTdGF0aWNcclxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBObi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuY29uc3QgWWUgPSBcInNjcm9sbHNweVwiLCBxYSA9IFwidHdlLnNjcm9sbHNweVwiLCBDaSA9IGAuJHtxYX1gLCBfcyA9IHtcclxuICBvZmZzZXQ6IDEwLFxyXG4gIG1ldGhvZDogXCJhdXRvXCIsXHJcbiAgdGFyZ2V0OiBcIlwiXHJcbn0sIFhhID0ge1xyXG4gIG9mZnNldDogXCJudW1iZXJcIixcclxuICBtZXRob2Q6IFwic3RyaW5nXCIsXHJcbiAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxyXG59LCBHYSA9IHtcclxuICBhY3RpdmU6IFwiIXRleHQtcHJpbWFyeSBmb250LXNlbWlib2xkIGJvcmRlci1zLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1wcmltYXJ5XCJcclxufSwgUWEgPSB7XHJcbiAgYWN0aXZlOiBcInN0cmluZ1wiXHJcbn0sIEtlID0gYGFjdGl2YXRlJHtDaX1gLCBaYSA9IGBzY3JvbGwke0NpfWAsIEt0ID0gXCJkYXRhLXR3ZS1uYXYtbGluay1hY3RpdmVcIiwgU24gPSBcImRhdGEtdHdlLWNvbGxhcHNpYmxlLXNjcm9sbHNweS1yZWZcIiwgTG4gPSBcIltkYXRhLXR3ZS1kcm9wZG93bi1pdGVtLXJlZl1cIiwgSmEgPSBcIltkYXRhLXR3ZS1uYXYtbGlzdC1yZWZdXCIsIG9pID0gXCJbZGF0YS10d2UtbmF2LWxpbmstcmVmXVwiLCB0bCA9IFwiW2RhdGEtdHdlLW5hdi1pdGVtLXJlZl1cIiwgJG4gPSBcIltkYXRhLXR3ZS1saXN0LWdyb3VwLWl0ZW0tcmVmXVwiLCB6ZSA9IGAke29pfSwgJHskbn0sICR7TG59YCwgZWwgPSBcIltkYXRhLXR3ZS1kcm9wZG93bi1yZWZdXCIsIGlsID0gXCJbZGF0YS10d2UtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgZ3MgPSBgWyR7U259XWAsIHNsID0gYFske0t0fV1gLCBxZSA9IFwidWxcIiwgbmwgPSBcIm1heE9mZnNldFwiLCBtcyA9IFwicG9zaXRpb25cIjtcclxuY2xhc3MgSW4gZXh0ZW5kcyB0dCB7XHJcbiAgY29uc3RydWN0b3IodCwgZSwgcykge1xyXG4gICAgc3VwZXIodCksIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnRhZ05hbWUgPT09IFwiQk9EWVwiID8gd2luZG93IDogdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhzKSwgdGhpcy5fb2Zmc2V0cyA9IFtdLCB0aGlzLl90YXJnZXRzID0gW10sIHRoaXMuX2NvbGxhcHNpYmxlcyA9IFtdLCB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwLCBkLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIFphLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpLCB0aGlzLnJlZnJlc2goKSwgdGhpcy5fcHJvY2VzcygpLCB0aGlzLl9iaW5kQWN0aXZhdGVFdmVudCgpLCB0aGlzLl9nZXRDb2xsYXBzaWJsZXMoKSwgdGhpcy5fY29sbGFwc2libGVzLmxlbmd0aCAhPT0gMCAmJiAodGhpcy5fc2hvd1N1YnNlY3Rpb24oKSwgdGhpcy5faGlkZVN1YnNlY3Rpb24oKSk7XHJcbiAgfVxyXG4gIC8vIEdldHRlcnNcclxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICByZXR1cm4gX3M7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgIHJldHVybiBZZTtcclxuICB9XHJcbiAgLy8gUHVibGljXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIGNvbnN0IHQgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IG5sIDogbXMsIGUgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSBcImF1dG9cIiA/IHQgOiB0aGlzLl9jb25maWcubWV0aG9kLCBzID0gZSA9PT0gbXMgPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XHJcbiAgICB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksIGguZmluZChcclxuICAgICAgemUsXHJcbiAgICAgIHRoaXMuX2NvbmZpZy50YXJnZXRcclxuICAgICkubWFwKChyKSA9PiB7XHJcbiAgICAgIGNvbnN0IG8gPSBjaShyKSwgYSA9IG8gPyBoLmZpbmRPbmUobykgOiBudWxsO1xyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIGNvbnN0IGwgPSBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmIChsLndpZHRoIHx8IGwuaGVpZ2h0KVxyXG4gICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgRVtlXShhKS50b3AgKyBzLFxyXG4gICAgICAgICAgICBvXHJcbiAgICAgICAgICBdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSkuZmlsdGVyKChyKSA9PiByKS5zb3J0KChyLCBvKSA9PiByWzBdIC0gb1swXSkuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICB0aGlzLl9vZmZzZXRzLnB1c2goclswXSksIHRoaXMuX3RhcmdldHMucHVzaChyWzFdKTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgZC5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgQ2kpLCBkLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCBLZSksIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbiAgLy8gUHJpdmF0ZVxyXG4gIF9nZXRDb25maWcodCkge1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLl9zLFxyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxyXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQgPyB0IDoge31cclxuICAgIH0sIHQudGFyZ2V0ID0gcnQodC50YXJnZXQpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgUihZZSwgdCwgWGEpLCB0O1xyXG4gIH1cclxuICBfZ2V0Q2xhc3Nlcyh0KSB7XHJcbiAgICBjb25zdCBlID0gRS5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLkdhLFxyXG4gICAgICAuLi5lLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCBSKFllLCB0LCBRYSksIHQ7XHJcbiAgfVxyXG4gIF9nZXRTY3JvbGxUb3AoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gIH1cclxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KFxyXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcclxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxyXG4gICAgKTtcclxuICB9XHJcbiAgX2dldE9mZnNldEhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcclxuICB9XHJcbiAgX3Byb2Nlc3MoKSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgKyB0aGlzLl9jb25maWcub2Zmc2V0LCBlID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksIHMgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgZSAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpO1xyXG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gZSAmJiB0aGlzLnJlZnJlc2goKSwgdCA+PSBzKSB7XHJcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gbiAmJiB0aGlzLl9hY3RpdmF0ZShuKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAmJiB0IDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9jbGVhcigpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBuID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IG4tLTsgKVxyXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbbl0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW25dICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tuICsgMV0gPiBcInVcIiB8fCB0IDwgdGhpcy5fb2Zmc2V0c1tuICsgMV0pICYmIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbbl0pO1xyXG4gIH1cclxuICBfYWN0aXZhdGUodCkge1xyXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdCwgdGhpcy5fY2xlYXIoKTtcclxuICAgIGNvbnN0IGUgPSB6ZS5zcGxpdChcIixcIikubWFwKFxyXG4gICAgICAobikgPT4gYCR7bn1bZGF0YS10d2UtdGFyZ2V0PVwiJHt0fVwiXSwke259W2hyZWY9XCIke3R9XCJdYFxyXG4gICAgKSwgcyA9IGguZmluZE9uZShlLmpvaW4oXCIsXCIpLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcclxuICAgIHMuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBzLnNldEF0dHJpYnV0ZShLdCwgXCJcIiksIHMuZ2V0QXR0cmlidXRlKExuKSA/IGguZmluZE9uZShcclxuICAgICAgaWwsXHJcbiAgICAgIHMuY2xvc2VzdChlbClcclxuICAgICkuY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpIDogaC5wYXJlbnRzKHMsIEphKS5mb3JFYWNoKFxyXG4gICAgICAobikgPT4ge1xyXG4gICAgICAgIGgucHJldihcclxuICAgICAgICAgIG4sXHJcbiAgICAgICAgICBgJHtvaX0sICR7JG59YFxyXG4gICAgICAgICkuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICAgICAgci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSksIHIuc2V0QXR0cmlidXRlKEt0LCBcIlwiKTtcclxuICAgICAgICB9KSwgaC5wcmV2KG4sIHRsKS5mb3JFYWNoKFxyXG4gICAgICAgICAgKHIpID0+IHtcclxuICAgICAgICAgICAgaC5jaGlsZHJlbihyLCBvaSkuZm9yRWFjaChcclxuICAgICAgICAgICAgICAobykgPT4gby5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICApLCBkLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgS2UsIHtcclxuICAgICAgcmVsYXRlZFRhcmdldDogdFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9jbGVhcigpIHtcclxuICAgIGguZmluZCh6ZSwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKFxyXG4gICAgICAodCkgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxyXG4gICAgKS5mb3JFYWNoKCh0KSA9PiB7XHJcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCB0LnJlbW92ZUF0dHJpYnV0ZShLdCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX2hpZGUodCkge1xyXG4gICAgY29uc3QgZSA9IGguZmluZE9uZShcclxuICAgICAgcWUsXHJcbiAgICAgIHQucGFyZW50Tm9kZVxyXG4gICAgKTtcclxuICAgIGUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCBlLnN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XHJcbiAgfVxyXG4gIF9zaG93KHQsIGUpIHtcclxuICAgIHQuc3R5bGUuaGVpZ2h0ID0gZTtcclxuICB9XHJcbiAgX2dldENvbGxhcHNpYmxlcygpIHtcclxuICAgIGNvbnN0IHQgPSBoLmZpbmQoXHJcbiAgICAgIGdzXHJcbiAgICApO1xyXG4gICAgdCAmJiB0LmZvckVhY2goKGUpID0+IHtcclxuICAgICAgY29uc3QgcyA9IGUucGFyZW50Tm9kZSwgbiA9IGguZmluZE9uZShxZSwgcyksIHIgPSBuLm9mZnNldEhlaWdodCB8fCBuLnNjcm9sbEhlaWdodDtcclxuICAgICAgdGhpcy5fY29sbGFwc2libGVzLnB1c2goe1xyXG4gICAgICAgIGVsZW1lbnQ6IG4sXHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLFxyXG4gICAgICAgIGhlaWdodDogYCR7cn1weGBcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3Nob3dTdWJzZWN0aW9uKCkge1xyXG4gICAgaC5maW5kKHNsKS5maWx0ZXIoKHMpID0+IHMuaGFzQXR0cmlidXRlKFNuKSkuZm9yRWFjaCgocykgPT4ge1xyXG4gICAgICBjb25zdCBuID0gaC5maW5kT25lKHFlLCBzLnBhcmVudE5vZGUpLCByID0gdGhpcy5fY29sbGFwc2libGVzLmZpbmQoKG8pID0+IG8ucmVsYXRlZFRhcmdldCA9IHMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkuaGVpZ2h0O1xyXG4gICAgICB0aGlzLl9zaG93KG4sIHIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9oaWRlU3Vic2VjdGlvbigpIHtcclxuICAgIGguZmluZChcclxuICAgICAgZ3NcclxuICAgICkuZmlsdGVyKChlKSA9PiBlLmhhc0F0dHJpYnV0ZShLdCkgPT09ICExKS5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgIHRoaXMuX2hpZGUoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX2JpbmRBY3RpdmF0ZUV2ZW50KCkge1xyXG4gICAgZC5vbih0aGlzLl9lbGVtZW50LCBLZSwgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9zaG93U3Vic2VjdGlvbigpLCB0aGlzLl9oaWRlU3Vic2VjdGlvbigpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIFN0YXRpY1xyXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgY29uc3QgZSA9IEluLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XHJcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcclxuICAgICAgICBlW3RdKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5jb25zdCBFcyA9IFwidGFiXCIsIHJsID0gXCJ0d2UudGFiXCIsIHllID0gYC4ke3JsfWAsIG9sID0gYGhpZGUke3llfWAsIGFsID0gYGhpZGRlbiR7eWV9YCwgbGwgPSBgc2hvdyR7eWV9YCwgY2wgPSBgc2hvd24ke3llfWAsIGRsID0gXCJkYXRhLXR3ZS1kcm9wZG93bi1tZW51LXJlZlwiLCBPdCA9IFwiZGF0YS10d2UtdGFiLWFjdGl2ZVwiLCBnZSA9IFwiZGF0YS10d2UtbmF2LWFjdGl2ZVwiLCB1bCA9IFwiW2RhdGEtdHdlLWRyb3Bkb3duLXJlZl1cIiwgaGwgPSBcIltkYXRhLXR3ZS1uYXYtcmVmXVwiLCB2cyA9IGBbJHtPdH1dYCwgZmwgPSBgWyR7Z2V9XWAsIGJzID0gXCI6c2NvcGUgPiBsaSA+IC5hY3RpdmVcIiwgcGwgPSBcIltkYXRhLXR3ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBfbCA9IFwiOnNjb3BlID4gW2RhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10d2UtZHJvcGRvd24tc2hvd11cIiwgZ2wgPSB7XHJcbiAgc2hvdzogXCJvcGFjaXR5LTEwMFwiLFxyXG4gIGhpZGU6IFwib3BhY2l0eS0wXCJcclxufSwgbWwgPSB7XHJcbiAgc2hvdzogXCJzdHJpbmdcIixcclxuICBoaWRlOiBcInN0cmluZ1wiXHJcbn07XHJcbmNsYXNzIFJuIGV4dGVuZHMgdHQge1xyXG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcclxuICAgIHN1cGVyKHQpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhlKTtcclxuICB9XHJcbiAgLy8gR2V0dGVyc1xyXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgIHJldHVybiBFcztcclxuICB9XHJcbiAgLy8gUHVibGljXHJcbiAgc2hvdygpIHtcclxuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShnZSkgPT09IFwiXCIpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGxldCB0O1xyXG4gICAgY29uc3QgZSA9IG50KHRoaXMuX2VsZW1lbnQpLCBzID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KGhsKSwgbiA9IGguZmluZE9uZShcclxuICAgICAgZmwsXHJcbiAgICAgIHNcclxuICAgICk7XHJcbiAgICBpZiAocykge1xyXG4gICAgICBjb25zdCBsID0gcy5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IHMubm9kZU5hbWUgPT09IFwiT0xcIiA/IGJzIDogdnM7XHJcbiAgICAgIHQgPSBoLmZpbmQobCwgcyksIHQgPSB0W3QubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCByID0gdCA/IGQudHJpZ2dlcih0LCBvbCwge1xyXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XHJcbiAgICB9KSA6IG51bGw7XHJcbiAgICBpZiAoZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGxsLCB7XHJcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcclxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgciAhPT0gbnVsbCAmJiByLmRlZmF1bHRQcmV2ZW50ZWQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIHRoaXMuX2FjdGl2YXRlKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBzLFxyXG4gICAgICBudWxsLFxyXG4gICAgICBuLFxyXG4gICAgICB0aGlzLl9lbGVtZW50XHJcbiAgICApO1xyXG4gICAgY29uc3QgYSA9ICgpID0+IHtcclxuICAgICAgZC50cmlnZ2VyKHQsIGFsLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxyXG4gICAgICB9KSwgZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGNsLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBlID8gdGhpcy5fYWN0aXZhdGUoXHJcbiAgICAgIGUsXHJcbiAgICAgIGUucGFyZW50Tm9kZSxcclxuICAgICAgYSxcclxuICAgICAgbixcclxuICAgICAgdGhpcy5fZWxlbWVudFxyXG4gICAgKSA6IGEoKTtcclxuICB9XHJcbiAgLy8gUHJpdmF0ZVxyXG4gIF9nZXRDbGFzc2VzKHQpIHtcclxuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XHJcbiAgICByZXR1cm4gdCA9IHtcclxuICAgICAgLi4uZ2wsXHJcbiAgICAgIC4uLmUsXHJcbiAgICAgIC4uLnRcclxuICAgIH0sIFIoRXMsIHQsIG1sKSwgdDtcclxuICB9XHJcbiAgX2FjdGl2YXRlKHQsIGUsIHMsIG4sIHIpIHtcclxuICAgIGNvbnN0IGEgPSAoZSAmJiAoZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGUubm9kZU5hbWUgPT09IFwiT0xcIikgPyBoLmZpbmQoYnMsIGUpIDogaC5jaGlsZHJlbihlLCB2cykpWzBdLCBsID0gcyAmJiBhICYmIGEuaGFzQXR0cmlidXRlKE90KSwgdSA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcclxuICAgICAgdCxcclxuICAgICAgYSxcclxuICAgICAgcyxcclxuICAgICAgbixcclxuICAgICAgclxyXG4gICAgKTtcclxuICAgIGEgJiYgbCA/IChFLnJlbW92ZUNsYXNzKGEsIHRoaXMuX2NsYXNzZXMuc2hvdyksIEUuYWRkQ2xhc3MoYSwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgdGhpcy5fcXVldWVDYWxsYmFjayh1LCB0LCAhMCkpIDogdSgpO1xyXG4gIH1cclxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIHMsIG4sIHIpIHtcclxuICAgIGlmIChlICYmIG4pIHtcclxuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUoT3QpLCBuLnJlbW92ZUF0dHJpYnV0ZShnZSk7XHJcbiAgICAgIGNvbnN0IGEgPSBoLmZpbmRPbmUoXHJcbiAgICAgICAgX2wsXHJcbiAgICAgICAgZS5wYXJlbnROb2RlXHJcbiAgICAgICk7XHJcbiAgICAgIGEgJiYgYS5yZW1vdmVBdHRyaWJ1dGUoT3QpLCBlLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKTtcclxuICAgIH1cclxuICAgIHQuc2V0QXR0cmlidXRlKE90LCBcIlwiKSwgci5zZXRBdHRyaWJ1dGUoZ2UsIFwiXCIpLCB0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgWHQodCksIHQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuaGlkZSkgJiYgKEUucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgRS5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnNob3cpKTtcclxuICAgIGxldCBvID0gdC5wYXJlbnROb2RlO1xyXG4gICAgaWYgKG8gJiYgby5ub2RlTmFtZSA9PT0gXCJMSVwiICYmIChvID0gby5wYXJlbnROb2RlKSwgbyAmJiBvLmhhc0F0dHJpYnV0ZShkbCkpIHtcclxuICAgICAgY29uc3QgYSA9IHQuY2xvc2VzdCh1bCk7XHJcbiAgICAgIGEgJiYgaC5maW5kKHBsLCBhKS5mb3JFYWNoKFxyXG4gICAgICAgIChsKSA9PiBsLnNldEF0dHJpYnV0ZShPdCwgXCJcIilcclxuICAgICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKTtcclxuICAgIH1cclxuICAgIHMgJiYgcygpO1xyXG4gIH1cclxuICAvLyBTdGF0aWNcclxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBSbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xyXG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XHJcbiAgICAgICAgZVt0XSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuKCgpID0+IHtcclxuICB2YXIgaSA9IHsgNDU0OiAocywgbiwgcikgPT4ge1xyXG4gICAgci5kKG4sIHsgWjogKCkgPT4gbCB9KTtcclxuICAgIHZhciBvID0gcig2NDUpLCBhID0gci5uKG8pKCkoZnVuY3Rpb24odSkge1xyXG4gICAgICByZXR1cm4gdVsxXTtcclxuICAgIH0pO1xyXG4gICAgYS5wdXNoKFtzLmlkLCBcIklOUFVUOi13ZWJraXQtYXV0b2ZpbGwsU0VMRUNUOi13ZWJraXQtYXV0b2ZpbGwsVEVYVEFSRUE6LXdlYmtpdC1hdXRvZmlsbHthbmltYXRpb24tbmFtZTpvbmF1dG9maWxsc3RhcnR9SU5QVVQ6bm90KDotd2Via2l0LWF1dG9maWxsKSxTRUxFQ1Q6bm90KDotd2Via2l0LWF1dG9maWxsKSxURVhUQVJFQTpub3QoOi13ZWJraXQtYXV0b2ZpbGwpe2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxjYW5jZWx9QGtleWZyYW1lcyBvbmF1dG9maWxsc3RhcnR7fUBrZXlmcmFtZXMgb25hdXRvZmlsbGNhbmNlbHt9XCIsIFwiXCJdKTtcclxuICAgIGNvbnN0IGwgPSBhO1xyXG4gIH0sIDY0NTogKHMpID0+IHtcclxuICAgIHMuZXhwb3J0cyA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgcmV0dXJuIHIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obykge1xyXG4gICAgICAgICAgdmFyIGEgPSBuKG8pO1xyXG4gICAgICAgICAgcmV0dXJuIG9bMl0gPyBcIkBtZWRpYSBcIi5jb25jYXQob1syXSwgXCIge1wiKS5jb25jYXQoYSwgXCJ9XCIpIDogYTtcclxuICAgICAgICB9KS5qb2luKFwiXCIpO1xyXG4gICAgICB9LCByLmkgPSBmdW5jdGlvbihvLCBhLCBsKSB7XHJcbiAgICAgICAgdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiAmJiAobyA9IFtbbnVsbCwgbywgXCJcIl1dKTtcclxuICAgICAgICB2YXIgdSA9IHt9O1xyXG4gICAgICAgIGlmIChsKVxyXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0aGlzLmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gdGhpc1tjXVswXTtcclxuICAgICAgICAgICAgZiAhPSBudWxsICYmICh1W2ZdID0gITApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgby5sZW5ndGg7IHYrKykge1xyXG4gICAgICAgICAgdmFyIGcgPSBbXS5jb25jYXQob1t2XSk7XHJcbiAgICAgICAgICBsICYmIHVbZ1swXV0gfHwgKGEgJiYgKGdbMl0gPyBnWzJdID0gXCJcIi5jb25jYXQoYSwgXCIgYW5kIFwiKS5jb25jYXQoZ1syXSkgOiBnWzJdID0gYSksIHIucHVzaChnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCByO1xyXG4gICAgfTtcclxuICB9LCA4MTA6ICgpID0+IHtcclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgdmFyIHMgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwidGVzdFwiLCB7IGNhbmNlbGFibGU6ICEwIH0pO1xyXG4gICAgICAgICAgaWYgKHMucHJldmVudERlZmF1bHQoKSwgcy5kZWZhdWx0UHJldmVudGVkICE9PSAhMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHByZXZlbnQgZGVmYXVsdFwiKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIHZhciBuID0gZnVuY3Rpb24obywgYSkge1xyXG4gICAgICAgICAgICB2YXIgbCwgdTtcclxuICAgICAgICAgICAgcmV0dXJuIChhID0gYSB8fCB7fSkuYnViYmxlcyA9ICEhYS5idWJibGVzLCBhLmNhbmNlbGFibGUgPSAhIWEuY2FuY2VsYWJsZSwgKGwgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQobywgYS5idWJibGVzLCBhLmNhbmNlbGFibGUsIGEuZGV0YWlsKSwgdSA9IGwucHJldmVudERlZmF1bHQsIGwucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICB1LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmV2ZW50ZWRcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBsO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG4ucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZSwgd2luZG93LkN1c3RvbUV2ZW50ID0gbjtcclxuICAgICAgICB9XHJcbiAgICB9KSgpO1xyXG4gIH0sIDM3OTogKHMsIG4sIHIpID0+IHtcclxuICAgIHZhciBvLCBhID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBtID0ge307XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgaWYgKG1bcF0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgdmFyIF8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHApO1xyXG4gICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBfIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIF8gPSBfLmNvbnRlbnREb2N1bWVudC5oZWFkO1xyXG4gICAgICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgICBfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgbVtwXSA9IF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtW3BdO1xyXG4gICAgICB9O1xyXG4gICAgfSgpLCBsID0gW107XHJcbiAgICBmdW5jdGlvbiB1KG0pIHtcclxuICAgICAgZm9yICh2YXIgcCA9IC0xLCBfID0gMDsgXyA8IGwubGVuZ3RoOyBfKyspXHJcbiAgICAgICAgaWYgKGxbX10uaWRlbnRpZmllciA9PT0gbSkge1xyXG4gICAgICAgICAgcCA9IF87XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYyhtLCBwKSB7XHJcbiAgICAgIGZvciAodmFyIF8gPSB7fSwgYiA9IFtdLCB3ID0gMDsgdyA8IG0ubGVuZ3RoOyB3KyspIHtcclxuICAgICAgICB2YXIgQyA9IG1bd10sIHkgPSBwLmJhc2UgPyBDWzBdICsgcC5iYXNlIDogQ1swXSwgTiA9IF9beV0gfHwgMCwgUyA9IFwiXCIuY29uY2F0KHksIFwiIFwiKS5jb25jYXQoTik7XHJcbiAgICAgICAgX1t5XSA9IE4gKyAxO1xyXG4gICAgICAgIHZhciB4ID0gdShTKSwgSSA9IHsgY3NzOiBDWzFdLCBtZWRpYTogQ1syXSwgc291cmNlTWFwOiBDWzNdIH07XHJcbiAgICAgICAgeCAhPT0gLTEgPyAobFt4XS5yZWZlcmVuY2VzKyssIGxbeF0udXBkYXRlcihJKSkgOiBsLnB1c2goeyBpZGVudGlmaWVyOiBTLCB1cGRhdGVyOiBMKEksIHApLCByZWZlcmVuY2VzOiAxIH0pLCBiLnB1c2goUyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmKG0pIHtcclxuICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksIF8gPSBtLmF0dHJpYnV0ZXMgfHwge307XHJcbiAgICAgIGlmIChfLm5vbmNlID09PSB2b2lkIDApIHtcclxuICAgICAgICB2YXIgYiA9IHIubmM7XHJcbiAgICAgICAgYiAmJiAoXy5ub25jZSA9IGIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhfKS5mb3JFYWNoKGZ1bmN0aW9uKEMpIHtcclxuICAgICAgICBwLnNldEF0dHJpYnV0ZShDLCBfW0NdKTtcclxuICAgICAgfSksIHR5cGVvZiBtLmluc2VydCA9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgbS5pbnNlcnQocCk7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciB3ID0gYShtLmluc2VydCB8fCBcImhlYWRcIik7XHJcbiAgICAgICAgaWYgKCF3KVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcclxuICAgICAgICB3LmFwcGVuZENoaWxkKHApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgdmFyIHYsIGcgPSAodiA9IFtdLCBmdW5jdGlvbihtLCBwKSB7XHJcbiAgICAgIHJldHVybiB2W21dID0gcCwgdi5maWx0ZXIoQm9vbGVhbikuam9pbihgXHJcbmApO1xyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBPKG0sIHAsIF8sIGIpIHtcclxuICAgICAgdmFyIHcgPSBfID8gXCJcIiA6IGIubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQoYi5tZWRpYSwgXCIge1wiKS5jb25jYXQoYi5jc3MsIFwifVwiKSA6IGIuY3NzO1xyXG4gICAgICBpZiAobS5zdHlsZVNoZWV0KVxyXG4gICAgICAgIG0uc3R5bGVTaGVldC5jc3NUZXh0ID0gZyhwLCB3KTtcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIEMgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh3KSwgeSA9IG0uY2hpbGROb2RlcztcclxuICAgICAgICB5W3BdICYmIG0ucmVtb3ZlQ2hpbGQoeVtwXSksIHkubGVuZ3RoID8gbS5pbnNlcnRCZWZvcmUoQywgeVtwXSkgOiBtLmFwcGVuZENoaWxkKEMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBUKG0sIHAsIF8pIHtcclxuICAgICAgdmFyIGIgPSBfLmNzcywgdyA9IF8ubWVkaWEsIEMgPSBfLnNvdXJjZU1hcDtcclxuICAgICAgaWYgKHcgPyBtLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIHcpIDogbS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKSwgQyAmJiB0eXBlb2YgYnRvYSA8IFwidVwiICYmIChiICs9IGBcclxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxgLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShDKSkpKSwgXCIgKi9cIikpLCBtLnN0eWxlU2hlZXQpXHJcbiAgICAgICAgbS5zdHlsZVNoZWV0LmNzc1RleHQgPSBiO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKDsgbS5maXJzdENoaWxkOyApXHJcbiAgICAgICAgICBtLnJlbW92ZUNoaWxkKG0uZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBBID0gbnVsbCwgRCA9IDA7XHJcbiAgICBmdW5jdGlvbiBMKG0sIHApIHtcclxuICAgICAgdmFyIF8sIGIsIHc7XHJcbiAgICAgIGlmIChwLnNpbmdsZXRvbikge1xyXG4gICAgICAgIHZhciBDID0gRCsrO1xyXG4gICAgICAgIF8gPSBBIHx8IChBID0gZihwKSksIGIgPSBPLmJpbmQobnVsbCwgXywgQywgITEpLCB3ID0gTy5iaW5kKG51bGwsIF8sIEMsICEwKTtcclxuICAgICAgfSBlbHNlXHJcbiAgICAgICAgXyA9IGYocCksIGIgPSBULmJpbmQobnVsbCwgXywgcCksIHcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIChmdW5jdGlvbih5KSB7XHJcbiAgICAgICAgICAgIGlmICh5LnBhcmVudE5vZGUgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xyXG4gICAgICAgICAgICB5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeSk7XHJcbiAgICAgICAgICB9KShfKTtcclxuICAgICAgICB9O1xyXG4gICAgICByZXR1cm4gYihtKSwgZnVuY3Rpb24oeSkge1xyXG4gICAgICAgIGlmICh5KSB7XHJcbiAgICAgICAgICBpZiAoeS5jc3MgPT09IG0uY3NzICYmIHkubWVkaWEgPT09IG0ubWVkaWEgJiYgeS5zb3VyY2VNYXAgPT09IG0uc291cmNlTWFwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBiKG0gPSB5KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIHcoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHMuZXhwb3J0cyA9IGZ1bmN0aW9uKG0sIHApIHtcclxuICAgICAgKHAgPSBwIHx8IHt9KS5zaW5nbGV0b24gfHwgdHlwZW9mIHAuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChwLnNpbmdsZXRvbiA9IChvID09PSB2b2lkIDAgJiYgKG8gPSAhISh3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYikpLCBvKSk7XHJcbiAgICAgIHZhciBfID0gYyhtID0gbSB8fCBbXSwgcCk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgaWYgKGIgPSBiIHx8IFtdLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYikgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xyXG4gICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCBfLmxlbmd0aDsgdysrKSB7XHJcbiAgICAgICAgICAgIHZhciBDID0gdShfW3ddKTtcclxuICAgICAgICAgICAgbFtDXS5yZWZlcmVuY2VzLS07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmb3IgKHZhciB5ID0gYyhiLCBwKSwgTiA9IDA7IE4gPCBfLmxlbmd0aDsgTisrKSB7XHJcbiAgICAgICAgICAgIHZhciBTID0gdShfW05dKTtcclxuICAgICAgICAgICAgbFtTXS5yZWZlcmVuY2VzID09PSAwICYmIChsW1NdLnVwZGF0ZXIoKSwgbC5zcGxpY2UoUywgMSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXyA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9IH0sIHQgPSB7fTtcclxuICBmdW5jdGlvbiBlKHMpIHtcclxuICAgIHZhciBuID0gdFtzXTtcclxuICAgIGlmIChuICE9PSB2b2lkIDApXHJcbiAgICAgIHJldHVybiBuLmV4cG9ydHM7XHJcbiAgICB2YXIgciA9IHRbc10gPSB7IGlkOiBzLCBleHBvcnRzOiB7fSB9O1xyXG4gICAgcmV0dXJuIGlbc10ociwgci5leHBvcnRzLCBlKSwgci5leHBvcnRzO1xyXG4gIH1cclxuICBlLm4gPSAocykgPT4ge1xyXG4gICAgdmFyIG4gPSBzICYmIHMuX19lc01vZHVsZSA/ICgpID0+IHMuZGVmYXVsdCA6ICgpID0+IHM7XHJcbiAgICByZXR1cm4gZS5kKG4sIHsgYTogbiB9KSwgbjtcclxuICB9LCBlLmQgPSAocywgbikgPT4ge1xyXG4gICAgZm9yICh2YXIgciBpbiBuKVxyXG4gICAgICBlLm8obiwgcikgJiYgIWUubyhzLCByKSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBuW3JdIH0pO1xyXG4gIH0sIGUubyA9IChzLCBuKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgbiksICgoKSA9PiB7XHJcbiAgICB2YXIgcyA9IGUoMzc5KSwgbiA9IGUubihzKSwgciA9IGUoNDU0KTtcclxuICAgIGZ1bmN0aW9uIG8obCkge1xyXG4gICAgICBpZiAoIWwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSkge1xyXG4gICAgICAgIGwuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiLCBcIlwiKTtcclxuICAgICAgICB2YXIgdSA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoXCJvbmF1dG9jb21wbGV0ZVwiLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgZGV0YWlsOiBudWxsIH0pO1xyXG4gICAgICAgIGwuZGlzcGF0Y2hFdmVudCh1KSB8fCAobC52YWx1ZSA9IFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhKGwpIHtcclxuICAgICAgbC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpICYmIChsLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiksIGwuZGlzcGF0Y2hFdmVudChuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwib25hdXRvY29tcGxldGVcIiwgeyBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITEsIGRldGFpbDogbnVsbCB9KSkpO1xyXG4gICAgfVxyXG4gICAgbigpKHIuWiwgeyBpbnNlcnQ6IFwiaGVhZFwiLCBzaW5nbGV0b246ICExIH0pLCByLloubG9jYWxzLCBlKDgxMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBmdW5jdGlvbihsKSB7XHJcbiAgICAgIGwuYW5pbWF0aW9uTmFtZSA9PT0gXCJvbmF1dG9maWxsc3RhcnRcIiA/IG8obC50YXJnZXQpIDogYShsLnRhcmdldCk7XHJcbiAgICB9LCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbihsKSB7XHJcbiAgICAgIGwuaW5wdXRUeXBlICE9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIFwiZGF0YVwiIGluIGwgPyBhKGwudGFyZ2V0KSA6IG8obC50YXJnZXQpO1xyXG4gICAgfSwgITApO1xyXG4gIH0pKCk7XHJcbn0pKCk7XHJcbmNvbnN0IFhlID0gXCJpbnB1dFwiLCBvZSA9IFwidHdlLmlucHV0XCIsIHhuID0gXCJkYXRhLXR3ZS1pbnB1dC13cmFwcGVyLWluaXRcIiwga24gPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLXJlZlwiLCBQbiA9IFwiZGF0YS10d2UtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgTW4gPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLW1pZGRsZS1yZWZcIiwgRWwgPSBcImRhdGEtdHdlLWlucHV0LW5vdGNoLXRyYWlsaW5nLXJlZlwiLCB2bCA9IFwiZGF0YS10d2UtaW5wdXQtaGVscGVyLXJlZlwiLCBibCA9IFwiZGF0YS10d2UtaW5wdXQtcGxhY2Vob2xkZXItYWN0aXZlXCIsIHN0ID0gXCJkYXRhLXR3ZS1pbnB1dC1zdGF0ZS1hY3RpdmVcIiwgd3MgPSBcImRhdGEtdHdlLWlucHV0LWZvY3VzZWRcIiwgVHMgPSBcImRhdGEtdHdlLWlucHV0LWZvcm0tY291bnRlclwiLCBhZSA9IGBbJHt4bn1dIGlucHV0YCwgbGUgPSBgWyR7eG59XSB0ZXh0YXJlYWAsIHl0ID0gYFske2tufV1gLCB5cyA9IGBbJHtQbn1dYCwgQXMgPSBgWyR7TW59XWAsIHdsID0gYFske3ZsfV1gLCBUbCA9IHtcclxuICBpbnB1dEZvcm1XaGl0ZTogITFcclxufSwgeWwgPSB7XHJcbiAgaW5wdXRGb3JtV2hpdGU6IFwiKGJvb2xlYW4pXCJcclxufSwgQWwgPSB7XHJcbiAgbm90Y2g6IFwiZ3JvdXAgZmxleCBhYnNvbHV0ZSBsZWZ0LTAgdG9wLTAgdy1mdWxsIG1heC13LWZ1bGwgaC1mdWxsIHRleHQtbGVmdCBwb2ludGVyLWV2ZW50cy1ub25lXCIsXHJcbiAgbm90Y2hMZWFkaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBsZWZ0LTAgdG9wLTAgaC1mdWxsIHctMiBib3JkZXItZS0wIHJvdW5kZWQtcy1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1lLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLWUtMFwiLFxyXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJib3JkZXItc2Vjb25kYXJ5LTUwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTQwMCBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06c2hhZG93LW5vdGNoLTEgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1wcmltYXJ5XCIsXHJcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctbm90Y2gtMSBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06c2hhZG93LXdoaXRlIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcclxuICBub3RjaE1pZGRsZTogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3Jvdy0wIHNocmluay0wIGJhc2lzLWF1dG8gdy1hdXRvIG1heC13LVtjYWxjKDEwMCUtMXJlbSldIGgtZnVsbCBib3JkZXItZS0wIGJvcmRlci1zLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci14LTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0d2UtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItc29saWQgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci10LXRyYW5zcGFyZW50IGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10LXRyYW5zcGFyZW50XCIsXHJcbiAgbm90Y2hNaWRkbGVOb3JtYWw6IFwiYm9yZGVyLXNlY29uZGFyeS01MDAgZGFyazpib3JkZXItbmV1dHJhbC00MDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0yIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxyXG4gIG5vdGNoTWlkZGxlV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctbm90Y2gtMiBncm91cC1kYXRhLVt0d2UtaW5wdXQtZm9jdXNlZF06c2hhZG93LXdoaXRlIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcclxuICBub3RjaFRyYWlsaW5nOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93IGgtZnVsbCBib3JkZXItcy0wIHJvdW5kZWQtZS1bMC4yNXJlbV0gZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zLTAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXMtMFwiLFxyXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwiYm9yZGVyLXNlY29uZGFyeS01MDAgZGFyazpib3JkZXItbmV1dHJhbC00MDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0zIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxyXG4gIG5vdGNoVHJhaWxpbmdXaGl0ZTogXCJib3JkZXItbmV1dHJhbC0yMDAgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1ub3RjaC0zIGdyb3VwLWRhdGEtW3R3ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctd2hpdGUgZ3JvdXAtZGF0YS1bdHdlLWlucHV0LWZvY3VzZWRdOmJvcmRlci13aGl0ZVwiLFxyXG4gIGNvdW50ZXI6IFwidGV4dC1yaWdodCBsZWFkaW5nLVsxLjZdXCJcclxufSwgQ2wgPSB7XHJcbiAgbm90Y2g6IFwic3RyaW5nXCIsXHJcbiAgbm90Y2hMZWFkaW5nOiBcInN0cmluZ1wiLFxyXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJzdHJpbmdcIixcclxuICBub3RjaExlYWRpbmdXaGl0ZTogXCJzdHJpbmdcIixcclxuICBub3RjaE1pZGRsZTogXCJzdHJpbmdcIixcclxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJzdHJpbmdcIixcclxuICBub3RjaE1pZGRsZVdoaXRlOiBcInN0cmluZ1wiLFxyXG4gIG5vdGNoVHJhaWxpbmc6IFwic3RyaW5nXCIsXHJcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJzdHJpbmdcIixcclxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwic3RyaW5nXCIsXHJcbiAgY291bnRlcjogXCJzdHJpbmdcIlxyXG59O1xyXG5jbGFzcyAkIHtcclxuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XHJcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSwgdCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhzKSwgdGhpcy5fbGFiZWwgPSBudWxsLCB0aGlzLl9sYWJlbFdpZHRoID0gMCwgdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgdGhpcy5fbm90Y2hMZWFkaW5nID0gbnVsbCwgdGhpcy5fbm90Y2hNaWRkbGUgPSBudWxsLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gbnVsbCwgdGhpcy5faW5pdGlhdGVkID0gITEsIHRoaXMuX2hlbHBlciA9IG51bGwsIHRoaXMuX2NvdW50ZXIgPSAhMSwgdGhpcy5fY291bnRlckVsZW1lbnQgPSBudWxsLCB0aGlzLl9tYXhMZW5ndGggPSAwLCB0aGlzLl9sZWFkaW5nSWNvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKFYuc2V0RGF0YSh0LCBvZSwgdGhpcyksIHRoaXMuaW5pdCgpKTtcclxuICB9XHJcbiAgLy8gR2V0dGVyc1xyXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgIHJldHVybiBYZTtcclxuICB9XHJcbiAgZ2V0IGlucHV0KCkge1xyXG4gICAgcmV0dXJuIGguZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpIHx8IGguZmluZE9uZShcInRleHRhcmVhXCIsIHRoaXMuX2VsZW1lbnQpO1xyXG4gIH1cclxuICAvLyBQdWJsaWNcclxuICBpbml0KCkge1xyXG4gICAgdGhpcy5faW5pdGlhdGVkIHx8ICh0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fYXBwbHlEaXZzKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKSwgdGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMuX2luaXRpYXRlZCA9ICEwKTtcclxuICB9XHJcbiAgdXBkYXRlKCkge1xyXG4gICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIHRoaXMuX2dldE5vdGNoRGF0YSgpLCB0aGlzLl9hcHBseU5vdGNoKCksIHRoaXMuX2FjdGl2YXRlKCksIHRoaXMuX2dldEhlbHBlcigpLCB0aGlzLl9nZXRDb3VudGVyKCk7XHJcbiAgfVxyXG4gIGZvcmNlQWN0aXZlKCkge1xyXG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoc3QsIFwiXCIpLCBoLmZpbmRPbmUoeXQsIHRoaXMuaW5wdXQucGFyZW50Tm9kZSkuc2V0QXR0cmlidXRlKFxyXG4gICAgICBzdCxcclxuICAgICAgXCJcIlxyXG4gICAgKTtcclxuICB9XHJcbiAgZm9yY2VJbmFjdGl2ZSgpIHtcclxuICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKHN0KSwgaC5maW5kT25lKFxyXG4gICAgICB5dCxcclxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXHJcbiAgICApLnJlbW92ZUF0dHJpYnV0ZShzdCk7XHJcbiAgfVxyXG4gIGRpc3Bvc2UoKSB7XHJcbiAgICB0aGlzLl9yZW1vdmVCb3JkZXIoKSwgVi5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIG9lKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XHJcbiAgfVxyXG4gIC8vIFByaXZhdGVcclxuICBfZ2V0Q29uZmlnKHQsIGUpIHtcclxuICAgIHJldHVybiB0ID0ge1xyXG4gICAgICAuLi5UbCxcclxuICAgICAgLi4uRS5nZXREYXRhQXR0cmlidXRlcyhlKSxcclxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxyXG4gICAgfSwgUihYZSwgdCwgeWwpLCB0O1xyXG4gIH1cclxuICBfZ2V0Q2xhc3Nlcyh0KSB7XHJcbiAgICBjb25zdCBlID0gRS5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLkFsLFxyXG4gICAgICAuLi5lLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCBSKFhlLCB0LCBDbCksIHQ7XHJcbiAgfVxyXG4gIF9nZXRMYWJlbERhdGEoKSB7XHJcbiAgICB0aGlzLl9sYWJlbCA9IGguZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9sYWJlbCA9PT0gbnVsbCA/IHRoaXMuX3Nob3dQbGFjZWhvbGRlcigpIDogKHRoaXMuX2dldExhYmVsV2lkdGgoKSwgdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKCkpO1xyXG4gIH1cclxuICBfZ2V0SGVscGVyKCkge1xyXG4gICAgdGhpcy5faGVscGVyID0gaC5maW5kT25lKHdsLCB0aGlzLl9lbGVtZW50KTtcclxuICB9XHJcbiAgX2dldENvdW50ZXIoKSB7XHJcbiAgICB0aGlzLl9jb3VudGVyID0gRS5nZXREYXRhQXR0cmlidXRlKFxyXG4gICAgICB0aGlzLmlucHV0LFxyXG4gICAgICBcImlucHV0U2hvd2NvdW50ZXJcIlxyXG4gICAgKSwgdGhpcy5fY291bnRlciAmJiAodGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pbnB1dC5tYXhMZW5ndGgsIHRoaXMuX3Nob3dDb3VudGVyKCkpO1xyXG4gIH1cclxuICBfZ2V0RXZlbnRzKCkge1xyXG4gICAgZC5vbihcclxuICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgXCJmb2N1c1wiLFxyXG4gICAgICBcImlucHV0XCIsXHJcbiAgICAgICQuYWN0aXZhdGUobmV3ICQoKSlcclxuICAgICksIGQub24oXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIFwiaW5wdXRcIixcclxuICAgICAgXCJpbnB1dFwiLFxyXG4gICAgICAkLmFjdGl2YXRlKG5ldyAkKCkpXHJcbiAgICApLCBkLm9uKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBcImJsdXJcIixcclxuICAgICAgXCJpbnB1dFwiLFxyXG4gICAgICAkLmRlYWN0aXZhdGUobmV3ICQoKSlcclxuICAgICksIGQub24oXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQsXHJcbiAgICAgIFwiZm9jdXNcIixcclxuICAgICAgXCJ0ZXh0YXJlYVwiLFxyXG4gICAgICAkLmFjdGl2YXRlKG5ldyAkKCkpXHJcbiAgICApLCBkLm9uKFxyXG4gICAgICB0aGlzLl9lbGVtZW50LFxyXG4gICAgICBcImlucHV0XCIsXHJcbiAgICAgIFwidGV4dGFyZWFcIixcclxuICAgICAgJC5hY3RpdmF0ZShuZXcgJCgpKVxyXG4gICAgKSwgZC5vbihcclxuICAgICAgdGhpcy5fZWxlbWVudCxcclxuICAgICAgXCJibHVyXCIsXHJcbiAgICAgIFwidGV4dGFyZWFcIixcclxuICAgICAgJC5kZWFjdGl2YXRlKG5ldyAkKCkpXHJcbiAgICApLCBkLm9uKHdpbmRvdywgXCJzaG93bi50d2UubW9kYWxcIiwgKHQpID0+IHtcclxuICAgICAgaC5maW5kKGFlLCB0LnRhcmdldCkuZm9yRWFjaChcclxuICAgICAgICAoZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcyA9ICQuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcclxuICAgICAgICAgIHMgJiYgcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICksIGguZmluZChsZSwgdC50YXJnZXQpLmZvckVhY2goXHJcbiAgICAgICAgKGUpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHMgPSAkLmdldEluc3RhbmNlKGUucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgICBzICYmIHMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSksIGQub24od2luZG93LCBcInNob3duLnR3ZS5kcm9wZG93blwiLCAodCkgPT4ge1xyXG4gICAgICBjb25zdCBlID0gdC50YXJnZXQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICAgIFwiW2RhdGEtdHdlLWRyb3Bkb3duLW1lbnUtcmVmXVwiXHJcbiAgICAgICk7XHJcbiAgICAgIGUgJiYgKGguZmluZChhZSwgZSkuZm9yRWFjaChcclxuICAgICAgICAocykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbiA9ICQuZ2V0SW5zdGFuY2Uocy5wYXJlbnROb2RlKTtcclxuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICksIGguZmluZChsZSwgZSkuZm9yRWFjaChcclxuICAgICAgICAocykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbiA9ICQuZ2V0SW5zdGFuY2Uocy5wYXJlbnROb2RlKTtcclxuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICkpO1xyXG4gICAgfSksIGQub24od2luZG93LCBcInNob3duLnR3ZS50YWJcIiwgKHQpID0+IHtcclxuICAgICAgbGV0IGU7XHJcbiAgICAgIHQudGFyZ2V0LmhyZWYgPyBlID0gdC50YXJnZXQuaHJlZi5zcGxpdChcIiNcIilbMV0gOiBlID0gRS5nZXREYXRhQXR0cmlidXRlKHQudGFyZ2V0LCBcInRhcmdldFwiKS5zcGxpdChcclxuICAgICAgICBcIiNcIlxyXG4gICAgICApWzFdO1xyXG4gICAgICBjb25zdCBzID0gaC5maW5kT25lKGAjJHtlfWApO1xyXG4gICAgICBoLmZpbmQoYWUsIHMpLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICBjb25zdCByID0gJC5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xyXG4gICAgICAgIHIgJiYgci51cGRhdGUoKTtcclxuICAgICAgfSksIGguZmluZChsZSwgcykuZm9yRWFjaChcclxuICAgICAgICAobikgPT4ge1xyXG4gICAgICAgICAgY29uc3QgciA9ICQuZ2V0SW5zdGFuY2Uobi5wYXJlbnROb2RlKTtcclxuICAgICAgICAgIHIgJiYgci51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KSwgZC5vbih3aW5kb3csIFwicmVzZXRcIiwgKHQpID0+IHtcclxuICAgICAgaC5maW5kKGFlLCB0LnRhcmdldCkuZm9yRWFjaChcclxuICAgICAgICAoZSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgcyA9ICQuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcclxuICAgICAgICAgIHMgJiYgcy5mb3JjZUluYWN0aXZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApLCBoLmZpbmQobGUsIHQudGFyZ2V0KS5mb3JFYWNoKFxyXG4gICAgICAgIChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzID0gJC5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgcyAmJiBzLmZvcmNlSW5hY3RpdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgICB9KSwgZC5vbih3aW5kb3csIFwib25hdXRvY29tcGxldGVcIiwgKHQpID0+IHtcclxuICAgICAgY29uc3QgZSA9ICQuZ2V0SW5zdGFuY2UodC50YXJnZXQucGFyZW50Tm9kZSk7XHJcbiAgICAgICFlIHx8ICF0LmNhbmNlbGFibGUgfHwgZS5mb3JjZUFjdGl2ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9zaG93Q291bnRlcigpIHtcclxuICAgIGlmIChoLmZpbmQoXHJcbiAgICAgIGBbJHtUc31dYCxcclxuICAgICAgdGhpcy5fZWxlbWVudFxyXG4gICAgKS5sZW5ndGggPiAwKVxyXG4gICAgICByZXR1cm47XHJcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIEUuYWRkQ2xhc3ModGhpcy5fY291bnRlckVsZW1lbnQsIHRoaXMuX2NsYXNzZXMuY291bnRlciksIHRoaXMuX2NvdW50ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShUcywgXCJcIik7XHJcbiAgICBjb25zdCBlID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XHJcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHtlfSAvICR7dGhpcy5fbWF4TGVuZ3RofWAsIHRoaXMuX2hlbHBlci5hcHBlbmRDaGlsZCh0aGlzLl9jb3VudGVyRWxlbWVudCksIHRoaXMuX2JpbmRDb3VudGVyKCk7XHJcbiAgfVxyXG4gIF9iaW5kQ291bnRlcigpIHtcclxuICAgIGQub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcclxuICAgICAgdGhpcy5fY291bnRlckVsZW1lbnQuaW5uZXJIVE1MID0gYCR7dH0gLyAke3RoaXMuX21heExlbmd0aH1gO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKHQgPSB0aGlzLmlucHV0KSB7XHJcbiAgICBpZiAoISh0LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwiZGF0ZVwiKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgIShkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0KSAmJiAhdC52YWx1ZSA/IHQuc3R5bGUub3BhY2l0eSA9IDAgOiB0LnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gIH1cclxuICBfc2hvd1BsYWNlaG9sZGVyKCkge1xyXG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoYmwsIFwiXCIpO1xyXG4gIH1cclxuICBfZ2V0Tm90Y2hEYXRhKCkge1xyXG4gICAgdGhpcy5fbm90Y2hNaWRkbGUgPSBoLmZpbmRPbmUoXHJcbiAgICAgIEFzLFxyXG4gICAgICB0aGlzLl9lbGVtZW50XHJcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcgPSBoLmZpbmRPbmUoXHJcbiAgICAgIHlzLFxyXG4gICAgICB0aGlzLl9lbGVtZW50XHJcbiAgICApO1xyXG4gIH1cclxuICBfZ2V0TGFiZWxXaWR0aCgpIHtcclxuICAgIHRoaXMuX2xhYmVsV2lkdGggPSB0aGlzLl9sYWJlbC5jbGllbnRXaWR0aCAqIDAuOCArIDg7XHJcbiAgfVxyXG4gIF9nZXRMYWJlbFBvc2l0aW9uSW5JbnB1dEdyb3VwKCkge1xyXG4gICAgaWYgKHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IDAsICF0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtdHdlLWlucHV0LWdyb3VwLXJlZlwiKSlcclxuICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQsIGUgPSBoLnByZXYoXHJcbiAgICAgIHQsXHJcbiAgICAgIFwiW2RhdGEtdHdlLWlucHV0LWdyb3VwLXRleHQtcmVmXVwiXHJcbiAgICApWzBdO1xyXG4gICAgZSA9PT0gdm9pZCAwID8gdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCA6IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IGUub2Zmc2V0V2lkdGggLSAxO1xyXG4gIH1cclxuICBfYXBwbHlEaXZzKCkge1xyXG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ05vcm1hbCwgZSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVOb3JtYWwsIHMgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ05vcm1hbCwgbiA9IGguZmluZCh5dCwgdGhpcy5fZWxlbWVudCksIHIgPSBGdChcImRpdlwiKTtcclxuICAgIEUuYWRkQ2xhc3MociwgdGhpcy5fY2xhc3Nlcy5ub3RjaCksIHIuc2V0QXR0cmlidXRlKGtuLCBcIlwiKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gRnQoXCJkaXZcIiksIEUuYWRkQ2xhc3MoXHJcbiAgICAgIHRoaXMuX25vdGNoTGVhZGluZyxcclxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaExlYWRpbmd9ICR7dH1gXHJcbiAgICApLCB0aGlzLl9ub3RjaExlYWRpbmcuc2V0QXR0cmlidXRlKFBuLCBcIlwiKSwgdGhpcy5fbm90Y2hNaWRkbGUgPSBGdChcImRpdlwiKSwgRS5hZGRDbGFzcyhcclxuICAgICAgdGhpcy5fbm90Y2hNaWRkbGUsXHJcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGV9ICR7ZX1gXHJcbiAgICApLCB0aGlzLl9ub3RjaE1pZGRsZS5zZXRBdHRyaWJ1dGUoTW4sIFwiXCIpLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gRnQoXCJkaXZcIiksIEUuYWRkQ2xhc3MoXHJcbiAgICAgIHRoaXMuX25vdGNoVHJhaWxpbmcsXHJcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ30gJHtzfWBcclxuICAgICksIHRoaXMuX25vdGNoVHJhaWxpbmcuc2V0QXR0cmlidXRlKEVsLCBcIlwiKSwgIShuLmxlbmd0aCA+PSAxKSAmJiAoci5hcHBlbmQodGhpcy5fbm90Y2hMZWFkaW5nKSwgci5hcHBlbmQodGhpcy5fbm90Y2hNaWRkbGUpLCByLmFwcGVuZCh0aGlzLl9ub3RjaFRyYWlsaW5nKSwgdGhpcy5fZWxlbWVudC5hcHBlbmQociksIHIuZGlyID0gXCJsdHJcIik7XHJcbiAgfVxyXG4gIF9hcHBseU5vdGNoKCkge1xyXG4gICAgdGhpcy5fbm90Y2hNaWRkbGUuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9sYWJlbFdpZHRofXB4YCwgdGhpcy5fbm90Y2hMZWFkaW5nLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0ICsgOX1weGAsIHRoaXMuX2xhYmVsICE9PSBudWxsICYmICh0aGlzLl9sYWJlbC5zdHlsZS5tYXJnaW5MZWZ0ID0gYCR7dGhpcy5fbGFiZWxNYXJnaW5MZWZ0fXB4YCk7XHJcbiAgfVxyXG4gIF9yZW1vdmVCb3JkZXIoKSB7XHJcbiAgICBjb25zdCB0ID0gaC5maW5kT25lKHl0LCB0aGlzLl9lbGVtZW50KTtcclxuICAgIHQgJiYgdC5yZW1vdmUoKTtcclxuICB9XHJcbiAgX2FjdGl2YXRlKHQpIHtcclxuICAgIFZzKCgpID0+IHtcclxuICAgICAgdGhpcy5fZ2V0RWxlbWVudHModCk7XHJcbiAgICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBzID0gaC5maW5kT25lKFxyXG4gICAgICAgIHl0LFxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcclxuICAgICAgKTtcclxuICAgICAgdCAmJiB0LnR5cGUgPT09IFwiZm9jdXNcIiAmJiBzICYmIHMuc2V0QXR0cmlidXRlKHdzLCBcIlwiKSwgZS52YWx1ZSAhPT0gXCJcIiAmJiAoZS5zZXRBdHRyaWJ1dGUoc3QsIFwiXCIpLCBzICYmIHMuc2V0QXR0cmlidXRlKHN0LCBcIlwiKSksIHRoaXMuX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIoZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX2dldEVsZW1lbnRzKHQpIHtcclxuICAgIGlmICh0ICYmICh0aGlzLl9lbGVtZW50ID0gdC50YXJnZXQucGFyZW50Tm9kZSwgdGhpcy5fbGFiZWwgPSBoLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSksIHQgJiYgdGhpcy5fbGFiZWwpIHtcclxuICAgICAgY29uc3QgZSA9IHRoaXMuX2xhYmVsV2lkdGg7XHJcbiAgICAgIHRoaXMuX2dldExhYmVsRGF0YSgpLCBlICE9PSB0aGlzLl9sYWJlbFdpZHRoICYmICh0aGlzLl9ub3RjaE1pZGRsZSA9IGguZmluZE9uZShcclxuICAgICAgICBBcyxcclxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXHJcbiAgICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGguZmluZE9uZShcclxuICAgICAgICB5cyxcclxuICAgICAgICB0LnRhcmdldC5wYXJlbnROb2RlXHJcbiAgICAgICksIHRoaXMuX2FwcGx5Tm90Y2goKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9kZWFjdGl2YXRlKHQpIHtcclxuICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0O1xyXG4gICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCIpXHJcbiAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHMgPSBoLmZpbmRPbmUoXHJcbiAgICAgIHl0LFxyXG4gICAgICBlLnBhcmVudE5vZGVcclxuICAgICk7XHJcbiAgICBzLnJlbW92ZUF0dHJpYnV0ZSh3cyksIGUudmFsdWUgPT09IFwiXCIgJiYgKGUucmVtb3ZlQXR0cmlidXRlKHN0KSwgcy5yZW1vdmVBdHRyaWJ1dGUoc3QpKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcihlKTtcclxuICB9XHJcbiAgc3RhdGljIGFjdGl2YXRlKHQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHQuX2FjdGl2YXRlKGUpO1xyXG4gICAgfTtcclxuICB9XHJcbiAgc3RhdGljIGRlYWN0aXZhdGUodCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgdC5fZGVhY3RpdmF0ZShlKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgbGV0IHMgPSBWLmdldERhdGEodGhpcywgb2UpO1xyXG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xyXG4gICAgICBpZiAoISghcyAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKHMgfHwgKHMgPSBuZXcgJCh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzW3RdID4gXCJ1XCIpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcclxuICAgICAgICBzW3RdKGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcclxuICAgIHJldHVybiBWLmdldERhdGEodCwgb2UpO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcclxuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IE9sID0ge1xyXG4gIHByb3BlcnR5OiBcImNvbG9yXCIsXHJcbiAgZGVmYXVsdFZhbHVlOiBudWxsLFxyXG4gIGluaGVyaXQ6ICEwXHJcbn0sIEF0ID0gKGksIHQpID0+IHtcclxuICBjb25zdCB7IHByb3BlcnR5OiBlLCBkZWZhdWx0VmFsdWU6IHMsIGluaGVyaXQ6IG4gfSA9IHsgLi4uT2wsIC4uLnQgfSwgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgci5jbGFzc0xpc3QuYWRkKGkpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHIpO1xyXG4gIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyKVtlXSB8fCBzLCB1ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoci5wYXJlbnRFbGVtZW50KVtlXTtcclxuICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKSwgIW4gJiYgdSAmJiBhID09PSB1ID8gcyA6IGEgfHwgcztcclxufSwgR2UgPSBcInJpcHBsZVwiLCBjZSA9IFwidHdlLnJpcHBsZVwiLCBEbCA9IFwicmdiYSh7e2NvbG9yfX0sIDAuMikgMCwgcmdiYSh7e2NvbG9yfX0sIDAuMykgNDAlLCByZ2JhKHt7Y29sb3J9fSwgMC40KSA1MCUsIHJnYmEoe3tjb2xvcn19LCAwLjUpIDYwJSwgcmdiYSh7e2NvbG9yfX0sIDApIDcwJVwiLCBObCA9IFtcIltkYXRhLXR3ZS1yaXBwbGUtaW5pdF1cIl0sIGRlID0gWzAsIDAsIDBdLCBTbCA9IFtcclxuICB7XHJcbiAgICBuYW1lOiBcInByaW1hcnlcIixcclxuICAgIGdyYWRpZW50Q29sb3I6IEF0KFwidGV4dC1wcmltYXJ5XCIsIHsgZGVmYXVsdFZhbHVlOiBcIiMzQjcxQ0FcIiwgaW5oZXJpdDogITEgfSlcclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6IFwic2Vjb25kYXJ5XCIsXHJcbiAgICBncmFkaWVudENvbG9yOiBBdChcInRleHQtcHJpbWFyeS0xMDBcIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzlGQTZCMlwiLCBpbmhlcml0OiAhMSB9KVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogXCJzdWNjZXNzXCIsXHJcbiAgICBncmFkaWVudENvbG9yOiBBdChcInRleHQtc3VjY2Vzc1wiLCB7IGRlZmF1bHRWYWx1ZTogXCIjMTRBNDREXCIsIGluaGVyaXQ6ICExIH0pXHJcbiAgfSxcclxuICB7XHJcbiAgICBuYW1lOiBcImRhbmdlclwiLFxyXG4gICAgZ3JhZGllbnRDb2xvcjogQXQoXCJ0ZXh0LWRhbmdlclwiLCB7IGRlZmF1bHRWYWx1ZTogXCIjREM0QzY0XCIsIGluaGVyaXQ6ICExIH0pXHJcbiAgfSxcclxuICB7XHJcbiAgICBuYW1lOiBcIndhcm5pbmdcIixcclxuICAgIGdyYWRpZW50Q29sb3I6IEF0KFwidGV4dC13YXJuaW5nXCIsIHsgZGVmYXVsdFZhbHVlOiBcIiNFNEExMUJcIiwgaW5oZXJpdDogITEgfSlcclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6IFwiaW5mb1wiLFxyXG4gICAgZ3JhZGllbnRDb2xvcjogQXQoXCJ0ZXh0LWluZm9cIiwgeyBkZWZhdWx0VmFsdWU6IFwiIzU0QjREM1wiLCBpbmhlcml0OiAhMSB9KVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogXCJsaWdodFwiLFxyXG4gICAgZ3JhZGllbnRDb2xvcjogXCIjZmJmYmZiXCJcclxuICB9LFxyXG4gIHtcclxuICAgIG5hbWU6IFwiZGFya1wiLFxyXG4gICAgZ3JhZGllbnRDb2xvcjogXCIjMjYyNjI2XCJcclxuICB9XHJcbl0sIENzID0gMC41LCBMbCA9IHtcclxuICByaXBwbGVDZW50ZXJlZDogITEsXHJcbiAgcmlwcGxlQ29sb3I6IFwiXCIsXHJcbiAgcmlwcGxlQ29sb3JEYXJrOiBcIlwiLFxyXG4gIHJpcHBsZUR1cmF0aW9uOiBcIjUwMG1zXCIsXHJcbiAgcmlwcGxlUmFkaXVzOiAwLFxyXG4gIHJpcHBsZVVuYm91bmQ6ICExXHJcbn0sICRsID0ge1xyXG4gIHJpcHBsZUNlbnRlcmVkOiBcImJvb2xlYW5cIixcclxuICByaXBwbGVDb2xvcjogXCJzdHJpbmdcIixcclxuICByaXBwbGVDb2xvckRhcms6IFwic3RyaW5nXCIsXHJcbiAgcmlwcGxlRHVyYXRpb246IFwic3RyaW5nXCIsXHJcbiAgcmlwcGxlUmFkaXVzOiBcIm51bWJlclwiLFxyXG4gIHJpcHBsZVVuYm91bmQ6IFwiYm9vbGVhblwiXHJcbn0sIElsID0ge1xyXG4gIHJpcHBsZTogXCJyZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW4gaW5saW5lLWJsb2NrIGFsaWduLWJvdHRvbVwiLFxyXG4gIHJpcHBsZVdhdmU6IFwicm91bmRlZC1bNTAlXSBvcGFjaXR5LTUwIHBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgdG91Y2gtbm9uZSBzY2FsZS0wIHRyYW5zaXRpb24tW3RyYW5zZm9ybSxfb3BhY2l0eV0gZWFzZS1bY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpLF9jdWJpYy1iZXppZXIoMCwwLDAuMTUsMSldIHotWzk5OV1cIixcclxuICB1bmJvdW5kOiBcIm92ZXJmbG93LXZpc2libGVcIlxyXG59LCBSbCA9IHtcclxuICByaXBwbGU6IFwic3RyaW5nXCIsXHJcbiAgcmlwcGxlV2F2ZTogXCJzdHJpbmdcIixcclxuICB1bmJvdW5kOiBcInN0cmluZ1wiXHJcbn07XHJcbmNsYXNzIEhuIHtcclxuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XHJcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMocyksIHRoaXMuX2N1cnJlbnRDb2xvciA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IsIHRoaXMuX2VsZW1lbnQgJiYgKFYuc2V0RGF0YSh0LCBjZSwgdGhpcyksIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpKSwgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5fY3JlYXRlUmlwcGxlLmJpbmQodGhpcyksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExLCB0aGlzLl9pbml0aWFsQ2xhc3NlcyA9IG51bGwsIHRoaXMuaW5pdCgpO1xyXG4gIH1cclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIEdlO1xyXG4gIH1cclxuICAvLyBQdWJsaWNcclxuICBpbml0KCkge1xyXG4gICAgdGhpcy5fYWRkQ2xpY2tFdmVudCh0aGlzLl9lbGVtZW50KTtcclxuICB9XHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIFYucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBjZSksIGQub2ZmKHRoaXMuX2VsZW1lbnQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlciksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbDtcclxuICB9XHJcbiAgLy8gUHJpdmF0ZVxyXG4gIF9hdXRvSW5pdCh0KSB7XHJcbiAgICBObC5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgIGguY2xvc2VzdCh0LnRhcmdldCwgZSkgJiYgKHRoaXMuX2VsZW1lbnQgPSBoLmNsb3Nlc3QodC50YXJnZXQsIGUpKTtcclxuICAgIH0pLCB0aGlzLl9lbGVtZW50LnN0eWxlLm1pbldpZHRoIHx8IChFLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcclxuICAgICAgXCJtaW4td2lkdGhcIjogZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS53aWR0aFxyXG4gICAgfSksIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMCksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoKSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbLi4udGhpcy5fZWxlbWVudC5jbGFzc0xpc3RdLCBFLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSwgdGhpcy5fY3JlYXRlUmlwcGxlKHQpO1xyXG4gIH1cclxuICBfYWRkQ2xpY2tFdmVudCh0KSB7XHJcbiAgICBkLm9uKHQsIFwibW91c2Vkb3duXCIsIHRoaXMuX2NsaWNrSGFuZGxlcik7XHJcbiAgfVxyXG4gIF9jcmVhdGVSaXBwbGUodCkge1xyXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZih0aGlzLl9jbGFzc2VzLnJpcHBsZSkgPCAwICYmIEUuYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5yaXBwbGUpO1xyXG4gICAgY29uc3QgeyBsYXllclg6IGUsIGxheWVyWTogcyB9ID0gdCwgbiA9IHQub2Zmc2V0WCB8fCBlLCByID0gdC5vZmZzZXRZIHx8IHMsIG8gPSB0aGlzLl9lbGVtZW50Lm9mZnNldEhlaWdodCwgYSA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0V2lkdGgsIGwgPSB0aGlzLl9kdXJhdGlvblRvTXNOdW1iZXIodGhpcy5fb3B0aW9ucy5yaXBwbGVEdXJhdGlvbiksIHUgPSB7XHJcbiAgICAgIG9mZnNldFg6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBvIC8gMiA6IG4sXHJcbiAgICAgIG9mZnNldFk6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyBhIC8gMiA6IHIsXHJcbiAgICAgIGhlaWdodDogbyxcclxuICAgICAgd2lkdGg6IGFcclxuICAgIH0sIGMgPSB0aGlzLl9nZXREaWFtZXRlcih1KSwgZiA9IHRoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzIHx8IGMgLyAyLCB2ID0ge1xyXG4gICAgICBkZWxheTogbCAqIENzLFxyXG4gICAgICBkdXJhdGlvbjogbCAtIGwgKiBDc1xyXG4gICAgfSwgZyA9IHtcclxuICAgICAgbGVmdDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke2EgLyAyIC0gZn1weGAgOiBgJHtuIC0gZn1weGAsXHJcbiAgICAgIHRvcDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke28gLyAyIC0gZn1weGAgOiBgJHtyIC0gZn1weGAsXHJcbiAgICAgIGhlaWdodDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IGN9cHhgLFxyXG4gICAgICB3aWR0aDogYCR7dGhpcy5fb3B0aW9ucy5yaXBwbGVSYWRpdXMgKiAyIHx8IGN9cHhgLFxyXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHt2LmRlbGF5fW1zYCxcclxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBgJHtsfW1zLCAke3YuZHVyYXRpb259bXNgXHJcbiAgICB9LCBPID0gRnQoXCJkaXZcIik7XHJcbiAgICB0aGlzLl9jcmVhdGVIVE1MUmlwcGxlKHtcclxuICAgICAgd3JhcHBlcjogdGhpcy5fZWxlbWVudCxcclxuICAgICAgcmlwcGxlOiBPLFxyXG4gICAgICBzdHlsZXM6IGdcclxuICAgIH0pLCB0aGlzLl9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiBPLCBkdXJhdGlvbjogbCB9KTtcclxuICB9XHJcbiAgX2NyZWF0ZUhUTUxSaXBwbGUoeyB3cmFwcGVyOiB0LCByaXBwbGU6IGUsIHN0eWxlczogcyB9KSB7XHJcbiAgICBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKFxyXG4gICAgICAobikgPT4gZS5zdHlsZVtuXSA9IHNbbl1cclxuICAgICksIEUuYWRkQ2xhc3MoZSwgdGhpcy5fY2xhc3Nlcy5yaXBwbGVXYXZlKSwgZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXR3ZS1yaXBwbGUtcmVmXCIsIFwiXCIpLCB0aGlzLl9hZGRDb2xvcihlLCB0KSwgdGhpcy5fdG9nZ2xlVW5ib3VuZCh0KSwgdGhpcy5fYXBwZW5kUmlwcGxlKGUsIHQpO1xyXG4gIH1cclxuICBfcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogdCwgZHVyYXRpb246IGUgfSkge1xyXG4gICAgdGhpcy5fcmlwcGxlVGltZXIgJiYgKGNsZWFyVGltZW91dCh0aGlzLl9yaXBwbGVUaW1lciksIHRoaXMuX3JpcHBsZVRpbWVyID0gbnVsbCksIHQgJiYgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHQuY2xhc3NMaXN0LmFkZChcIiFvcGFjaXR5LTBcIik7XHJcbiAgICB9LCAxMCksIHRoaXMuX3JpcHBsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIGlmICh0ICYmICh0LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIGguZmluZChcIltkYXRhLXR3ZS1yaXBwbGUtcmVmXVwiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxyXG4gICAgICAgICAgKG4pID0+IHtcclxuICAgICAgICAgICAgbi5yZW1vdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICApLCB0aGlzLl9pc01pbldpZHRoU2V0ICYmIChFLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgXCJtaW4td2lkdGhcIjogXCJcIiB9KSwgdGhpcy5faXNNaW5XaWR0aFNldCA9ICExKTtcclxuICAgICAgICBjb25zdCBzID0gdGhpcy5faW5pdGlhbENsYXNzZXMgPyB0aGlzLl9hZGRlZE5ld1JpcHBsZUNsYXNzZXMoXHJcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLnJpcHBsZSxcclxuICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzXHJcbiAgICAgICAgKSA6IHRoaXMuX2NsYXNzZXMucmlwcGxlLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBFLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHMpO1xyXG4gICAgICB9XHJcbiAgICB9LCBlKTtcclxuICB9XHJcbiAgX2FkZGVkTmV3UmlwcGxlQ2xhc3Nlcyh0LCBlKSB7XHJcbiAgICByZXR1cm4gdC5zcGxpdChcIiBcIikuZmlsdGVyKFxyXG4gICAgICAocykgPT4gZS5maW5kSW5kZXgoKG4pID0+IHMgPT09IG4pID09PSAtMVxyXG4gICAgKTtcclxuICB9XHJcbiAgX2R1cmF0aW9uVG9Nc051bWJlcih0KSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHQucmVwbGFjZShcIm1zXCIsIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiMDAwXCIpKTtcclxuICB9XHJcbiAgX2dldENvbmZpZyh0ID0ge30pIHtcclxuICAgIGNvbnN0IGUgPSBFLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLkxsLFxyXG4gICAgICAuLi5lLFxyXG4gICAgICAuLi50XHJcbiAgICB9LCBSKEdlLCB0LCAkbCksIHQ7XHJcbiAgfVxyXG4gIF9nZXRDbGFzc2VzKHQgPSB7fSkge1xyXG4gICAgY29uc3QgZSA9IEUuZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcclxuICAgIHJldHVybiB0ID0ge1xyXG4gICAgICAuLi5JbCxcclxuICAgICAgLi4uZSxcclxuICAgICAgLi4udFxyXG4gICAgfSwgUihHZSwgdCwgUmwpLCB0O1xyXG4gIH1cclxuICBfZ2V0RGlhbWV0ZXIoeyBvZmZzZXRYOiB0LCBvZmZzZXRZOiBlLCBoZWlnaHQ6IHMsIHdpZHRoOiBuIH0pIHtcclxuICAgIGNvbnN0IHIgPSBlIDw9IHMgLyAyLCBvID0gdCA8PSBuIC8gMiwgYSA9ICh2LCBnKSA9PiBNYXRoLnNxcnQodiAqKiAyICsgZyAqKiAyKSwgbCA9IGUgPT09IHMgLyAyICYmIHQgPT09IG4gLyAyLCB1ID0ge1xyXG4gICAgICBmaXJzdDogciA9PT0gITAgJiYgbyA9PT0gITEsXHJcbiAgICAgIHNlY29uZDogciA9PT0gITAgJiYgbyA9PT0gITAsXHJcbiAgICAgIHRoaXJkOiByID09PSAhMSAmJiBvID09PSAhMCxcclxuICAgICAgZm91cnRoOiByID09PSAhMSAmJiBvID09PSAhMVxyXG4gICAgfSwgYyA9IHtcclxuICAgICAgdG9wTGVmdDogYSh0LCBlKSxcclxuICAgICAgdG9wUmlnaHQ6IGEobiAtIHQsIGUpLFxyXG4gICAgICBib3R0b21MZWZ0OiBhKHQsIHMgLSBlKSxcclxuICAgICAgYm90dG9tUmlnaHQ6IGEobiAtIHQsIHMgLSBlKVxyXG4gICAgfTtcclxuICAgIGxldCBmID0gMDtcclxuICAgIHJldHVybiBsIHx8IHUuZm91cnRoID8gZiA9IGMudG9wTGVmdCA6IHUudGhpcmQgPyBmID0gYy50b3BSaWdodCA6IHUuc2Vjb25kID8gZiA9IGMuYm90dG9tUmlnaHQgOiB1LmZpcnN0ICYmIChmID0gYy5ib3R0b21MZWZ0KSwgZiAqIDI7XHJcbiAgfVxyXG4gIF9hcHBlbmRSaXBwbGUodCwgZSkge1xyXG4gICAgZS5hcHBlbmRDaGlsZCh0KSwgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIEUuYWRkQ2xhc3ModCwgXCJvcGFjaXR5LTAgc2NhbGUtMTAwXCIpO1xyXG4gICAgfSwgNTApO1xyXG4gIH1cclxuICBfdG9nZ2xlVW5ib3VuZCh0KSB7XHJcbiAgICB0aGlzLl9vcHRpb25zLnJpcHBsZVVuYm91bmQgPT09ICEwID8gRS5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnVuYm91bmQpIDogRS5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnVuYm91bmQpO1xyXG4gIH1cclxuICBfYWRkQ29sb3IodCkge1xyXG4gICAgbGV0IGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yIHx8IFwicmdiKDAsMCwwKVwiO1xyXG4gICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yRGFyayB8fCB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yKTtcclxuICAgIGNvbnN0IHMgPSBTbC5maW5kKFxyXG4gICAgICAobykgPT4gby5uYW1lID09PSBlLnRvTG93ZXJDYXNlKClcclxuICAgICksIG4gPSBzID8gdGhpcy5fY29sb3JUb1JHQihzLmdyYWRpZW50Q29sb3IpLmpvaW4oXCIsXCIpIDogdGhpcy5fY29sb3JUb1JHQihlKS5qb2luKFwiLFwiKSwgciA9IERsLnNwbGl0KFwie3tjb2xvcn19XCIpLmpvaW4oYCR7bn1gKTtcclxuICAgIHQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHJhZGlhbC1ncmFkaWVudChjaXJjbGUsICR7cn0pYDtcclxuICB9XHJcbiAgX2NvbG9yVG9SR0IodCkge1xyXG4gICAgZnVuY3Rpb24gZShyKSB7XHJcbiAgICAgIHJldHVybiByLmxlbmd0aCA8IDcgJiYgKHIgPSBgIyR7clsxXX0ke3JbMV19JHtyWzJdfSR7clsyXX0ke3JbM119JHtyWzNdfWApLCBbXHJcbiAgICAgICAgcGFyc2VJbnQoci5zdWJzdHIoMSwgMiksIDE2KSxcclxuICAgICAgICBwYXJzZUludChyLnN1YnN0cigzLCAyKSwgMTYpLFxyXG4gICAgICAgIHBhcnNlSW50KHIuc3Vic3RyKDUsIDIpLCAxNilcclxuICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHMocikge1xyXG4gICAgICBjb25zdCBvID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChcclxuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmljdHVtXCIpXHJcbiAgICAgICksIGEgPSBcInJnYigxLCAyLCAzKVwiO1xyXG4gICAgICByZXR1cm4gby5zdHlsZS5jb2xvciA9IGEsIG8uc3R5bGUuY29sb3IgIT09IGEgfHwgKG8uc3R5bGUuY29sb3IgPSByLCBvLnN0eWxlLmNvbG9yID09PSBhIHx8IG8uc3R5bGUuY29sb3IgPT09IFwiXCIpID8gZGUgOiAociA9IGdldENvbXB1dGVkU3R5bGUobykuY29sb3IsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobyksIHIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbihyKSB7XHJcbiAgICAgIHJldHVybiByID0gci5tYXRjaCgvWy5cXGRdKy9nKS5tYXAoKG8pID0+ICtOdW1iZXIobykpLCByLmxlbmd0aCA9IDMsIHI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpID09PSBcInRyYW5zcGFyZW50XCIgPyBkZSA6IHRbMF0gPT09IFwiI1wiID8gZSh0KSA6ICh0LmluZGV4T2YoXCJyZ2JcIikgPT09IC0xICYmICh0ID0gcyh0KSksIHQuaW5kZXhPZihcInJnYlwiKSA9PT0gMCA/IG4odCkgOiBkZSk7XHJcbiAgfVxyXG4gIC8vIFN0YXRpY1xyXG4gIHN0YXRpYyBhdXRvSW5pdGlhbCh0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xyXG4gICAgICB0Ll9hdXRvSW5pdChlKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIFYuZ2V0RGF0YSh0aGlzLCBjZSkgPyBudWxsIDogbmV3IEhuKHRoaXMsIHQpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XHJcbiAgICByZXR1cm4gVi5nZXREYXRhKHQsIGNlKTtcclxuICB9XHJcbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xyXG4gIH1cclxufVxyXG5jb25zdCBRZSA9IFwibW9kYWxcIiwgeGwgPSBcInR3ZS5tb2RhbFwiLCBLID0gYC4ke3hsfWAsIE9zID0gXCJFc2NhcGVcIiwgRHMgPSB7XHJcbiAgYmFja2Ryb3A6ICEwLFxyXG4gIGtleWJvYXJkOiAhMCxcclxuICBmb2N1czogITBcclxufSwgTnMgPSB7XHJcbiAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxyXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcclxuICBmb2N1czogXCJib29sZWFuXCJcclxufSwga2wgPSB7XHJcbiAgc2hvdzogXCJ0cmFuc2Zvcm0tbm9uZVwiLFxyXG4gIHN0YXRpYzogXCJzY2FsZS1bMS4wMl1cIixcclxuICBzdGF0aWNQcm9wZXJ0aWVzOiBcInRyYW5zaXRpb24tc2NhbGUgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCIsXHJcbiAgYmFja2Ryb3A6IFwib3BhY2l0eS01MCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXQgZml4ZWQgdG9wLTAgbGVmdC0wIHotWzEwNDBdIGJnLWJsYWNrIHctc2NyZWVuIGgtc2NyZWVuXCJcclxufSwgUGwgPSB7XHJcbiAgc2hvdzogXCJzdHJpbmdcIixcclxuICBzdGF0aWM6IFwic3RyaW5nXCIsXHJcbiAgc3RhdGljUHJvcGVydGllczogXCJzdHJpbmdcIixcclxuICBiYWNrZHJvcDogXCJzdHJpbmdcIlxyXG59LCBNbCA9IGBoaWRlJHtLfWAsIEhsID0gYGhpZGVQcmV2ZW50ZWQke0t9YCwgVmwgPSBgaGlkZGVuJHtLfWAsIFdsID0gYHNob3cke0t9YCwgQmwgPSBgc2hvd24ke0t9YCwgU3MgPSBgcmVzaXplJHtLfWAsIExzID0gYGNsaWNrLmRpc21pc3Mke0t9YCwgJHMgPSBga2V5ZG93bi5kaXNtaXNzJHtLfWAsIGpsID0gYG1vdXNldXAuZGlzbWlzcyR7S31gLCBJcyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7S31gLCBScyA9IFwiZGF0YS10d2UtbW9kYWwtb3BlblwiLCB4cyA9IFwiZGF0YS10d2Utb3BlblwiLCBVdCA9IFwiW2RhdGEtdHdlLW1vZGFsLWRpYWxvZy1yZWZdXCIsIFVsID0gXCJbZGF0YS10d2UtbW9kYWwtYm9keS1yZWZdXCI7XHJcbmNsYXNzIGFpIGV4dGVuZHMgdHQge1xyXG4gIGNvbnN0cnVjdG9yKHQsIGUsIHMpIHtcclxuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKHMpLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX3Njcm9sbEJhciA9IG5ldyByaSgpLCB0aGlzLl9kaWFsb2cgPSBoLmZpbmRPbmUoVXQsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xyXG4gIH1cclxuICAvLyBHZXR0ZXJzXHJcbiAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgcmV0dXJuIFFlO1xyXG4gIH1cclxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICByZXR1cm4gRHM7XHJcbiAgfVxyXG4gIHN0YXRpYyBnZXQgZ2V0RGVmYXVsdFR5cGUoKSB7XHJcbiAgICByZXR1cm4gTnM7XHJcbiAgfVxyXG4gIC8vIFB1YmxpY1xyXG4gIHRvZ2dsZSh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xyXG4gIH1cclxuICBzaG93KHQpIHtcclxuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGQudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBXbCwge1xyXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XHJcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2lzQW5pbWF0ZWQoKSAmJiAodGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITApLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShScywgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgZC5vbih0aGlzLl9kaWFsb2csIElzLCAoKSA9PiB7XHJcbiAgICAgIGQub25lKHRoaXMuX2VsZW1lbnQsIGpsLCAocykgPT4ge1xyXG4gICAgICAgIHMudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50ICYmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITApO1xyXG4gICAgICB9KTtcclxuICAgIH0pLCB0aGlzLl9zaG93RWxlbWVudCh0KSwgdGhpcy5fc2hvd0JhY2tkcm9wKCkpO1xyXG4gIH1cclxuICBoaWRlKCkge1xyXG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTWwpLmRlZmF1bHRQcmV2ZW50ZWQpXHJcbiAgICAgIHJldHVybjtcclxuICAgIHRoaXMuX2lzU2hvd24gPSAhMTtcclxuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XHJcbiAgICBlICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIGguZmluZE9uZShVdCwgdGhpcy5fZWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCBkLm9mZih0aGlzLl9lbGVtZW50LCBMcyksIGQub2ZmKHRoaXMuX2RpYWxvZywgSXMpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCBlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoeHMpO1xyXG4gIH1cclxuICBkaXNwb3NlKCkge1xyXG4gICAgW3dpbmRvdywgZG9jdW1lbnQsIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChcclxuICAgICAgKHQpID0+IGQub2ZmKHQsIEspXHJcbiAgICApLCB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIHN1cGVyLmRpc3Bvc2UoKTtcclxuICB9XHJcbiAgaGFuZGxlVXBkYXRlKCkge1xyXG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XHJcbiAgfVxyXG4gIC8vIFByaXZhdGVcclxuICBfaW5pdCgpIHtcclxuICAgIHRoaXMuX2RpZEluaXQgfHwgKENuKGFpKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcclxuICB9XHJcbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcclxuICAgIHJldHVybiBuZXcgeW4oe1xyXG4gICAgICBpc1Zpc2libGU6ICEhdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxyXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcclxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpLFxyXG4gICAgICBiYWNrZHJvcENsYXNzZXM6IHRoaXMuX2NsYXNzZXMuYmFja2Ryb3BcclxuICAgIH0pO1xyXG4gIH1cclxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcclxuICAgIHJldHVybiBuZXcgQW4odGhpcy5fZWxlbWVudCwge1xyXG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXHJcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5ID09PSBcIlRhYlwiXHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3Nob3dFbGVtZW50KHQpIHtcclxuICAgIGNvbnN0IGUgPSB0aGlzLl9pc0FuaW1hdGVkKCksIHMgPSBoLmZpbmRPbmUoVWwsIHRoaXMuX2RpYWxvZyk7XHJcbiAgICAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7eHN9YCwgXCJ0cnVlXCIpLCB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XHJcbiAgICBjb25zdCBuID0gaC5maW5kT25lKFV0LCB0aGlzLl9lbGVtZW50KTtcclxuICAgIG4uY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLnNob3cpLCBuLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIiksIG4uY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMTAwXCIpLCBzICYmIChzLnNjcm9sbFRvcCA9IDApLCBlICYmIFh0KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgY29uc3QgciA9ICgpID0+IHtcclxuICAgICAgdGhpcy5fY29uZmlnLmZvY3VzICYmIHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQmwsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sociwgdGhpcy5fZGlhbG9nLCBlKTtcclxuICB9XHJcbiAgX3NldEVzY2FwZUV2ZW50KCkge1xyXG4gICAgdGhpcy5faXNTaG93biA/IGQub24oZG9jdW1lbnQsICRzLCAodCkgPT4ge1xyXG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IE9zID8gKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5oaWRlKCkpIDogIXRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gT3MgJiYgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xyXG4gICAgfSkgOiBkLm9mZih0aGlzLl9lbGVtZW50LCAkcyk7XHJcbiAgfVxyXG4gIF9zZXRSZXNpemVFdmVudCgpIHtcclxuICAgIHRoaXMuX2lzU2hvd24gPyBkLm9uKHdpbmRvdywgU3MsICgpID0+IHRoaXMuX2FkanVzdERpYWxvZygpKSA6IGQub2ZmKHdpbmRvdywgU3MpO1xyXG4gIH1cclxuICBfaGlkZU1vZGFsKCkge1xyXG4gICAgY29uc3QgdCA9IGguZmluZE9uZShVdCwgdGhpcy5fZWxlbWVudCk7XHJcbiAgICB0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3Nlcy5zaG93KSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKTtcclxuICAgIGNvbnN0IGUgPSBKZSh0KTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH0sIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcclxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoUnMpLCB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBkLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVmwpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9zaG93QmFja2Ryb3AodCkge1xyXG4gICAgZC5vbih0aGlzLl9lbGVtZW50LCBMcywgKGUpID0+IHtcclxuICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcclxuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITE7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgJiYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gITAgPyB0aGlzLmhpZGUoKSA6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gXCJzdGF0aWNcIiAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkpO1xyXG4gICAgfSksIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XHJcbiAgfVxyXG4gIF9pc0FuaW1hdGVkKCkge1xyXG4gICAgcmV0dXJuICEhaC5maW5kT25lKFV0LCB0aGlzLl9lbGVtZW50KTtcclxuICB9XHJcbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XHJcbiAgICBpZiAoZC50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhsKS5kZWZhdWx0UHJldmVudGVkKVxyXG4gICAgICByZXR1cm47XHJcbiAgICBjb25zdCB7IGNsYXNzTGlzdDogZSwgc2Nyb2xsSGVpZ2h0OiBzLCBzdHlsZTogbiB9ID0gdGhpcy5fZWxlbWVudCwgciA9IHMgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgaWYgKCFyICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpKVxyXG4gICAgICByZXR1cm47XHJcbiAgICByIHx8IChuLm92ZXJmbG93WSA9IFwiaGlkZGVuXCIpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpYy5zcGxpdChcIiBcIikpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpY1Byb3BlcnRpZXMuc3BsaXQoXCIgXCIpKTtcclxuICAgIGNvbnN0IG8gPSBKZSh0aGlzLl9lbGVtZW50KTtcclxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICBlLnJlbW92ZSh0aGlzLl9jbGFzc2VzLnN0YXRpYyksIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGUucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuc3RhdGljUHJvcGVydGllcy5zcGxpdChcIiBcIikpO1xyXG4gICAgICB9LCBvKSwgciB8fCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBuLm92ZXJmbG93WSA9IFwiXCI7XHJcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XHJcbiAgICB9LCB0aGlzLl9kaWFsb2cpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XHJcbiAgfVxyXG4gIF9nZXRDb25maWcodCkge1xyXG4gICAgcmV0dXJuIHQgPSB7XHJcbiAgICAgIC4uLkRzLFxyXG4gICAgICAuLi5FLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxyXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XHJcbiAgICB9LCBSKFFlLCB0LCBOcyksIHQ7XHJcbiAgfVxyXG4gIF9nZXRDbGFzc2VzKHQpIHtcclxuICAgIGNvbnN0IGUgPSBFLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XHJcbiAgICByZXR1cm4gdCA9IHtcclxuICAgICAgLi4ua2wsXHJcbiAgICAgIC4uLmUsXHJcbiAgICAgIC4uLnRcclxuICAgIH0sIFIoUWUsIHQsIFBsKSwgdDtcclxuICB9XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIF9hZGp1c3REaWFsb2coKSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCBlID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCksIHMgPSBlID4gMDtcclxuICAgICghcyAmJiB0ICYmICFNKCkgfHwgcyAmJiAhdCAmJiBNKCkpICYmICh0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7ZX1weGApLCAocyAmJiAhdCAmJiAhTSgpIHx8ICFzICYmIHQgJiYgTSgpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtlfXB4YCk7XHJcbiAgfVxyXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xyXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcclxuICB9XHJcbiAgLy8gU3RhdGljXHJcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zdCBzID0gYWkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcclxuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNbdF0gPiBcInVcIilcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xyXG4gICAgICAgIHNbdF0oZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5jb25zdCBGbCA9IChpLCB0KSA9PiB7XHJcbiAgZC5vbihcclxuICAgIGRvY3VtZW50LFxyXG4gICAgYGNsaWNrLnR3ZS4ke2kuTkFNRX1gLFxyXG4gICAgdCxcclxuICAgIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCBpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XHJcbiAgICB9XHJcbiAgKTtcclxufSwgWWwgPSAoaSwgdCkgPT4ge1xyXG4gIGQub24oXHJcbiAgICBkb2N1bWVudCxcclxuICAgIGBjbGljay50d2UuJHtpLk5BTUV9LmRhdGEtYXBpYCxcclxuICAgIHQsXHJcbiAgICBmdW5jdGlvbihlKSB7XHJcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZ3QodGhpcykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xyXG4gICAgfVxyXG4gICk7XHJcbn0sIEtsID0gKGksIHQpID0+IHtcclxuICBkLm9uKFxyXG4gICAgZG9jdW1lbnQsXHJcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfS5kYXRhLWFwaWAsXHJcbiAgICB0LFxyXG4gICAgZnVuY3Rpb24oZSkge1xyXG4gICAgICBjb25zdCBzID0gbnQodGhpcyk7XHJcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZ3QodGhpcykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBkLm9uZShzLCBpLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xyXG4gICAgICAgIGt0KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IG4gPSBoLmZpbmRPbmUoaS5PUEVOX1NFTEVDVE9SKTtcclxuICAgICAgbiAmJiBuICE9PSBzICYmIGkuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBpLmdldE9yQ3JlYXRlSW5zdGFuY2UocykudG9nZ2xlKHRoaXMpO1xyXG4gICAgfVxyXG4gICk7XHJcbn0sIHpsID0gKGksIHQpID0+IHtcclxuICBkLm9uKFxyXG4gICAgZG9jdW1lbnQsXHJcbiAgICBgY2xpY2sudHdlLiR7aS5OQU1FfWAsXHJcbiAgICB0LFxyXG4gICAgKGUpID0+IHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCBzID0gZS50YXJnZXQuY2xvc2VzdCh0KTtcclxuICAgICAgaS5nZXRPckNyZWF0ZUluc3RhbmNlKHMpLnRvZ2dsZSgpO1xyXG4gICAgfVxyXG4gICk7XHJcbn0sIHFsID0gKGksIHQpID0+IHtcclxuICBkLm9uZShcclxuICAgIGRvY3VtZW50LFxyXG4gICAgXCJtb3VzZWRvd25cIixcclxuICAgIHQsXHJcbiAgICBpLmF1dG9Jbml0aWFsKG5ldyBpKCkpXHJcbiAgKTtcclxufSwgWGwgPSAoaSwgdCkgPT4ge1xyXG4gIGQub24oXHJcbiAgICBkb2N1bWVudCxcclxuICAgIGBjbGljay50d2UuJHtpLk5BTUV9LmRhdGEtYXBpYCxcclxuICAgIHQsXHJcbiAgICBmdW5jdGlvbihlKSB7XHJcbiAgICAgIChlLnRhcmdldC50YWdOYW1lID09PSBcIkFcIiB8fCBlLmRlbGVnYXRlVGFyZ2V0ICYmIGUuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gXCJBXCIpICYmIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgcyA9IGNpKHRoaXMpO1xyXG4gICAgICBoLmZpbmQocykuZm9yRWFjaCgocikgPT4ge1xyXG4gICAgICAgIGkuZ2V0T3JDcmVhdGVJbnN0YW5jZShyLCB7IHRvZ2dsZTogITEgfSkudG9nZ2xlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICk7XHJcbn0sIEdsID0gKGksIHQpID0+IHtcclxuICBbXS5zbGljZS5jYWxsKFxyXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KVxyXG4gICkubWFwKGZ1bmN0aW9uKHMpIHtcclxuICAgIHJldHVybiBuZXcgaShzKTtcclxuICB9KTtcclxufSwgUWwgPSAoaSwgdCkgPT4ge1xyXG4gIFtdLnNsaWNlLmNhbGwoXHJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHQpXHJcbiAgKS5tYXAoZnVuY3Rpb24ocykge1xyXG4gICAgcmV0dXJuIG5ldyBpKHMpO1xyXG4gIH0pO1xyXG59LCBabCA9IChpLCB0KSA9PiB7XHJcbiAgZC5vbihcclxuICAgIGRvY3VtZW50LFxyXG4gICAgYGNsaWNrLnR3ZS4ke2kuTkFNRX1gLFxyXG4gICAgdCxcclxuICAgIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgY29uc3QgcyA9IG50KHRoaXMpO1xyXG4gICAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZC5vbmUocywgaS5FVkVOVF9TSE9XLCAobykgPT4ge1xyXG4gICAgICAgIG8uZGVmYXVsdFByZXZlbnRlZCB8fCBkLm9uZShzLCBpLkVWRU5UX0hJRERFTiwgKCkgPT4ge1xyXG4gICAgICAgICAga3QodGhpcykgJiYgdGhpcy5mb2N1cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgbiA9IGguZmluZE9uZShcclxuICAgICAgICBgWyR7aS5PUEVOX1NFTEVDVE9SfT1cInRydWVcIl1gXHJcbiAgICAgICk7XHJcbiAgICAgIG4gJiYgaS5nZXRJbnN0YW5jZShuKS5oaWRlKCksIGkuZ2V0T3JDcmVhdGVJbnN0YW5jZShzKS50b2dnbGUodGhpcyk7XHJcbiAgICB9XHJcbiAgKTtcclxufSwgSmwgPSB7XHJcbiAgY2Fyb3VzZWw6IHtcclxuICAgIG5hbWU6IFwiQ2Fyb3VzZWxcIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1jYXJvdXNlbC1pbml0XVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMVxyXG4gIH0sXHJcbiAgaW5wdXQ6IHtcclxuICAgIG5hbWU6IFwiSW5wdXRcIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1pbnB1dC13cmFwcGVyLWluaXRdXCIsXHJcbiAgICBpc1RvZ2dsZXI6ICExXHJcbiAgfSxcclxuICBzY3JvbGxzcHk6IHtcclxuICAgIG5hbWU6IFwiU2Nyb2xsU3B5XCIsXHJcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2Utc3B5PSdzY3JvbGwnXVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMVxyXG4gIH0sXHJcbiAgLy8gdG9nZ2xlcnNcclxuICBidXR0b246IHtcclxuICAgIG5hbWU6IFwiQnV0dG9uXCIsXHJcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2UtdG9nZ2xlPSdidXR0b24nXVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMCxcclxuICAgIGNhbGxiYWNrOiB6bFxyXG4gIH0sXHJcbiAgY29sbGFwc2U6IHtcclxuICAgIG5hbWU6IFwiQ29sbGFwc2VcIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1jb2xsYXBzZS1pbml0XVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMCxcclxuICAgIGNhbGxiYWNrOiBYbFxyXG4gIH0sXHJcbiAgZHJvcGRvd246IHtcclxuICAgIG5hbWU6IFwiRHJvcGRvd25cIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMCxcclxuICAgIGNhbGxiYWNrOiBGbFxyXG4gIH0sXHJcbiAgcmlwcGxlOiB7XHJcbiAgICBuYW1lOiBcIlJpcHBsZVwiLFxyXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLXJpcHBsZS1pbml0XVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMCxcclxuICAgIGNhbGxiYWNrOiBxbFxyXG4gIH0sXHJcbiAgb2ZmY2FudmFzOiB7XHJcbiAgICBuYW1lOiBcIk9mZmNhbnZhc1wiLFxyXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLW9mZmNhbnZhcy10b2dnbGVdXCIsXHJcbiAgICBpc1RvZ2dsZXI6ICEwLFxyXG4gICAgY2FsbGJhY2s6IEtsXHJcbiAgfSxcclxuICB0YWI6IHtcclxuICAgIG5hbWU6IFwiVGFiXCIsXHJcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10d2UtdG9nZ2xlPSd0YWInXSwgW2RhdGEtdHdlLXRvZ2dsZT0ncGlsbCddLCBbZGF0YS10d2UtdG9nZ2xlPSdsaXN0J11cIixcclxuICAgIGlzVG9nZ2xlcjogITAsXHJcbiAgICBjYWxsYmFjazogWWxcclxuICB9LFxyXG4gIHRvb2x0aXA6IHtcclxuICAgIG5hbWU6IFwiVG9vbHRpcFwiLFxyXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdHdlLXRvZ2dsZT0ndG9vbHRpcCddXCIsXHJcbiAgICBpc1RvZ2dsZXI6ICExLFxyXG4gICAgY2FsbGJhY2s6IEdsXHJcbiAgfSxcclxuICBwb3BvdmVyOiB7XHJcbiAgICBuYW1lOiBcIlBvcG92ZXJcIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS10b2dnbGU9J3BvcG92ZXInXVwiLFxyXG4gICAgaXNUb2dnbGVyOiAhMCxcclxuICAgIGNhbGxiYWNrOiBRbFxyXG4gIH0sXHJcbiAgbW9kYWw6IHtcclxuICAgIG5hbWU6IFwiTW9kYWxcIixcclxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXR3ZS10b2dnbGU9J21vZGFsJ11cIixcclxuICAgIGlzVG9nZ2xlcjogITAsXHJcbiAgICBjYWxsYmFjazogWmxcclxuICB9XHJcbn0sIHRjID0gKGkpID0+IHtcclxuICBWcygoKSA9PiB7XHJcbiAgICBjb25zdCB0ID0gSHMoKTtcclxuICAgIGlmICh0KSB7XHJcbiAgICAgIGNvbnN0IGUgPSBpLk5BTUUsIHMgPSB0LmZuW2VdO1xyXG4gICAgICB0LmZuW2VdID0gaS5qUXVlcnlJbnRlcmZhY2UsIHQuZm5bZV0uQ29uc3RydWN0b3IgPSBpLCB0LmZuW2VdLm5vQ29uZmxpY3QgPSAoKSA9PiAodC5mbltlXSA9IHMsIGkualF1ZXJ5SW50ZXJmYWNlKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuY2xhc3MgZWMge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5pbml0cyA9IFtdO1xyXG4gIH1cclxuICBnZXQgaW5pdGlhbGl6ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbml0cztcclxuICB9XHJcbiAgaXNJbml0ZWQodCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5pdHMuaW5jbHVkZXModCk7XHJcbiAgfVxyXG4gIGFkZCh0KSB7XHJcbiAgICB0aGlzLmlzSW5pdGVkKHQpIHx8IHRoaXMuaW5pdHMucHVzaCh0KTtcclxuICB9XHJcbn1cclxuY29uc3QgbGkgPSBuZXcgZWMoKTtcclxubGV0IER0O1xyXG5jb25zdCBpYyA9IChpKSA9PiBEdFtpLk5BTUVdIHx8IG51bGwsIHNjID0gKGksIHQpID0+IHtcclxuICBpZiAoIWkgfHwgIXQuYWxsb3dSZWluaXRzICYmIGxpLmlzSW5pdGVkKGkuTkFNRSkpXHJcbiAgICByZXR1cm47XHJcbiAgbGkuYWRkKGkuTkFNRSk7XHJcbiAgY29uc3QgZSA9IGljKGkpLCBzID0gKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXNUb2dnbGVyKSB8fCAhMTtcclxuICBpZiAodGMoaSksIGUgIT0gbnVsbCAmJiBlLmFkdmFuY2VkKSB7XHJcbiAgICBlID09IG51bGwgfHwgZS5hZHZhbmNlZChpLCBlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHMpIHtcclxuICAgIGUgPT0gbnVsbCB8fCBlLmNhbGxiYWNrKGksIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc2VsZWN0b3IpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBoLmZpbmQoZSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWxlY3RvcikuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgbGV0IHIgPSBpLmdldEluc3RhbmNlKG4pO1xyXG4gICAgciB8fCAociA9IG5ldyBpKG4pLCBlICE9IG51bGwgJiYgZS5vbkluaXQgJiYgcltlLm9uSW5pdF0oKSk7XHJcbiAgfSk7XHJcbn0sIG5jID0ge1xyXG4gIGFsbG93UmVpbml0czogITEsXHJcbiAgY2hlY2tPdGhlckltcG9ydHM6ICExXHJcbn07XHJcbmNsYXNzIHJjIHtcclxuICBjb25zdHJ1Y3Rvcih0KSB7XHJcbiAgICBOZSh0aGlzLCBcImluaXRcIiwgKHQsIGUpID0+IHtcclxuICAgICAgdC5mb3JFYWNoKChzKSA9PiBzYyhzLCBlKSk7XHJcbiAgICB9KTtcclxuICAgIE5lKHRoaXMsIFwiaW5pdFRXRVwiLCAodCwgZSkgPT4ge1xyXG4gICAgICBjb25zdCBzID0geyAuLi5uYywgLi4uZSB9LCBuID0gT2JqZWN0LmtleXMoRHQpLm1hcCgocikgPT4ge1xyXG4gICAgICAgIGlmICghIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoRHRbcl0uc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICBjb25zdCBhID0gdFtEdFtyXS5uYW1lXTtcclxuICAgICAgICAgIHJldHVybiAhYSAmJiAhbGkuaXNJbml0ZWQocikgJiYgcy5jaGVja090aGVySW1wb3J0cyAmJiBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBQbGVhc2UgaW1wb3J0ICR7RHRbcl0ubmFtZX0gZnJvbSBcInR3LWVsZW1lbnRzXCIgcGFja2FnZSBhbmQgYWRkIGl0IHRvIGEgb2JqZWN0IHBhcmFtZXRlciBpbnNpZGUgXCJpbml0VFdFXCIgZnVuY3Rpb25gXHJcbiAgICAgICAgICApLCBhO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMuaW5pdChuLCBzKTtcclxuICAgIH0pO1xyXG4gICAgRHQgPSB0O1xyXG4gIH1cclxufVxyXG5jb25zdCBvYyA9IG5ldyByYyhKbCksIGxjID0gb2MuaW5pdFRXRTtcclxuZXhwb3J0IHtcclxuICBxcyBhcyBCdXR0b24sXHJcbiAgWiBhcyBDYXJvdXNlbCxcclxuICBwZSBhcyBDb2xsYXBzZSxcclxuICBYIGFzIERyb3Bkb3duLFxyXG4gICQgYXMgSW5wdXQsXHJcbiAgYWkgYXMgTW9kYWwsXHJcbiAgX2UgYXMgT2ZmY2FudmFzLFxyXG4gIE5uIGFzIFBvcG92ZXIsXHJcbiAgSG4gYXMgUmlwcGxlLFxyXG4gIEluIGFzIFNjcm9sbFNweSxcclxuICBSbiBhcyBUYWIsXHJcbiAgUXQgYXMgVG9vbHRpcCxcclxuICBsYyBhcyBpbml0VFdFXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR3LWVsZW1lbnRzLmVzLm1pbi5qcy5tYXBcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tw-elements/js/tw-elements.es.min.js\n");

/***/ })

};
;